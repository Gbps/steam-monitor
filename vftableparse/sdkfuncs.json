{
    "CSteamAPIContext": {
        "cppclass": "CSteamAPIContext",
        "cppinterface": null,
        "cppinterfacev": null,
        "funcs": [
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ]
                ],
                "argsstr": "void *pvParam",
                "comments": "DEPRECATED - there is no benefit to using this over the global accessors\nCSteamAPIContext() { Clear(); }\nvoid Clear();\nbool Init();\nISteamClient*SteamClient() const{ return m_pSteamClient; }\nISteamUser*SteamUser() const{ return m_pSteamUser; }\nISteamFriends*SteamFriends() const{ return m_pSteamFriends; }\nISteamUtils*SteamUtils() const{ return m_pSteamUtils; }\nISteamMatchmaking*SteamMatchmaking() const{ return m_pSteamMatchmaking; }\nISteamUserStats*SteamUserStats() const{ return m_pSteamUserStats; }\nISteamApps*SteamApps() const{ return m_pSteamApps; }\nISteamMatchmakingServers* SteamMatchmakingServers() const { return m_pSteamMatchmakingServers; }\nISteamNetworking*SteamNetworking() const{ return m_pSteamNetworking; }\nISteamRemoteStorage* SteamRemoteStorage() const{ return m_pSteamRemoteStorage; }\nISteamScreenshots*SteamScreenshots() const{ return m_pSteamScreenshots; }\nISteamHTTP*SteamHTTP() const{ return m_pSteamHTTP; }\nISteamController*SteamController() const{ return m_pController; }\nISteamUGC*SteamUGC() const{ return m_pSteamUGC; }\nISteamAppList*SteamAppList() const{ return m_pSteamAppList; }\nISteamMusic*SteamMusic() const{ return m_pSteamMusic; }\nISteamMusicRemote*SteamMusicRemote() const{ return m_pSteamMusicRemote; }\nISteamHTMLSurface*SteamHTMLSurface() const{ return m_pSteamHTMLSurface; }\nISteamInventory*SteamInventory() const{ return m_pSteamInventory; }\nISteamVideo*SteamVideo() const{ return m_pSteamVideo; }\nISteamParentalSettings* SteamParentalSettings() const{ return m_pSteamParentalSettings; }\n DEPRECATED - there is no benefit to using this over the global accessors\nprivate:\nISteamClient*m_pSteamClient;\nISteamUser*m_pSteamUser;\nISteamFriends*m_pSteamFriends;\nISteamUtils*m_pSteamUtils;\nISteamMatchmaking*m_pSteamMatchmaking;\nISteamUserStats*m_pSteamUserStats;\nISteamApps*m_pSteamApps;\nISteamMatchmakingServers *m_pSteamMatchmakingServers;\nISteamNetworking*m_pSteamNetworking;\nISteamRemoteStorage *m_pSteamRemoteStorage;\nISteamScreenshots*m_pSteamScreenshots;\nISteamHTTP*m_pSteamHTTP;\nISteamController*m_pController;\nISteamUGC*m_pSteamUGC;\nISteamAppList*m_pSteamAppList;\nISteamMusic*m_pSteamMusic;\nISteamMusicRemote*m_pSteamMusicRemote;\nISteamHTMLSurface*m_pSteamHTMLSurface;\nISteamInventory*m_pSteamInventory;\nISteamVideo*m_pSteamVideo;\nISteamParentalSettings *m_pSteamParentalSettings;\n};\n\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------\nsteam callback and call-result helpers\n\nThe following macros and classes are used to register your application for\ncallbacks and call-results, which are delivered in a predictable manner.\n\nSTEAM_CALLBACK macros are meant for use inside of a C++ class definition.\nThey map a Steam notification callback directly to a class member function\nwhich is automatically prototyped as \"void func( callback_type *pParam )\".\n\nCCallResult is used with specific Steam APIs that return \"result handles\".\nThe handle can be passed to a CCallResult object's Set function, along with\nan object pointer and member-function pointer. The member function will\nbe executed once the results of the Steam API call are available.\n\nCCallback and CCallbackManual classes can be used instead of STEAM_CALLBACK\nmacros if you require finer control over registration and unregistration.\n\nCallbacks and call-results are queued automatically and are only\ndelivered/executed when your application calls SteamAPI_RunCallbacks().\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n SteamAPI_RunCallbacks is safe to call from multiple threads simultaneously,\n but if you choose to do this, callback code could be executed on any thread.\n One alternative is to call SteamAPI_RunCallbacks from the main thread only,\n and call SteamAPI_ReleaseCurrentThreadMemory regularly on other threads.\nS_API void S_CALLTYPE SteamAPI_RunCallbacks();\n\n\n Declares a callback member function plus a helper member variable which\n registers the callback on object creation and unregisters on destruction.\n The optional fourth 'var' param exists only for backwards-compatibility\n and can be ignored.\n#define STEAM_CALLBACK( thisclass, func, .../*callback_type, [deprecated] var*/ ) \\\n_STEAM_CALLBACK_SELECT( ( __VA_ARGS__, 4, 3 ), ( /**/, thisclass, func, __VA_ARGS__ ) )\n\n Declares a callback function and a named CCallbackManual variable which\n has Register and Unregister functions instead of automatic registration.\n#define STEAM_CALLBACK_MANUAL( thisclass, func, callback_type, var )\\\nCCallbackManual< thisclass, callback_type > var; void func( callback_type *pParam )\n\n\n Internal functions used by the utility CCallback objects to receive callbacks\nS_API void S_CALLTYPE SteamAPI_RegisterCallback( class CCallbackBase *pCallback, int iCallback );\nS_API void S_CALLTYPE SteamAPI_UnregisterCallback( class CCallbackBase *pCallback );\n Internal functions used by the utility CCallResult objects to receive async call results\nS_API void S_CALLTYPE SteamAPI_RegisterCallResult( class CCallbackBase *pCallback, SteamAPICall_t hAPICall );\nS_API void S_CALLTYPE SteamAPI_UnregisterCallResult( class CCallbackBase *pCallback, SteamAPICall_t hAPICall );\n\n\n-----------------------------------------------------------------------------\n Purpose: base for callbacks and call results - internal implementation detail\n-----------------------------------------------------------------------------\nclass CCallbackBase\n{\npublic:\nCCallbackBase() { m_nCallbackFlags = 0; m_iCallback = 0; }\n don't add a virtual destructor because we export this binary interface across dll's",
                "name": "Run",
                "nargs": 1,
                "retval": "void",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ],
                    [
                        "bool",
                        "bIOFailure"
                    ],
                    [
                        "SteamAPICall_t",
                        "hSteamAPICall"
                    ]
                ],
                "argsstr": "void *pvParam, bool bIOFailure, SteamAPICall_t hSteamAPICall",
                "name": "Run",
                "nargs": 3,
                "retval": "void",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetCallbackSizeBytes",
                "nargs": 0,
                "retval": "int",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ]
                ],
                "argsstr": "void *pvParam",
                "comments": "-----------------------------------------------------------------------------\n Purpose: templated base for callbacks - internal implementation detail\n-----------------------------------------------------------------------------\ntemplate< int sizeof_P >\nclass CCallbackImpl : protected CCallbackBase\n{\npublic:\n~CCallbackImpl() { if ( m_nCallbackFlags & k_ECallbackFlagsRegistered ) SteamAPI_UnregisterCallback( this ); }\nvoid SetGameserverFlag() { m_nCallbackFlags |= k_ECallbackFlagsGameServer; }\n\nprotected:",
                "name": "Run",
                "nargs": 1,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ],
                    [
                        "bool",
                        "/*bIOFailure*/"
                    ],
                    [
                        "SteamAPICall_t",
                        "/*hSteamAPICall*/"
                    ]
                ],
                "argsstr": "void *pvParam, bool /*bIOFailure*/, SteamAPICall_t /*hSteamAPICall*/",
                "name": "Run",
                "nargs": 3,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetCallbackSizeBytes",
                "nargs": 0,
                "retval": "int",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ]
                ],
                "argsstr": "void *pvParam",
                "comments": "-----------------------------------------------------------------------------\n Purpose: maps a steam async call result to a class member function\ntemplate params: T = local class, P = parameter struct\n-----------------------------------------------------------------------------\ntemplate< class T, class P >\nclass CCallResult : private CCallbackBase\n{\npublic:\ntypedef void (T::*func_t)( P*, bool );\n\nCCallResult();\n~CCallResult();\n\nvoid Set( SteamAPICall_t hAPICall, T *p, func_t func );\nbool IsActive() const;\nvoid Cancel();\n\nvoid SetGameserverFlag() { m_nCallbackFlags |= k_ECallbackFlagsGameServer; }\nprivate:",
                "name": "Run",
                "nargs": 1,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ],
                    [
                        "bool",
                        "bIOFailure"
                    ],
                    [
                        "SteamAPICall_t",
                        "hSteamAPICall"
                    ]
                ],
                "argsstr": "void *pvParam, bool bIOFailure, SteamAPICall_t hSteamAPICall",
                "name": "Run",
                "nargs": 3,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetCallbackSizeBytes",
                "nargs": 0,
                "retval": "int",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "void*",
                        "pvParam"
                    ]
                ],
                "argsstr": "void *pvParam",
                "comments": "-----------------------------------------------------------------------------\n Purpose: maps a steam callback to a class member function\ntemplate params: T = local class, P = parameter struct,\nbGameserver = listen for gameserver callbacks instead of client callbacks\n-----------------------------------------------------------------------------\ntemplate< class T, class P, bool bGameserver = false >\nclass CCallback : public CCallbackImpl< sizeof( P ) >\n{\npublic:\ntypedef void (T::*func_t)(P*);\n\n NOTE: If you can't provide the correct parameters at construction time, you should\n use the CCallbackManual callback object (STEAM_CALLBACK_MANUAL macro) instead.\nCCallback( T *pObj, func_t func );\n\nvoid Register( T *pObj, func_t func );\nvoid Unregister();\n\nprotected:",
                "name": "Run",
                "nargs": 1,
                "retval": "void",
                "vfindex": 9
            }
        ]
    },
    "ISteamAppList": {
        "cppclass": "ISteamAppList",
        "cppinterface": "STEAMAPPLIST_INTERFACE_VERSION",
        "cppinterfacev": "STEAMAPPLIST_INTERFACE_VERSION001",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "name": "GetNumInstalledApps",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "AppId_t*",
                        "pvecAppID"
                    ],
                    [
                        "uint32",
                        "unMaxAppIDs"
                    ]
                ],
                "argsstr": "AppId_t *pvecAppID, uint32 unMaxAppIDs",
                "name": "GetInstalledApps",
                "nargs": 2,
                "retval": "uint32",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "comments": "Returns -1 if no name was found\nvirtual int  GetAppInstallDir( AppId_t nAppID, char *pchDirectory, int cchNameMax ) = 0;  returns -1 if no dir was found",
                "name": "GetAppBuildId",
                "nargs": 1,
                "retval": "int",
                "vfindex": 2
            }
        ]
    },
    "ISteamAppTicket": {
        "cppclass": "ISteamAppTicket",
        "cppinterface": "STEAMAPPTICKET_INTERFACE_VERSION",
        "cppinterfacev": "STEAMAPPTICKET_INTERFACE_VERSION001",
        "funcs": [
            {
                "args": [
                    [
                        "uint32",
                        "nAppID"
                    ],
                    [
                        "void*",
                        "pvBuffer"
                    ],
                    [
                        "uint32",
                        "cbBufferLength"
                    ],
                    [
                        "uint32*",
                        "piAppId"
                    ],
                    [
                        "uint32*",
                        "piSteamId"
                    ],
                    [
                        "uint32*",
                        "piSignature"
                    ],
                    [
                        "uint32*",
                        "pcbSignature"
                    ]
                ],
                "argsstr": "uint32 nAppID, void *pvBuffer, uint32 cbBufferLength, uint32 *piAppId, uint32 *piSteamId, uint32 *piSignature, uint32 *pcbSignature",
                "name": "GetAppOwnershipTicketData",
                "nargs": 7,
                "retval": "uint32",
                "vfindex": 0
            }
        ]
    },
    "ISteamApps": {
        "cppclass": "ISteamApps",
        "cppinterface": "STEAMAPPS_INTERFACE_VERSION",
        "cppinterfacev": "STEAMAPPS_INTERFACE_VERSION008",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "name": "BIsSubscribed",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsLowViolence",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsCybercafe",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsVACBanned",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetCurrentGameLanguage",
                "nargs": 0,
                "retval": "const char *",
                "vfindex": 4
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetAvailableGameLanguages",
                "nargs": 0,
                "retval": "const char *",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "appID"
                    ]
                ],
                "argsstr": "AppId_t appID",
                "comments": "Only use this member if you need to check ownership of another game related to yours, a demo for example",
                "name": "BIsSubscribedApp",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "appID"
                    ]
                ],
                "argsstr": "AppId_t appID",
                "comments": "Takes AppID of DLC and checks if the user owns the DLC & if the DLC is installed",
                "name": "BIsDlcInstalled",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "comments": "Returns the Unix time of the purchase of the app",
                "name": "GetEarliestPurchaseUnixTime",
                "nargs": 1,
                "retval": "uint32",
                "vfindex": 8
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Checks if the user is subscribed to the current app through a free weekend\n This function will return false for users who have a retail or other type of license\n Before using, please ask your Valve technical contact how to package and secure your free weekened",
                "name": "BIsSubscribedFromFreeWeekend",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the number of DLC pieces for the running app",
                "name": "GetDLCCount",
                "nargs": 0,
                "retval": "int",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "int",
                        "iDLC"
                    ],
                    [
                        "AppId_t*",
                        "pAppID"
                    ],
                    [
                        "bool*",
                        "pbAvailable"
                    ],
                    [
                        "char*",
                        "pchName"
                    ],
                    [
                        "int",
                        "cchNameBufferSize"
                    ]
                ],
                "argsstr": "int iDLC, AppId_t *pAppID, bool *pbAvailable, char *pchName, int cchNameBufferSize",
                "comments": "Returns metadata for DLC by index, of range [0, GetDLCCount()]",
                "name": "BGetDLCDataByIndex",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "comments": "Install/Uninstall control for optional DLC",
                "name": "InstallDLC",
                "nargs": 1,
                "retval": "void",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "name": "UninstallDLC",
                "nargs": 1,
                "retval": "void",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "comments": "Request legacy cd-key for yourself or owned DLC. If you are interested in this\n data then make sure you provide us with a list of valid keys to be distributed\n to users when they purchase the game, before the game ships.\n You'll receive an AppProofOfPurchaseKeyResponse_t callback when\n the key is available (which may be immediately).",
                "name": "RequestAppProofOfPurchaseKey",
                "nargs": 1,
                "retval": "void",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "char*",
                        "pchName"
                    ],
                    [
                        "int",
                        "cchNameBufferSize"
                    ]
                ],
                "argsstr": "char *pchName, int cchNameBufferSize",
                "name": "GetCurrentBetaName",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "bool",
                        "bMissingFilesOnly"
                    ]
                ],
                "argsstr": "bool bMissingFilesOnly",
                "comments": "Returns current beta branch name, 'public' is the default branch",
                "name": "MarkContentCorrupt",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "appID"
                    ],
                    [
                        "DepotId_t*",
                        "pvecDepots"
                    ],
                    [
                        "uint32",
                        "cMaxDepots"
                    ]
                ],
                "argsstr": "AppId_t appID, DepotId_t *pvecDepots, uint32 cMaxDepots",
                "comments": "Signal Steam that game files seems corrupt or missing",
                "name": "GetInstalledDepots",
                "nargs": 3,
                "retval": "uint32",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "appID"
                    ],
                    [
                        "char*",
                        "pchFolder"
                    ],
                    [
                        "uint32",
                        "cchFolderBufferSize"
                    ]
                ],
                "argsstr": "AppId_t appID, char *pchFolder, uint32 cchFolderBufferSize",
                "comments": "Return installed depots in mount order\n\n returns current app install folder for AppID, returns folder name length",
                "name": "GetAppInstallDir",
                "nargs": 3,
                "retval": "uint32",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "appID"
                    ]
                ],
                "argsstr": "AppId_t appID",
                "name": "BIsAppInstalled",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if that app is installed (not necessarily owned)",
                "name": "GetAppOwner",
                "nargs": 0,
                "retval": "CSteamID",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "const char *pchKey",
                "comments": "Returns the SteamID of the original owner. If different from current user, it's borrowed\n\n Returns the associated launch param if the game is run via steam:run/<appid>?param1=value1;param2=value2;param3=value3 etc.\n Parameter names starting with the character '@' are reserved for internal use and will always return and empty string.\n Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game,\n but it is advised that you not param names beginning with an underscore for your own features.",
                "name": "GetLaunchQueryParam",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ],
                    [
                        "uint64*",
                        "punBytesDownloaded"
                    ],
                    [
                        "uint64*",
                        "punBytesTotal"
                    ]
                ],
                "argsstr": "AppId_t nAppID, uint64 *punBytesDownloaded, uint64 *punBytesTotal",
                "comments": "Get download progress for optional DLC",
                "name": "GetDlcDownloadProgress",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Return the buildid of this app, may change at any time based on backend updates to the game",
                "name": "GetAppBuildId",
                "nargs": 0,
                "retval": "int",
                "vfindex": 23
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Request all proof of purchase keys for the calling appid and asociated DLC.\n A series of AppProofOfPurchaseKeyResponse_t callbacks will be sent with\n appropriate appid values, ending with a final callback where the m_nAppId\n member is k_uAppIdInvalid (zero).",
                "name": "RequestAllProofOfPurchaseKeys",
                "nargs": 0,
                "retval": "void",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszFileName"
                    ]
                ],
                "argsstr": "const char* pszFileName",
                "name": "GetFileDetails",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 25
            }
        ]
    },
    "ISteamClient": {
        "cppclass": "ISteamClient",
        "cppinterface": null,
        "cppinterfacev": null,
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Creates a communication pipe to the Steam client.\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling",
                "name": "CreateSteamPipe",
                "nargs": 0,
                "retval": "HSteamPipe",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ]
                ],
                "argsstr": "HSteamPipe hSteamPipe",
                "comments": "Releases a previously created communications pipe\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling",
                "name": "BReleaseSteamPipe",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ]
                ],
                "argsstr": "HSteamPipe hSteamPipe",
                "comments": "Connects to an existing global user, failing if none exists\n used by the game to coordinate with the steamUI\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling",
                "name": "ConnectToGlobalUser",
                "nargs": 1,
                "retval": "HSteamUser",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "HSteamPipe*",
                        "phSteamPipe"
                    ],
                    [
                        "EAccountType",
                        "eAccountType"
                    ]
                ],
                "argsstr": "HSteamPipe *phSteamPipe, EAccountType eAccountType",
                "comments": "Used by game servers, create a steam user that won't be shared with anyone else\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling",
                "name": "CreateLocalUser",
                "nargs": 2,
                "retval": "HSteamUser",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "HSteamUser",
                        "hUser"
                    ]
                ],
                "argsstr": "HSteamPipe hSteamPipe, HSteamUser hUser",
                "comments": "Removes an allocated user\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling",
                "name": "ReleaseUser",
                "nargs": 2,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Retrieves the ISteamUser interface associated with the handle",
                "name": "GetISteamUser",
                "nargs": 3,
                "retval": "ISteamUser *",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Retrieves the ISteamGameServer interface associated with the handle",
                "name": "GetISteamGameServer",
                "nargs": 3,
                "retval": "ISteamGameServer *",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIP"
                    ],
                    [
                        "uint16",
                        "usPort"
                    ]
                ],
                "argsstr": "uint32 unIP, uint16 usPort",
                "comments": "Set the local IP and Port to bind to\n this must be set before CreateLocalUser()",
                "name": "SetLocalIPBinding",
                "nargs": 2,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamFriends interface",
                "name": "GetISteamFriends",
                "nargs": 3,
                "retval": "ISteamFriends *",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamUtils interface",
                "name": "GetISteamUtils",
                "nargs": 2,
                "retval": "ISteamUtils *",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamMatchmaking interface",
                "name": "GetISteamMatchmaking",
                "nargs": 3,
                "retval": "ISteamMatchmaking *",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamMatchmakingServers interface",
                "name": "GetISteamMatchmakingServers",
                "nargs": 3,
                "retval": "ISteamMatchmakingServers *",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the a generic interface",
                "name": "GetISteamGenericInterface",
                "nargs": 3,
                "retval": "void *",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamUserStats interface",
                "name": "GetISteamUserStats",
                "nargs": 3,
                "retval": "ISteamUserStats *",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns the ISteamGameServerStats interface",
                "name": "GetISteamGameServerStats",
                "nargs": 3,
                "retval": "ISteamGameServerStats *",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns apps interface",
                "name": "GetISteamApps",
                "nargs": 3,
                "retval": "ISteamApps *",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Networking",
                "name": "GetISteamNetworking",
                "nargs": 3,
                "retval": "ISteamNetworking *",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Remote storage",
                "name": "GetISteamRemoteStorage",
                "nargs": 3,
                "retval": "ISteamRemoteStorage *",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "User screenshots",
                "name": "GetISteamScreenshots",
                "nargs": 3,
                "retval": "ISteamScreenshots *",
                "vfindex": 18
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Deprecated. Applications should use SteamAPI_RunCallbacks() or SteamGameServer_RunCallbacks() instead.\nSTEAM_PRIVATE_API(",
                "name": "RunFrame",
                "nargs": 0,
                "retval": "void",
                "vfindex": 19
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the number of IPC calls made since the last time this function was called\n Used for perf debugging so you can understand how many IPC calls your game makes per frame\n Every IPC call is at minimum a thread context switch if not a process one so you want to rate\n control how often you do them.",
                "name": "GetIPCCallCount",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "SteamAPIWarningMessageHook_t",
                        "pFunction"
                    ]
                ],
                "argsstr": "SteamAPIWarningMessageHook_t pFunction",
                "comments": "API warning handling\n 'int' is the severity; 0 for msg, 1 for warning\n 'const char *' is the text of the message\n callbacks will occur directly after the API function is called that generated the warning or message.",
                "name": "SetWarningMessageHook",
                "nargs": 1,
                "retval": "void",
                "vfindex": 21
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Trigger global shutdown for the DLL",
                "name": "BShutdownIfAllPipesClosed",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Expose HTTP interface",
                "name": "GetISteamHTTP",
                "nargs": 3,
                "retval": "ISteamHTTP *",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Deprecated - the ISteamUnifiedMessages interface is no longer intended for public consumption.\nSTEAM_PRIVATE_API(",
                "name": "DEPRECATED_GetISteamUnifiedMessages",
                "nargs": 3,
                "retval": "void *",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Exposes the ISteamController interface",
                "name": "GetISteamController",
                "nargs": 3,
                "retval": "ISteamController *",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Exposes the ISteamUGC interface",
                "name": "GetISteamUGC",
                "nargs": 3,
                "retval": "ISteamUGC *",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamUser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Returns app list interface, only available on specially registered apps",
                "name": "GetISteamAppList",
                "nargs": 3,
                "retval": "ISteamAppList *",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Music Player",
                "name": "GetISteamMusic",
                "nargs": 3,
                "retval": "ISteamMusic *",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Music Player Remote",
                "name": "GetISteamMusicRemote",
                "nargs": 3,
                "retval": "ISteamMusicRemote *",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Html page display",
                "name": "GetISteamHTMLSurface",
                "nargs": 3,
                "retval": "ISteamHTMLSurface *",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "void",
                        "(*"
                    ]
                ],
                "argsstr": "void (*",
                "comments": "Helper functions for internal Steam usage\nSTEAM_PRIVATE_API(",
                "name": "DEPRECATED_Set_SteamAPI_CPostAPIResultInProcess",
                "nargs": 1,
                "retval": "void",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "void",
                        "(*"
                    ]
                ],
                "argsstr": "void (*",
                "name": "DEPRECATED_Remove_SteamAPI_CPostAPIResultInProcess",
                "nargs": 1,
                "retval": "void",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "SteamAPI_CheckCallbackRegistered_t",
                        "func"
                    ]
                ],
                "argsstr": "SteamAPI_CheckCallbackRegistered_t func",
                "name": "Set_SteamAPI_CCheckCallbackRegisteredInProcess",
                "nargs": 1,
                "retval": "void",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Inventory",
                "name": "GetISteamInventory",
                "nargs": 3,
                "retval": "ISteamInventory *",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Video",
                "name": "GetISteamVideo",
                "nargs": 3,
                "retval": "ISteamVideo *",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "HSteamUser",
                        "hSteamuser"
                    ],
                    [
                        "HSteamPipe",
                        "hSteamPipe"
                    ],
                    [
                        "constchar*",
                        "pchVersion"
                    ]
                ],
                "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion",
                "comments": "Parental controls",
                "name": "GetISteamParentalSettings",
                "nargs": 3,
                "retval": "ISteamParentalSettings *",
                "vfindex": 36
            }
        ]
    },
    "ISteamController": {
        "cppclass": "ISteamController",
        "cppinterface": "STEAMCONTROLLER_INTERFACE_VERSION",
        "cppinterfacev": "SteamController006",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Init and Shutdown must be called when starting/ending use of this interface",
                "name": "Init",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "Shutdown",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Synchronize API state with the latest Steam Controller inputs available. This\n is performed automatically by SteamAPI_RunCallbacks, but for the absolute lowest\n possible latency, you call this directly before reading controller state.",
                "name": "RunFrame",
                "nargs": 0,
                "retval": "void",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "ControllerHandle_t*",
                        "handlesOut"
                    ]
                ],
                "argsstr": "ControllerHandle_t *handlesOut",
                "comments": "Enumerate currently connected controllers\n handlesOut should point to a STEAM_CONTROLLER_MAX_COUNT sized array of ControllerHandle_t handles\n Returns the number of handles written to handlesOut",
                "name": "GetConnectedControllers",
                "nargs": 1,
                "retval": "int",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle",
                "comments": "Invokes the Steam overlay and brings up the binding screen\n Returns false is overlay is disabled / unavailable, or the user is not in Big Picture mode",
                "name": "ShowBindingPanel",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszActionSetName"
                    ]
                ],
                "argsstr": "const char *pszActionSetName",
                "comments": "ACTION SETS\n Lookup the handle for an Action Set. Best to do this once on startup, and store the handles for all future API calls.",
                "name": "GetActionSetHandle",
                "nargs": 1,
                "retval": "ControllerActionSetHandle_t",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t",
                        "actionSetHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle",
                "comments": "Reconfigure the controller to use the specified action set (ie 'Menu', 'Walk' or 'Drive')\n This is cheap, and can be safely called repeatedly. It's often easier to repeatedly call it in\n your state loops, instead of trying to place it in all of your state transitions.",
                "name": "ActivateActionSet",
                "nargs": 2,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle",
                "name": "GetCurrentActionSet",
                "nargs": 1,
                "retval": "ControllerActionSetHandle_t",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t",
                        "actionSetLayerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle",
                "name": "ActivateActionSetLayer",
                "nargs": 2,
                "retval": "void",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t",
                        "actionSetLayerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle",
                "name": "DeactivateActionSetLayer",
                "nargs": 2,
                "retval": "void",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle",
                "name": "DeactivateAllActionSetLayers",
                "nargs": 1,
                "retval": "void",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t*",
                        "handlesOut"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t *handlesOut",
                "name": "GetActiveActionSetLayers",
                "nargs": 2,
                "retval": "int",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszActionName"
                    ]
                ],
                "argsstr": "const char *pszActionName",
                "comments": "ACTIONS\n Lookup the handle for a digital action. Best to do this once on startup, and store the handles for all future API calls.",
                "name": "GetDigitalActionHandle",
                "nargs": 1,
                "retval": "ControllerDigitalActionHandle_t",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerDigitalActionHandle_t",
                        "digitalActionHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle",
                "comments": "Returns the current state of the supplied digital game action",
                "name": "GetDigitalActionData",
                "nargs": 2,
                "retval": "ControllerDigitalActionData_t",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t",
                        "actionSetHandle"
                    ],
                    [
                        "ControllerDigitalActionHandle_t",
                        "digitalActionHandle"
                    ],
                    [
                        "EControllerActionOrigin*",
                        "originsOut"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerDigitalActionHandle_t digitalActionHandle, EControllerActionOrigin *originsOut",
                "comments": "Get the origin(s) for a digital action within an action set. Returns the number of origins supplied in originsOut. Use this to display the appropriate on-screen prompt for the action.\n originsOut should point to a STEAM_CONTROLLER_MAX_ORIGINS sized array of EControllerActionOrigin handles",
                "name": "GetDigitalActionOrigins",
                "nargs": 4,
                "retval": "int",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszActionName"
                    ]
                ],
                "argsstr": "const char *pszActionName",
                "comments": "Lookup the handle for an analog action. Best to do this once on startup, and store the handles for all future API calls.",
                "name": "GetAnalogActionHandle",
                "nargs": 1,
                "retval": "ControllerAnalogActionHandle_t",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerAnalogActionHandle_t",
                        "analogActionHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle",
                "comments": "Returns the current state of these supplied analog game action",
                "name": "GetAnalogActionData",
                "nargs": 2,
                "retval": "ControllerAnalogActionData_t",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerActionSetHandle_t",
                        "actionSetHandle"
                    ],
                    [
                        "ControllerAnalogActionHandle_t",
                        "analogActionHandle"
                    ],
                    [
                        "EControllerActionOrigin*",
                        "originsOut"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerAnalogActionHandle_t analogActionHandle, EControllerActionOrigin *originsOut",
                "comments": "Get the origin(s) for an analog action within an action set. Returns the number of origins supplied in originsOut. Use this to display the appropriate on-screen prompt for the action.\n originsOut should point to a STEAM_CONTROLLER_MAX_ORIGINS sized array of EControllerActionOrigin handles",
                "name": "GetAnalogActionOrigins",
                "nargs": 4,
                "retval": "int",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerAnalogActionHandle_t",
                        "eAction"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t eAction",
                "name": "StopAnalogActionMomentum",
                "nargs": 2,
                "retval": "void",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ESteamControllerPad",
                        "eTargetPad"
                    ],
                    [
                        "unsignedshort",
                        "usDurationMicroSec"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ESteamControllerPad eTargetPad, unsigned short usDurationMicroSec",
                "comments": "Trigger a haptic pulse on a controller",
                "name": "TriggerHapticPulse",
                "nargs": 3,
                "retval": "void",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ESteamControllerPad",
                        "eTargetPad"
                    ],
                    [
                        "unsignedshort",
                        "usDurationMicroSec"
                    ],
                    [
                        "unsignedshort",
                        "usOffMicroSec"
                    ],
                    [
                        "unsignedshort",
                        "unRepeat"
                    ],
                    [
                        "unsignedint",
                        "nFlags"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ESteamControllerPad eTargetPad, unsigned short usDurationMicroSec, unsigned short usOffMicroSec, unsigned short unRepeat, unsigned int nFlags",
                "comments": "Trigger a pulse with a duty cycle of usDurationMicroSec / usOffMicroSec, unRepeat times.\n nFlags is currently unused and reserved for future use.",
                "name": "TriggerRepeatedHapticPulse",
                "nargs": 6,
                "retval": "void",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "unsignedshort",
                        "usLeftSpeed"
                    ],
                    [
                        "unsignedshort",
                        "usRightSpeed"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, unsigned short usLeftSpeed, unsigned short usRightSpeed",
                "comments": "Tigger a vibration event on supported controllers.",
                "name": "TriggerVibration",
                "nargs": 3,
                "retval": "void",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "uint8",
                        "nColorR"
                    ],
                    [
                        "uint8",
                        "nColorG"
                    ],
                    [
                        "uint8",
                        "nColorB"
                    ],
                    [
                        "unsignedint",
                        "nFlags"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, uint8 nColorR, uint8 nColorG, uint8 nColorB, unsigned int nFlags",
                "comments": "Set the controller LED color on supported controllers.",
                "name": "SetLEDColor",
                "nargs": 5,
                "retval": "void",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "ulControllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t ulControllerHandle",
                "comments": "Returns the associated gamepad index for the specified controller, if emulating a gamepad",
                "name": "GetGamepadIndexForController",
                "nargs": 1,
                "retval": "int",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "int",
                        "nIndex"
                    ]
                ],
                "argsstr": "int nIndex",
                "comments": "Returns the associated controller handle for the specified emulated gamepad",
                "name": "GetControllerForGamepadIndex",
                "nargs": 1,
                "retval": "ControllerHandle_t",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle",
                "comments": "Returns raw motion data from the specified controller",
                "name": "GetMotionData",
                "nargs": 1,
                "retval": "ControllerMotionData_t",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerDigitalActionHandle_t",
                        "digitalActionHandle"
                    ],
                    [
                        "float",
                        "flScale"
                    ],
                    [
                        "float",
                        "flXPosition"
                    ],
                    [
                        "float",
                        "flYPosition"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle, float flScale, float flXPosition, float flYPosition",
                "comments": "Attempt to display origins of given action in the controller HUD, for the currently active action set\n Returns false is overlay is disabled / unavailable, or the user is not in Big Picture mode",
                "name": "ShowDigitalActionOrigins",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ],
                    [
                        "ControllerAnalogActionHandle_t",
                        "analogActionHandle"
                    ],
                    [
                        "float",
                        "flScale"
                    ],
                    [
                        "float",
                        "flXPosition"
                    ],
                    [
                        "float",
                        "flYPosition"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle, float flScale, float flXPosition, float flYPosition",
                "name": "ShowAnalogActionOrigins",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "EControllerActionOrigin",
                        "eOrigin"
                    ]
                ],
                "argsstr": "EControllerActionOrigin eOrigin",
                "comments": "Returns a localized string (from Steam's language setting) for the specified origin",
                "name": "GetStringForActionOrigin",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "EControllerActionOrigin",
                        "eOrigin"
                    ]
                ],
                "argsstr": "EControllerActionOrigin eOrigin",
                "comments": "Get a local path to art for on-screen glyph for a particular origin",
                "name": "GetGlyphForActionOrigin",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "ControllerHandle_t",
                        "controllerHandle"
                    ]
                ],
                "argsstr": "ControllerHandle_t controllerHandle",
                "comments": "Returns the input type for a particular handle",
                "name": "GetInputTypeForHandle",
                "nargs": 1,
                "retval": "ESteamInputType",
                "vfindex": 30
            }
        ]
    },
    "ISteamFriends": {
        "cppclass": "ISteamFriends",
        "cppinterface": "STEAMFRIENDS_INTERFACE_VERSION",
        "cppinterfacev": "SteamFriends015",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the local players name - guaranteed to not be NULL.\n this is the same name as on the users community profile page\n this is stored in UTF-8 format\n like all the other interface functions that return a char *, it's important that this pointer is not saved\n off; it will eventually be free'd or re-allocated",
                "name": "GetPersonaName",
                "nargs": 0,
                "retval": "const char *",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchPersonaName"
                    ]
                ],
                "argsstr": "const char *pchPersonaName",
                "comments": "Sets the player name, stores it on the server and publishes the changes to all friends who are online.\n Changes take place locally immediately, and a PersonaStateChange_t is posted, presuming success.\n\n The final results are available through the return value SteamAPICall_t, using SetPersonaNameResponse_t.\n\n If the name change fails to happen on the server, then an additional global PersonaStateChange_t will be posted\n to change the name back, in addition to the SetPersonaNameResponse_t callback.\nCALL_RESULT( SetPersonaNameResponse_t )",
                "name": "SetPersonaName",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets the status of the current user",
                "name": "GetPersonaState",
                "nargs": 0,
                "retval": "EPersonaState",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "int",
                        "iFriendFlags"
                    ]
                ],
                "argsstr": "int iFriendFlags",
                "comments": "Friend iteration\n takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria\n then GetFriendByIndex() can then be used to return the id's of each of those users",
                "name": "GetFriendCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "int",
                        "iFriend"
                    ],
                    [
                        "int",
                        "iFriendFlags"
                    ]
                ],
                "argsstr": "int iFriend, int iFriendFlags",
                "comments": "Returns the steamID of a user\n iFriend is a index of range [0, GetFriendCount())\n iFriendsFlags must be the same value as used in GetFriendCount()\n the returned CSteamID can then be used by all the functions below to access details about the user",
                "name": "GetFriendByIndex",
                "nargs": 2,
                "retval": "CSteamID",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Returns a relationship to a user",
                "name": "GetFriendRelationship",
                "nargs": 1,
                "retval": "EFriendRelationship",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Returns the current status of the specified user\n this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user",
                "name": "GetFriendPersonaState",
                "nargs": 1,
                "retval": "EPersonaState",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Returns the name another user - guaranteed to not be NULL.\n same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user\n note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously",
                "name": "GetFriendPersonaName",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "FriendGameInfo_t*",
                        "pFriendGameInfo"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend,  FriendGameInfo_t *pFriendGameInfo",
                "comments": "Returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details",
                "name": "GetFriendGamePlayed",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "int",
                        "iPersonaName"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, int iPersonaName",
                "comments": "Accesses old friends names - returns an empty string when their are no more items in the history",
                "name": "GetFriendPersonaNameHistory",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Friends steam level",
                "name": "GetFriendSteamLevel",
                "nargs": 1,
                "retval": "int",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDPlayer"
                    ]
                ],
                "argsstr": "CSteamID steamIDPlayer",
                "comments": "Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.",
                "name": "GetPlayerNickname",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 11
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Friend grouping (tag) apis\n returns the number of friends groups",
                "name": "GetFriendsGroupCount",
                "nargs": 0,
                "retval": "int",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "int",
                        "iFG"
                    ]
                ],
                "argsstr": "int iFG",
                "comments": "Returns the friends group ID for the given index (invalid indices return k_FriendsGroupID_Invalid)",
                "name": "GetFriendsGroupIDByIndex",
                "nargs": 1,
                "retval": "FriendsGroupID_t",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "FriendsGroupID_t",
                        "friendsGroupID"
                    ]
                ],
                "argsstr": "FriendsGroupID_t friendsGroupID",
                "comments": "Returns the name for the given friends group (NULL in the case of invalid friends group IDs)",
                "name": "GetFriendsGroupName",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "FriendsGroupID_t",
                        "friendsGroupID"
                    ]
                ],
                "argsstr": "FriendsGroupID_t friendsGroupID",
                "comments": "Returns the number of members in a given friends group",
                "name": "GetFriendsGroupMembersCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "FriendsGroupID_t",
                        "friendsGroupID"
                    ],
                    [
                        "CSteamID*",
                        "pOutSteamIDMembers"
                    ],
                    [
                        "int",
                        "nMembersCount"
                    ]
                ],
                "argsstr": "FriendsGroupID_t friendsGroupID,  CSteamID *pOutSteamIDMembers, int nMembersCount",
                "comments": "Gets up to nMembersCount members of the given friends group, if fewer exist than requested those positions' SteamIDs will be invalid",
                "name": "GetFriendsGroupMembersList",
                "nargs": 3,
                "retval": "void",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "int",
                        "iFriendFlags"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, int iFriendFlags",
                "comments": "Returns true if the specified user meets any of the criteria specified in iFriendFlags\n iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values",
                "name": "HasFriend",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Clan (group) iteration and access functions",
                "name": "GetClanCount",
                "nargs": 0,
                "retval": "int",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "int",
                        "iClan"
                    ]
                ],
                "argsstr": "int iClan",
                "name": "GetClanByIndex",
                "nargs": 1,
                "retval": "CSteamID",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "GetClanName",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "GetClanTag",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ],
                    [
                        "int*",
                        "pnOnline"
                    ],
                    [
                        "int*",
                        "pnInGame"
                    ],
                    [
                        "int*",
                        "pnChatting"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan, int *pnOnline, int *pnInGame, int *pnChatting",
                "comments": "Returns the most recent information we have about what's happening in a clan",
                "name": "GetClanActivityCounts",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "CSteamID*",
                        "psteamIDClans"
                    ],
                    [
                        "int",
                        "cClansToRequest"
                    ]
                ],
                "argsstr": "CSteamID *psteamIDClans, int cClansToRequest",
                "comments": "For clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest",
                "name": "DownloadClanActivityCounts",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDSource"
                    ]
                ],
                "argsstr": "CSteamID steamIDSource",
                "comments": "Iterators for getting users in a chat room, lobby, game server or clan\n note that large clans that cannot be iterated by the local user\n note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby\n steamIDSource can be the steamID of a group, game server, lobby or chat room",
                "name": "GetFriendCountFromSource",
                "nargs": 1,
                "retval": "int",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDSource"
                    ],
                    [
                        "int",
                        "iFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDSource, int iFriend",
                "name": "GetFriendFromSourceByIndex",
                "nargs": 2,
                "retval": "CSteamID",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "CSteamID",
                        "steamIDSource"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, CSteamID steamIDSource",
                "comments": "Returns true if the local user can see that steamIDUser is a member or in steamIDSource",
                "name": "IsUserInSource",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "bool",
                        "bSpeaking"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, bool bSpeaking",
                "comments": "User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)",
                "name": "SetInGameVoiceSpeaking",
                "nargs": 2,
                "retval": "void",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchDialog"
                    ]
                ],
                "argsstr": "const char *pchDialog",
                "comments": "Activates the game overlay, with an optional dialog to open \n valid options are \"Friends\", \"Community\", \"Players\", \"Settings\", \"OfficialGameGroup\", \"Stats\", \"Achievements\"",
                "name": "ActivateGameOverlay",
                "nargs": 1,
                "retval": "void",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchDialog"
                    ],
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "const char *pchDialog, CSteamID steamID",
                "comments": "Activates game overlay to a specific place\n valid options are\n\"steamid\" - opens the overlay web browser to the specified user or groups profile\n\"chat\" - opens a chat window to the specified user, or joins the group chat \n\"jointrade\" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API\n\"stats\" - opens the overlay web browser to the specified user's stats\n\"achievements\" - opens the overlay web browser to the specified user's achievements\n\"friendadd\" - opens the overlay in minimal mode prompting the user to add the target user as a friend\n\"friendremove\" - opens the overlay in minimal mode prompting the user to remove the target friend\n\"friendrequestaccept\" - opens the overlay in minimal mode prompting the user to accept an incoming friend invite\n\"friendrequestignore\" - opens the overlay in minimal mode prompting the user to ignore an incoming friend invite",
                "name": "ActivateGameOverlayToUser",
                "nargs": 2,
                "retval": "void",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchURL"
                    ]
                ],
                "argsstr": "const char *pchURL",
                "comments": "Activates game overlay web browser directly to the specified URL\n full address with protocol type is required, e.g. http:www.steamgames.com/",
                "name": "ActivateGameOverlayToWebPage",
                "nargs": 1,
                "retval": "void",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ],
                    [
                        "EOverlayToStoreFlag",
                        "eFlag"
                    ]
                ],
                "argsstr": "AppId_t nAppID, EOverlayToStoreFlag eFlag",
                "comments": "Activates game overlay to store page for app",
                "name": "ActivateGameOverlayToStore",
                "nargs": 2,
                "retval": "void",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUserPlayedWith"
                    ]
                ],
                "argsstr": "CSteamID steamIDUserPlayedWith",
                "comments": "Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is \n in game",
                "name": "SetPlayedWith",
                "nargs": 1,
                "retval": "void",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.",
                "name": "ActivateGameOverlayInviteDialog",
                "nargs": 1,
                "retval": "void",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set",
                "name": "GetSmallFriendAvatar",
                "nargs": 1,
                "retval": "int",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set",
                "name": "GetMediumFriendAvatar",
                "nargs": 1,
                "retval": "int",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set\n returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again",
                "name": "GetLargeFriendAvatar",
                "nargs": 1,
                "retval": "int",
                "vfindex": 36
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "bool",
                        "bRequireNameOnly"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, bool bRequireNameOnly",
                "comments": "Requests information about a user - persona name & avatar\n if bRequireNameOnly is set, then the avatar of a user isn't downloaded \n - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them\n if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved\n if returns false, it means that we already have all the details about that user, and functions can be called immediately",
                "name": "RequestUserInformation",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 37
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "comments": "Requests information about a clan officer list\n when complete, data is returned in ClanOfficerListResponse_t call result\n this makes available the calls below\n you can only ask about clans that a user is a member of\n note that this won't download avatars automatically; if you get an officer,\n and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar\nCALL_RESULT( ClanOfficerListResponse_t )",
                "name": "RequestClanOfficerList",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 38
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "comments": "Iteration of clan officers - can only be done when a RequestClanOfficerList() call has completed\n\n returns the steamID of the clan owner",
                "name": "GetClanOwner",
                "nargs": 1,
                "retval": "CSteamID",
                "vfindex": 39
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "comments": "Returns the number of officers in a clan (including the owner)",
                "name": "GetClanOfficerCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 40
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ],
                    [
                        "int",
                        "iOfficer"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan, int iOfficer",
                "comments": "Returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)",
                "name": "GetClanOfficerByIndex",
                "nargs": 2,
                "retval": "CSteamID",
                "vfindex": 41
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "If current user is chat restricted, he can't send or receive any text/voice chat messages.\n the user can't see custom avatars. But the user can be online and send/recv game invites.\n a chat restricted user can't add friends or join any groups.",
                "name": "GetUserRestrictions",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 42
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "const char *pchKey, const char *pchValue",
                "comments": "Rich Presence data is automatically shared between friends who are in the same game\n Each user has a set of Key/Value pairs\n Note the following limits: k_cchMaxRichPresenceKeys, k_cchMaxRichPresenceKeyLength, k_cchMaxRichPresenceValueLength\n There are two magic keys:\n\"status\"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list\n\"connect\" - a UTF-8 string that contains the command-line for how a friend can connect to a game\n GetFriendRichPresence() returns an empty string \"\" if no value is set\n SetRichPresence() to a NULL or an empty string deletes the key\n You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()\n and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)",
                "name": "SetRichPresence",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 43
            },
            {
                "args": [],
                "argsstr": "",
                "name": "ClearRichPresence",
                "nargs": 0,
                "retval": "void",
                "vfindex": 44
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, const char *pchKey",
                "name": "GetFriendRichPresence",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 45
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "name": "GetFriendRichPresenceKeyCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 46
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "int",
                        "iKey"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, int iKey",
                "name": "GetFriendRichPresenceKeyByIndex",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 47
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "comments": "Requests rich presence for a specific user.",
                "name": "RequestFriendRichPresence",
                "nargs": 1,
                "retval": "void",
                "vfindex": 48
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "constchar*",
                        "pchConnectString"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, const char *pchConnectString",
                "comments": "Rich invite support\n if the target accepts the invite, the pchConnectString gets added to the command-line for launching the game\n if the game is already running, a GameRichPresenceJoinRequested_t callback is posted containing the connect string\n invites can only be sent to friends",
                "name": "InviteUserToGame",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 49
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Recently-played-with friends iteration\n this iterates the entire list of users recently played with, across games\n GetFriendCoplayTime() returns as a unix time",
                "name": "GetCoplayFriendCount",
                "nargs": 0,
                "retval": "int",
                "vfindex": 50
            },
            {
                "args": [
                    [
                        "int",
                        "iCoplayFriend"
                    ]
                ],
                "argsstr": "int iCoplayFriend",
                "name": "GetCoplayFriend",
                "nargs": 1,
                "retval": "CSteamID",
                "vfindex": 51
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "name": "GetFriendCoplayTime",
                "nargs": 1,
                "retval": "int",
                "vfindex": 52
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend",
                "name": "GetFriendCoplayGame",
                "nargs": 1,
                "retval": "AppId_t",
                "vfindex": 53
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "comments": "Chat interface for games\n this allows in-game access to group (clan) chats from in the game\n the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay\n use ActivateGameOverlayToUser( \"chat\", steamIDClan ) to open the in-game overlay version of the chat\nCALL_RESULT( JoinClanChatRoomCompletionResult_t )",
                "name": "JoinClanChatRoom",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 54
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "LeaveClanChatRoom",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 55
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "GetClanChatMemberCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 56
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ],
                    [
                        "int",
                        "iUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan, int iUser",
                "name": "GetChatMemberByIndex",
                "nargs": 2,
                "retval": "CSteamID",
                "vfindex": 57
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ],
                    [
                        "constchar*",
                        "pchText"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat, const char *pchText",
                "name": "SendClanChatMessage",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 58
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ],
                    [
                        "int",
                        "iMessage"
                    ],
                    [
                        "void*",
                        "prgchText"
                    ],
                    [
                        "int",
                        "cchTextMax"
                    ],
                    [
                        "EChatEntryType*",
                        "peChatEntryType"
                    ],
                    [
                        "CSteamID*",
                        "psteamidChatter"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat, int iMessage, void *prgchText, int cchTextMax, EChatEntryType *peChatEntryType,  CSteamID *psteamidChatter",
                "name": "GetClanChatMessage",
                "nargs": 6,
                "retval": "int",
                "vfindex": 59
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ],
                    [
                        "CSteamID",
                        "steamIDUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat, CSteamID steamIDUser",
                "name": "IsClanChatAdmin",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 60
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat",
                "comments": "Interact with the Steam (game overlay / desktop)",
                "name": "IsClanChatWindowOpenInSteam",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 61
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat",
                "name": "OpenClanChatWindowInSteam",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 62
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClanChat"
                    ]
                ],
                "argsstr": "CSteamID steamIDClanChat",
                "name": "CloseClanChatWindowInSteam",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 63
            },
            {
                "args": [
                    [
                        "bool",
                        "bInterceptEnabled"
                    ]
                ],
                "argsstr": "bool bInterceptEnabled",
                "comments": "Peer-to-peer chat interception\n this is so you can show P2P chats inline in the game",
                "name": "SetListenForFriendsMessages",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 64
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "constchar*",
                        "pchMsgToSend"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, const char *pchMsgToSend",
                "name": "ReplyToFriendMessage",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 65
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDFriend"
                    ],
                    [
                        "int",
                        "iMessageID"
                    ],
                    [
                        "void*",
                        "pvData"
                    ],
                    [
                        "int",
                        "cubData"
                    ],
                    [
                        "EChatEntryType*",
                        "peChatEntryType"
                    ]
                ],
                "argsstr": "CSteamID steamIDFriend, int iMessageID, void *pvData, int cubData, EChatEntryType *peChatEntryType",
                "name": "GetFriendMessage",
                "nargs": 5,
                "retval": "int",
                "vfindex": 66
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "CSteamID steamID",
                "comments": "Following apis\nCALL_RESULT( FriendsGetFollowerCount_t )",
                "name": "GetFollowerCount",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 67
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "CSteamID steamID",
                "name": "IsFollowing",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 68
            },
            {
                "args": [
                    [
                        "uint32",
                        "unStartIndex"
                    ]
                ],
                "argsstr": "uint32 unStartIndex",
                "name": "EnumerateFollowingList",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 69
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "IsClanPublic",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 70
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "name": "IsClanOfficialGameGroup",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 71
            }
        ]
    },
    "ISteamGameCoordinator": {
        "cppclass": "ISteamGameCoordinator",
        "cppinterface": "STEAMGAMECOORDINATOR_INTERFACE_VERSION",
        "cppinterfacev": "SteamGameCoordinator001",
        "funcs": [
            {
                "args": [
                    [
                        "uint32",
                        "unMsgType"
                    ],
                    [
                        "constvoid*",
                        "pubData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ]
                ],
                "argsstr": "uint32 unMsgType, const void *pubData, uint32 cubData",
                "comments": "Sends a message to the Game Coordinator",
                "name": "SendMessage",
                "nargs": 3,
                "retval": "EGCResults",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ]
                ],
                "argsstr": "uint32 *pcubMsgSize",
                "comments": "Returns true if there is a message waiting from the game coordinator",
                "name": "IsMessageAvailable",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "uint32*",
                        "punMsgType"
                    ],
                    [
                        "void*",
                        "pubDest"
                    ],
                    [
                        "uint32",
                        "cubDest"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ]
                ],
                "argsstr": "uint32 *punMsgType, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize",
                "comments": "Fills the provided buffer with the first message in the queue and returns k_EGCResultOK or \n returns k_EGCResultNoMessage if there is no message waiting. pcubMsgSize is filled with the message size.\n If the provided buffer is not large enough to fit the entire message, k_EGCResultBufferTooSmall is returned\n and the message remains at the head of the queue.",
                "name": "RetrieveMessage",
                "nargs": 4,
                "retval": "EGCResults",
                "vfindex": 2
            }
        ]
    },
    "ISteamGameServer": {
        "cppclass": "ISteamGameServer",
        "cppinterface": "STEAMGAMESERVER_INTERFACE_VERSION",
        "cppinterfacev": "SteamGameServer012",
        "funcs": [
            {
                "args": [
                    [
                        "uint32",
                        "unIP"
                    ],
                    [
                        "uint16",
                        "usGamePort"
                    ],
                    [
                        "uint16",
                        "usQueryPort"
                    ],
                    [
                        "uint32",
                        "unFlags"
                    ],
                    [
                        "AppId_t",
                        "nGameAppId"
                    ],
                    [
                        "constchar*",
                        "pchVersionString"
                    ]
                ],
                "argsstr": "uint32 unIP, uint16 usGamePort, uint16 usQueryPort, uint32 unFlags, AppId_t nGameAppId, const char *pchVersionString",
                "comments": "Basic server data.  These properties, if set, must be set before before calling LogOn.  They\n may not be changed after logged in.\n\n\n/ This is called by SteamGameServer_Init, and you will usually not need to call it directly",
                "name": "InitGameServer",
                "nargs": 6,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszProduct"
                    ]
                ],
                "argsstr": "const char *pszProduct",
                "comments": "/ Game product identifier.  This is currently used by the master server for version checking purposes.\n/ It's a required field, but will eventually will go away, and the AppID will be used for this purpose.",
                "name": "SetProduct",
                "nargs": 1,
                "retval": "void",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszGameDescription"
                    ]
                ],
                "argsstr": "const char *pszGameDescription",
                "comments": "/ Description of the game.  This is a required field and is displayed in the steam server browser....for now.\n/ This is a required field, but it will go away eventually, as the data should be determined from the AppID.",
                "name": "SetGameDescription",
                "nargs": 1,
                "retval": "void",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszModDir"
                    ]
                ],
                "argsstr": "const char *pszModDir",
                "comments": "/ If your game is a \"mod,\" pass the string that identifies it.  The default is an empty string, meaning\n/ this application is the original game, not a mod.\n/\n/ @see k_cbMaxGameServerGameDir",
                "name": "SetModDir",
                "nargs": 1,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "bool",
                        "bDedicated"
                    ]
                ],
                "argsstr": "bool bDedicated",
                "comments": "/ Is this is a dedicated server?  The default value is false.",
                "name": "SetDedicatedServer",
                "nargs": 1,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszToken"
                    ]
                ],
                "argsstr": "const char *pszToken",
                "comments": "Login\n\n\n/ Begin process to login to a persistent game server account\n/\n/ You need to register for callbacks to determine the result of this operation.\n/ @see SteamServersConnected_t\n/ @see SteamServerConnectFailure_t\n/ @see SteamServersDisconnected_t",
                "name": "LogOn",
                "nargs": 1,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "/ Login to a generic, anonymous account.\n/\n/ Note: in previous versions of the SDK, this was automatically called within SteamGameServer_Init,\n/ but this is no longer the case.",
                "name": "LogOnAnonymous",
                "nargs": 0,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "/ Begin process of logging game server out of steam",
                "name": "LogOff",
                "nargs": 0,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Status functions",
                "name": "BLoggedOn",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BSecure",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetSteamID",
                "nargs": 0,
                "retval": "CSteamID",
                "vfindex": 10
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "/ Returns true if the master server has requested a restart.\n/ Only returns true once per request.",
                "name": "WasRestartRequested",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "int",
                        "cPlayersMax"
                    ]
                ],
                "argsstr": "int cPlayersMax",
                "comments": "Server state.  These properties may be changed at any time.\n\n\n/ Max player count that will be reported to server browser and client queries",
                "name": "SetMaxPlayerCount",
                "nargs": 1,
                "retval": "void",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "int",
                        "cBotplayers"
                    ]
                ],
                "argsstr": "int cBotplayers",
                "comments": "/ Number of bots.  Default value is zero",
                "name": "SetBotPlayerCount",
                "nargs": 1,
                "retval": "void",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszServerName"
                    ]
                ],
                "argsstr": "const char *pszServerName",
                "comments": "/ Set the name of server as it will appear in the server browser\n/\n/ @see k_cbMaxGameServerName",
                "name": "SetServerName",
                "nargs": 1,
                "retval": "void",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszMapName"
                    ]
                ],
                "argsstr": "const char *pszMapName",
                "comments": "/ Set name of map to report in the server browser\n/\n/ @see k_cbMaxGameServerName",
                "name": "SetMapName",
                "nargs": 1,
                "retval": "void",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "bool",
                        "bPasswordProtected"
                    ]
                ],
                "argsstr": "bool bPasswordProtected",
                "comments": "/ Let people know if your server will require a password",
                "name": "SetPasswordProtected",
                "nargs": 1,
                "retval": "void",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "uint16",
                        "unSpectatorPort"
                    ]
                ],
                "argsstr": "uint16 unSpectatorPort",
                "comments": "/ Spectator server.  The default value is zero, meaning the service\n/ is not used.",
                "name": "SetSpectatorPort",
                "nargs": 1,
                "retval": "void",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszSpectatorServerName"
                    ]
                ],
                "argsstr": "const char *pszSpectatorServerName",
                "comments": "/ Name of the spectator server.  (Only used if spectator port is nonzero.)\n/\n/ @see k_cbMaxGameServerMapName",
                "name": "SetSpectatorServerName",
                "nargs": 1,
                "retval": "void",
                "vfindex": 18
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "/ Call this to clear the whole list of key/values that are sent in rules queries.",
                "name": "ClearAllKeyValues",
                "nargs": 0,
                "retval": "void",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pKey"
                    ],
                    [
                        "constchar*",
                        "pValue"
                    ]
                ],
                "argsstr": "const char *pKey, const char *pValue",
                "comments": "/ Call this to add/update a key/value pair.",
                "name": "SetKeyValue",
                "nargs": 2,
                "retval": "void",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchGameTags"
                    ]
                ],
                "argsstr": "const char *pchGameTags",
                "comments": "/ Sets a string defining the \"gametags\" for this server, this is optional, but if it is set\n/ it allows users to filter in the matchmaking/server-browser interfaces based on the value\n/\n/ @see k_cbMaxGameServerTags",
                "name": "SetGameTags",
                "nargs": 1,
                "retval": "void",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchGameData"
                    ]
                ],
                "argsstr": "const char *pchGameData",
                "comments": "/ Sets a string defining the \"gamedata\" for this server, this is optional, but if it is set\n/ it allows users to filter in the matchmaking/server-browser interfaces based on the value\n/ don't set this unless it actually changes, its only uploaded to the master once (when\n/ acknowledged)\n/\n/ @see k_cbMaxGameServerGameData",
                "name": "SetGameData",
                "nargs": 1,
                "retval": "void",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pszRegion"
                    ]
                ],
                "argsstr": "const char *pszRegion",
                "comments": "/ Region identifier.  This is an optional field, the default value is empty, meaning the \"world\" region",
                "name": "SetRegion",
                "nargs": 1,
                "retval": "void",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIPClient"
                    ],
                    [
                        "constvoid*",
                        "pvAuthBlob"
                    ],
                    [
                        "uint32",
                        "cubAuthBlobSize"
                    ],
                    [
                        "CSteamID*",
                        "pSteamIDUser"
                    ]
                ],
                "argsstr": "uint32 unIPClient, const void *pvAuthBlob, uint32 cubAuthBlobSize, CSteamID *pSteamIDUser",
                "comments": "Player list management / authentication\n\n\n Handles receiving a new connection from a Steam user.  This call will ask the Steam\n servers to validate the users identity, app ownership, and VAC status.  If the Steam servers \n are off-line, then it will validate the cached ticket itself which will validate app ownership \n and identity.  The AuthBlob here should be acquired on the game client using SteamUser()->InitiateGameConnection()\n and must then be sent up to the game server for authentication.\n\n Return Value: returns true if the users ticket passes basic checks. pSteamIDUser will contain the Steam ID of this user. pSteamIDUser must NOT be NULL\n If the call succeeds then you should expect a GSClientApprove_t or GSClientDeny_t callback which will tell you whether authentication\n for the user has succeeded or failed (the steamid in the callback will match the one returned by this call)",
                "name": "SendUserConnectAndAuthenticate",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Creates a fake user (ie, a bot) which will be listed as playing on the server, but skips validation.  \n \n Return Value: Returns a SteamID for the user to be tracked with, you should call HandleUserDisconnect()\n when this user leaves the server just like you would for a real user.",
                "name": "CreateUnauthenticatedUserConnection",
                "nargs": 0,
                "retval": "CSteamID",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser",
                "comments": "Should be called whenever a user leaves our game server, this lets Steam internally\n track which users are currently on which servers for the purposes of preventing a single\n account being logged into multiple servers, showing who is currently on a server, etc.",
                "name": "SendUserDisconnect",
                "nargs": 1,
                "retval": "void",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchPlayerName"
                    ],
                    [
                        "uint32",
                        "uScore"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchPlayerName, uint32 uScore",
                "comments": "Update the data to be displayed in the server browser and matchmaking interfaces for a user\n currently connected to the server.  For regular users you must call this after you receive a\n GSUserValidationSuccess callback.\n \n Return Value: true if successful, false if failure (ie, steamIDUser wasn't for an active player)",
                "name": "BUpdateUserData",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "void*",
                        "pTicket"
                    ],
                    [
                        "int",
                        "cbMaxTicket"
                    ],
                    [
                        "uint32*",
                        "pcbTicket"
                    ]
                ],
                "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket",
                "comments": "New auth system APIs - do not mix with the old auth system APIs.\n ----------------------------------------------------------------\n\n Retrieve ticket to be sent to the entity who wishes to authenticate you ( using BeginAuthSession API ). \n pcbTicket retrieves the length of the actual ticket.",
                "name": "GetAuthSessionTicket",
                "nargs": 3,
                "retval": "HAuthTicket",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "constvoid*",
                        "pAuthTicket"
                    ],
                    [
                        "int",
                        "cbAuthTicket"
                    ],
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "const void *pAuthTicket, int cbAuthTicket, CSteamID steamID",
                "comments": "Authenticate ticket ( from GetAuthSessionTicket ) from entity steamID to be sure it is valid and isnt reused\n Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )",
                "name": "BeginAuthSession",
                "nargs": 3,
                "retval": "EBeginAuthSessionResult",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "CSteamID steamID",
                "comments": "Stop tracking started by BeginAuthSession - called when no longer playing game with this entity",
                "name": "EndAuthSession",
                "nargs": 1,
                "retval": "void",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "HAuthTicket",
                        "hAuthTicket"
                    ]
                ],
                "argsstr": "HAuthTicket hAuthTicket",
                "comments": "Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to",
                "name": "CancelAuthTicket",
                "nargs": 1,
                "retval": "void",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ],
                    [
                        "AppId_t",
                        "appID"
                    ]
                ],
                "argsstr": "CSteamID steamID, AppId_t appID",
                "comments": "After receiving a user's authentication data, and passing it to SendUserConnectAndAuthenticate, use this function\n to determine if the user owns downloadable content specified by the provided AppID.",
                "name": "UserHasLicenseForApp",
                "nargs": 2,
                "retval": "EUserHasLicenseForAppResult",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "CSteamID",
                        "steamIDGroup"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, CSteamID steamIDGroup",
                "comments": "Ask if a user in in the specified group, results returns async by GSUserGroupStatus_t\n returns false if we're not connected to the steam servers and thus cannot ask",
                "name": "RequestUserGroupStatus",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 33
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "These two functions s are deprecated, and will not return results\n they will be removed in a future version of the SDK",
                "name": "GetGameplayStats",
                "nargs": 0,
                "retval": "void",
                "vfindex": 34
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetServerReputation",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 35
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the public IP of the server according to Steam, useful when the server is \n behind NAT and you want to advertise its IP in a lobby for other clients to directly\n connect to",
                "name": "GetPublicIP",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 36
            },
            {
                "args": [
                    [
                        "constvoid*",
                        "pData"
                    ],
                    [
                        "int",
                        "cbData"
                    ],
                    [
                        "uint32",
                        "srcIP"
                    ],
                    [
                        "uint16",
                        "srcPort"
                    ]
                ],
                "argsstr": "const void *pData, int cbData, uint32 srcIP, uint16 srcPort",
                "comments": "These are in GameSocketShare mode, where instead of ISteamGameServer creating its own\n socket to talk to the master server on, it lets the game use its socket to forward messages\n back and forth. This prevents us from requiring server ops to open up yet another port\n in their firewalls.\n\n the IP address and port should be in host order, i.e 127.0.0.1 == 0x7f000001\n\n These are used when you've elected to multiplex the game server's UDP socket\n rather than having the master server updater use its own sockets.\n \n Source games use this to simplify the job of the server admins, so they \n don't have to open up more ports on their firewalls.\n\n Call this when a packet that starts with 0xFFFFFFFF comes in. That means\n it's for us.",
                "name": "HandleIncomingPacket",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 37
            },
            {
                "args": [
                    [
                        "void*",
                        "pOut"
                    ],
                    [
                        "int",
                        "cbMaxOut"
                    ],
                    [
                        "uint32*",
                        "pNetAdr"
                    ],
                    [
                        "uint16*",
                        "pPort"
                    ]
                ],
                "argsstr": "void *pOut, int cbMaxOut, uint32 *pNetAdr, uint16 *pPort",
                "comments": "AFTER calling HandleIncomingPacket for any packets that came in that frame, call this.\n This gets a packet that the master server updater needs to send out on UDP.\n It returns the length of the packet it wants to send, or 0 if there are no more packets to send.\n Call this each frame until it returns 0.",
                "name": "GetNextOutgoingPacket",
                "nargs": 4,
                "retval": "int",
                "vfindex": 38
            },
            {
                "args": [
                    [
                        "bool",
                        "bActive"
                    ]
                ],
                "argsstr": "bool bActive",
                "comments": "Control heartbeats / advertisement with master server\n\n\n Call this as often as you like to tell the master server updater whether or not\n you want it to be active (default: off).",
                "name": "EnableHeartbeats",
                "nargs": 1,
                "retval": "void",
                "vfindex": 39
            },
            {
                "args": [
                    [
                        "int",
                        "iHeartbeatInterval"
                    ]
                ],
                "argsstr": "int iHeartbeatInterval",
                "comments": "You usually don't need to modify this.\n Pass -1 to use the default value for iHeartbeatInterval.\n Some mods change this.",
                "name": "SetHeartbeatInterval",
                "nargs": 1,
                "retval": "void",
                "vfindex": 40
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Force a heartbeat to steam at the next opportunity",
                "name": "ForceHeartbeat",
                "nargs": 0,
                "retval": "void",
                "vfindex": 41
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDClan"
                    ]
                ],
                "argsstr": "CSteamID steamIDClan",
                "comments": "Associate this game server with this clan for the purposes of computing player compat\nCALL_RESULT( AssociateWithClanResult_t )",
                "name": "AssociateWithClan",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 42
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDNewPlayer"
                    ]
                ],
                "argsstr": "CSteamID steamIDNewPlayer",
                "comments": "Ask if any of the current players dont want to play with this new player - or vice versa\nCALL_RESULT( ComputeNewPlayerCompatibilityResult_t )",
                "name": "ComputeNewPlayerCompatibility",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 43
            }
        ]
    },
    "ISteamGameServerStats": {
        "cppclass": "ISteamGameServerStats",
        "cppinterface": "STEAMGAMESERVERSTATS_INTERFACE_VERSION",
        "cppinterfacev": "SteamGameServerStats001",
        "funcs": [
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser",
                "comments": "Downloads stats for the user\n returns a GSStatsReceived_t callback when completed\n if the user has no stats, GSStatsReceived_t.m_eResult will be set to k_EResultFail\n these stats will only be auto-updated for clients playing on the server. For other\n users you'll need to call RequestUserStats() again to refresh any data\nCALL_RESULT( GSStatsReceived_t )",
                "name": "RequestUserStats",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int32*",
                        "pData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, int32 *pData",
                "comments": "Requests stat information for a user, usable after a successful call to RequestUserStats()",
                "name": "GetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float*",
                        "pData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, float *pData",
                "name": "GetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved",
                "name": "GetUserAchievement",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int32",
                        "nData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, int32 nData",
                "comments": "Set / update stats and achievements. \n Note: These updates will work only on stats game servers are allowed to edit and only for \n game servers that have been declared as officially controlled by the game creators. \n Set the IP range of your official servers on the Steamworks page",
                "name": "SetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float",
                        "fData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, float fData",
                "name": "SetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float",
                        "flCountThisSession"
                    ],
                    [
                        "double",
                        "dSessionLength"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, float flCountThisSession, double dSessionLength",
                "name": "UpdateUserAvgRateStat",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName",
                "name": "SetUserAchievement",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName",
                "name": "ClearUserAchievement",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser",
                "comments": "Store the current data on the server, will get a GSStatsStored_t callback when set.\n\n If the callback has a result of k_EResultInvalidParam, one or more stats \n uploaded has been rejected, either because they broke constraints\n or were out of date. In this case the server sends back updated values.\n The stats should be re-iterated to keep in sync.\nCALL_RESULT( GSStatsStored_t )",
                "name": "StoreUserStats",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 9
            }
        ]
    },
    "ISteamHTMLSurface": {
        "cppclass": "ISteamHTMLSurface",
        "cppinterface": "STEAMHTMLSURFACE_INTERFACE_VERSION",
        "cppinterfacev": "STEAMHTMLSURFACE_INTERFACE_VERSION_004",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Must call init and shutdown when starting/ending use of the interface",
                "name": "Init",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "Shutdown",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchUserAgent"
                    ],
                    [
                        "constchar*",
                        "pchUserCSS"
                    ]
                ],
                "argsstr": "const char *pchUserAgent, const char *pchUserCSS",
                "comments": "Create a browser object for display of a html page, when creation is complete the call handle\n will return a HTML_BrowserReady_t callback for the HHTMLBrowser of your new browser.\n   The user agent string is a substring to be added to the general user agent string so you can\n identify your client on web servers.\n   The userCSS string lets you apply a CSS style sheet to every displayed page, leave null if\n you do not require this functionality.\n\n YOU MUST HAVE IMPLEMENTED HANDLERS FOR HTML_BrowserReady_t, HTML_StartRequest_t,\n HTML_JSAlert_t, HTML_JSConfirm_t, and HTML_FileOpenDialog_t! See the CALLBACKS\n section of this interface (AllowStartRequest, etc) for more details. If you do\n not implement these callback handlers, the browser may appear to hang instead of\n navigating to new pages or triggering javascript popups.\n\nCALL_RESULT( HTML_BrowserReady_t )",
                "name": "CreateBrowser",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Call this when you are done with a html surface, this lets us free the resources being used by it",
                "name": "RemoveBrowser",
                "nargs": 1,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "constchar*",
                        "pchURL"
                    ],
                    [
                        "constchar*",
                        "pchPostData"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchURL, const char *pchPostData",
                "comments": "Navigate to this URL, results in a HTML_StartRequest_t as the request commences",
                "name": "LoadURL",
                "nargs": 3,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "unWidth"
                    ],
                    [
                        "uint32",
                        "unHeight"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 unWidth, uint32 unHeight",
                "comments": "Tells the surface the size in pixels to display the surface",
                "name": "SetSize",
                "nargs": 3,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Stop the load of the current html page",
                "name": "StopLoad",
                "nargs": 1,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Reload (most likely from local cache) the current page",
                "name": "Reload",
                "nargs": 1,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Navigate back in the page history",
                "name": "GoBack",
                "nargs": 1,
                "retval": "void",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Navigate forward in the page history",
                "name": "GoForward",
                "nargs": 1,
                "retval": "void",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchKey, const char *pchValue",
                "comments": "Add this header to any url requests from this browser",
                "name": "AddHeader",
                "nargs": 3,
                "retval": "void",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "constchar*",
                        "pchScript"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchScript",
                "comments": "Run this javascript script in the currently loaded page",
                "name": "ExecuteJavascript",
                "nargs": 2,
                "retval": "void",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "EHTMLMouseButton",
                        "eMouseButton"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton",
                "comments": "Mouse click and mouse movement commands",
                "name": "MouseUp",
                "nargs": 2,
                "retval": "void",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "EHTMLMouseButton",
                        "eMouseButton"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton",
                "name": "MouseDown",
                "nargs": 2,
                "retval": "void",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "EHTMLMouseButton",
                        "eMouseButton"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton",
                "name": "MouseDoubleClick",
                "nargs": 2,
                "retval": "void",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "int",
                        "x"
                    ],
                    [
                        "int",
                        "y"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, int x, int y",
                "comments": "X and y are relative to the HTML bounds",
                "name": "MouseMove",
                "nargs": 3,
                "retval": "void",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "int32",
                        "nDelta"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, int32 nDelta",
                "comments": "NDelta is pixels of scroll",
                "name": "MouseWheel",
                "nargs": 2,
                "retval": "void",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "nNativeKeyCode"
                    ],
                    [
                        "EHTMLKeyModifiers",
                        "eHTMLKeyModifiers"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers",
                "comments": "Don't show any custom cursor, just use your default\ndc_middle_pan,\ndc_north_pan,\ndc_north_east_pan,\ndc_east_pan,\ndc_south_east_pan,\ndc_south_pan,\ndc_south_west_pan,\ndc_west_pan,\ndc_north_west_pan,\ndc_alias,\ndc_cell,\ndc_colresize,\ndc_copycur,\ndc_verticaltext,\ndc_rowresize,\ndc_zoomin,\ndc_zoomout,\ndc_help,\ndc_custom,\n\ndc_last,  custom cursors start from this value and up\n};\n\nenum EHTMLKeyModifiers\n{\nk_eHTMLKeyModifier_None = 0,\nk_eHTMLKeyModifier_AltDown = 1 << 0,\nk_eHTMLKeyModifier_CtrlDown = 1 << 1,\nk_eHTMLKeyModifier_ShiftDown = 1 << 2,\n};\n\n keyboard interactions, native keycode is the virtual key code value from your OS",
                "name": "KeyDown",
                "nargs": 3,
                "retval": "void",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "nNativeKeyCode"
                    ],
                    [
                        "EHTMLKeyModifiers",
                        "eHTMLKeyModifiers"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers",
                "name": "KeyUp",
                "nargs": 3,
                "retval": "void",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "cUnicodeChar"
                    ],
                    [
                        "EHTMLKeyModifiers",
                        "eHTMLKeyModifiers"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 cUnicodeChar, EHTMLKeyModifiers eHTMLKeyModifiers",
                "comments": "CUnicodeChar is the unicode character point for this keypress (and potentially multiple chars per press)",
                "name": "KeyChar",
                "nargs": 3,
                "retval": "void",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "nAbsolutePixelScroll"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nAbsolutePixelScroll",
                "comments": "Programmatically scroll this many pixels on the page",
                "name": "SetHorizontalScroll",
                "nargs": 2,
                "retval": "void",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "uint32",
                        "nAbsolutePixelScroll"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nAbsolutePixelScroll",
                "name": "SetVerticalScroll",
                "nargs": 2,
                "retval": "void",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "bool",
                        "bHasKeyFocus"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, bool bHasKeyFocus",
                "comments": "Tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things",
                "name": "SetKeyFocus",
                "nargs": 2,
                "retval": "void",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Open the current pages html code in the local editor of choice, used for debugging",
                "name": "ViewSource",
                "nargs": 1,
                "retval": "void",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Copy the currently selected text on the html page to the local clipboard",
                "name": "CopyToClipboard",
                "nargs": 1,
                "retval": "void",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Paste from the local clipboard to the current html page",
                "name": "PasteFromClipboard",
                "nargs": 1,
                "retval": "void",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "constchar*",
                        "pchSearchStr"
                    ],
                    [
                        "bool",
                        "bCurrentlyInFind"
                    ],
                    [
                        "bool",
                        "bReverse"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchSearchStr, bool bCurrentlyInFind, bool bReverse",
                "comments": "Find this string in the browser, if bCurrentlyInFind is true then instead cycle to the next matching element",
                "name": "Find",
                "nargs": 4,
                "retval": "void",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle",
                "comments": "Cancel a currently running find",
                "name": "StopFind",
                "nargs": 1,
                "retval": "void",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "int",
                        "x"
                    ],
                    [
                        "int",
                        "y"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, int x, int y",
                "comments": "Return details about the link at position x,y on the current page",
                "name": "GetLinkAtPosition",
                "nargs": 3,
                "retval": "void",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchHostname"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ],
                    [
                        "constchar*pchPath=",
                        "\"/\""
                    ],
                    [
                        "RTime32nExpires=",
                        "0"
                    ],
                    [
                        "boolbSecure=",
                        "false"
                    ],
                    [
                        "boolbHTTPOnly=",
                        "false"
                    ]
                ],
                "argsstr": "const char *pchHostname, const char *pchKey, const char *pchValue, const char *pchPath = \"/\", RTime32 nExpires = 0, bool bSecure = false, bool bHTTPOnly = false",
                "comments": "Set a webcookie for the hostname in question",
                "name": "SetCookie",
                "nargs": 7,
                "retval": "void",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "float",
                        "flZoom"
                    ],
                    [
                        "int",
                        "nPointX"
                    ],
                    [
                        "int",
                        "nPointY"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, float flZoom, int nPointX, int nPointY",
                "comments": "Zoom the current page by flZoom ( from 0.0 to 2.0, so to zoom to 120% use 1.2 ), zooming around point X,Y in the page (use 0,0 if you don't care)",
                "name": "SetPageScaleFactor",
                "nargs": 4,
                "retval": "void",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "bool",
                        "bBackgroundMode"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, bool bBackgroundMode",
                "comments": "Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are\n more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,\n all HTML5 video and audio objects will execute \".pause()\" and gain the property \"._steam_background_paused = 1\".\n When background mode is disabled, any video or audio objects with that property will resume with \".play()\".",
                "name": "SetBackgroundMode",
                "nargs": 2,
                "retval": "void",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "float",
                        "flDPIScaling"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, float flDPIScaling",
                "comments": "Scale the output display space by this factor, this is useful when displaying content on high dpi devices.\n Specifies the ratio between physical and logical pixels.",
                "name": "SetDPIScalingFactor",
                "nargs": 2,
                "retval": "void",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "bool",
                        "bAllowed"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, bool bAllowed",
                "comments": "CALLBACKS\n\n  These set of functions are used as responses to callback requests\n\n\n You MUST call this in response to a HTML_StartRequest_t callback\n  Set bAllowed to true to allow this navigation, false to cancel it and stay \n on the current page. You can use this feature to limit the valid pages\n allowed in your HTML surface.",
                "name": "AllowStartRequest",
                "nargs": 2,
                "retval": "void",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "bool",
                        "bResult"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, bool bResult",
                "comments": "You MUST call this in response to a HTML_JSAlert_t or HTML_JSConfirm_t callback\n  Set bResult to true for the OK option of a confirm, use false otherwise",
                "name": "JSDialogResponse",
                "nargs": 2,
                "retval": "void",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "HHTMLBrowser",
                        "unBrowserHandle"
                    ],
                    [
                        "constchar*",
                        "*pchSelectedFiles"
                    ]
                ],
                "argsstr": "HHTMLBrowser unBrowserHandle, const char **pchSelectedFiles",
                "comments": "You MUST call this in response to a HTML_FileOpenDialog_t callback\nIGNOREATTR()",
                "name": "FileLoadDialogResponse",
                "nargs": 2,
                "retval": "void",
                "vfindex": 35
            }
        ]
    },
    "ISteamHTTP": {
        "cppclass": "ISteamHTTP",
        "cppinterface": "STEAMHTTP_INTERFACE_VERSION",
        "cppinterfacev": "STEAMHTTP_INTERFACE_VERSION002",
        "funcs": [
            {
                "args": [
                    [
                        "EHTTPMethod",
                        "eHTTPRequestMethod"
                    ],
                    [
                        "constchar*",
                        "pchAbsoluteURL"
                    ]
                ],
                "argsstr": "EHTTPMethod eHTTPRequestMethod, const char *pchAbsoluteURL",
                "comments": "Initializes a new HTTP request, returning a handle to use in further operations on it.  Requires\n the method (GET or POST) and the absolute URL for the request.  Both http and https are supported,\n so this string must start with http: or https: and should look like http:store.steampowered.com/app/250/ \n or such.",
                "name": "CreateHTTPRequest",
                "nargs": 2,
                "retval": "HTTPRequestHandle",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint64",
                        "ulContextValue"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint64 ulContextValue",
                "comments": "Set a context value for the request, which will be returned in the HTTPRequestCompleted_t callback after\n sending the request.  This is just so the caller can easily keep track of which callbacks go with which request data.",
                "name": "SetHTTPRequestContextValue",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint32",
                        "unTimeoutSeconds"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint32 unTimeoutSeconds",
                "comments": "Set a timeout in seconds for the HTTP request, must be called prior to sending the request.  Default\n timeout is 60 seconds if you don't call this.  Returns false if the handle is invalid, or the request\n has already been sent.",
                "name": "SetHTTPRequestNetworkActivityTimeout",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchHeaderName"
                    ],
                    [
                        "constchar*",
                        "pchHeaderValue"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, const char *pchHeaderValue",
                "comments": "Set a request header value for the request, must be called prior to sending the request.  Will \n return false if the handle is invalid or the request is already sent.",
                "name": "SetHTTPRequestHeaderValue",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchParamName"
                    ],
                    [
                        "constchar*",
                        "pchParamValue"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchParamName, const char *pchParamValue",
                "comments": "Set a GET or POST parameter value on the request, which is set will depend on the EHTTPMethod specified\n when creating the request.  Must be called prior to sending the request.  Will return false if the \n handle is invalid or the request is already sent.",
                "name": "SetHTTPRequestGetOrPostParameter",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "SteamAPICall_t*",
                        "pCallHandle"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, SteamAPICall_t *pCallHandle",
                "comments": "Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on\n asynchronous response via callback.\n\n Note: If the user is in offline mode in Steam, then this will add a only-if-cached cache-control \n header and only do a local cache lookup rather than sending any actual remote request.",
                "name": "SendHTTPRequest",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "SteamAPICall_t*",
                        "pCallHandle"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, SteamAPICall_t *pCallHandle",
                "comments": "Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on\n asynchronous response via callback for completion, and listen for HTTPRequestHeadersReceived_t and \n HTTPRequestDataReceived_t callbacks while streaming.",
                "name": "SendHTTPRequestAndStreamResponse",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest",
                "comments": "Defers a request you have sent, the actual HTTP client code may have many requests queued, and this will move\n the specified request to the tail of the queue.  Returns false on invalid handle, or if the request is not yet sent.",
                "name": "DeferHTTPRequest",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest",
                "comments": "Prioritizes a request you have sent, the actual HTTP client code may have many requests queued, and this will move\n the specified request to the head of the queue.  Returns false on invalid handle, or if the request is not yet sent.",
                "name": "PrioritizeHTTPRequest",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchHeaderName"
                    ],
                    [
                        "uint32*",
                        "unResponseHeaderSize"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, uint32 *unResponseHeaderSize",
                "comments": "Checks if a response header is present in a HTTP response given a handle from HTTPRequestCompleted_t, also \n returns the size of the header value if present so the caller and allocate a correctly sized buffer for\n GetHTTPResponseHeaderValue.",
                "name": "GetHTTPResponseHeaderSize",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchHeaderName"
                    ],
                    [
                        "uint8*",
                        "pHeaderValueBuffer"
                    ],
                    [
                        "uint32",
                        "unBufferSize"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, uint8 *pHeaderValueBuffer, uint32 unBufferSize",
                "comments": "Gets header values from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the\n header is not present or if your buffer is too small to contain it's value.  You should first call \n BGetHTTPResponseHeaderSize to check for the presence of the header and to find out the size buffer needed.",
                "name": "GetHTTPResponseHeaderValue",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint32*",
                        "unBodySize"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint32 *unBodySize",
                "comments": "Gets the size of the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the \n handle is invalid.",
                "name": "GetHTTPResponseBodySize",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint8*",
                        "pBodyDataBuffer"
                    ],
                    [
                        "uint32",
                        "unBufferSize"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint8 *pBodyDataBuffer, uint32 unBufferSize",
                "comments": "Gets the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the \n handle is invalid or is to a streaming response, or if the provided buffer is not the correct size.  Use BGetHTTPResponseBodySize first to find out\n the correct buffer size to use.",
                "name": "GetHTTPResponseBodyData",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint32",
                        "cOffset"
                    ],
                    [
                        "uint8*",
                        "pBodyDataBuffer"
                    ],
                    [
                        "uint32",
                        "unBufferSize"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint32 cOffset, uint8 *pBodyDataBuffer, uint32 unBufferSize",
                "comments": "Gets the body data from a streaming HTTP response given a handle from HTTPRequestDataReceived_t. Will return false if the \n handle is invalid or is to a non-streaming response (meaning it wasn't sent with SendHTTPRequestAndStreamResponse), or if the buffer size and offset \n do not match the size and offset sent in HTTPRequestDataReceived_t.",
                "name": "GetHTTPStreamingResponseBodyData",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest",
                "comments": "Releases an HTTP response handle, should always be called to free resources after receiving a HTTPRequestCompleted_t\n callback and finishing using the response.",
                "name": "ReleaseHTTPRequest",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "float*",
                        "pflPercentOut"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, float *pflPercentOut",
                "comments": "Gets progress on downloading the body for the request.  This will be zero unless a response header has already been\n received which included a content-length field.  For responses that contain no content-length it will report\n zero for the duration of the request as the size is unknown until the connection closes.",
                "name": "GetHTTPDownloadProgressPct",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchContentType"
                    ],
                    [
                        "uint8*",
                        "pubBody"
                    ],
                    [
                        "uint32",
                        "unBodyLen"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchContentType, uint8 *pubBody, uint32 unBodyLen",
                "comments": "Sets the body for an HTTP Post request.  Will fail and return false on a GET request, and will fail if POST params\n have already been set for the request.  Setting this raw body makes it the only contents for the post, the pchContentType\n parameter will set the content-type header for the request so the server may know how to interpret the body.",
                "name": "SetHTTPRequestRawPostBody",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "bool",
                        "bAllowResponsesToModify"
                    ]
                ],
                "argsstr": "bool bAllowResponsesToModify",
                "comments": "Creates a cookie container handle which you must later free with ReleaseCookieContainer().  If bAllowResponsesToModify=true\n than any response to your requests using this cookie container may add new cookies which may be transmitted with\n future requests.  If bAllowResponsesToModify=false than only cookies you explicitly set will be sent.  This API is just for\n during process lifetime, after steam restarts no cookies are persisted and you have no way to access the cookie container across\n repeat executions of your process.",
                "name": "CreateCookieContainer",
                "nargs": 1,
                "retval": "HTTPCookieContainerHandle",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "HTTPCookieContainerHandle",
                        "hCookieContainer"
                    ]
                ],
                "argsstr": "HTTPCookieContainerHandle hCookieContainer",
                "comments": "Release a cookie container you are finished using, freeing it's memory",
                "name": "ReleaseCookieContainer",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "HTTPCookieContainerHandle",
                        "hCookieContainer"
                    ],
                    [
                        "constchar*",
                        "pchHost"
                    ],
                    [
                        "constchar*",
                        "pchUrl"
                    ],
                    [
                        "constchar*",
                        "pchCookie"
                    ]
                ],
                "argsstr": "HTTPCookieContainerHandle hCookieContainer, const char *pchHost, const char *pchUrl, const char *pchCookie",
                "comments": "Adds a cookie to the specified cookie container that will be used with future requests.",
                "name": "SetCookie",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "HTTPCookieContainerHandle",
                        "hCookieContainer"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer",
                "comments": "Set the cookie container to use for a HTTP request",
                "name": "SetHTTPRequestCookieContainer",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "constchar*",
                        "pchUserAgentInfo"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, const char *pchUserAgentInfo",
                "comments": "Set the extra user agent info for a request, this doesn't clobber the normal user agent, it just adds the extra info on the end",
                "name": "SetHTTPRequestUserAgentInfo",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "bool",
                        "bRequireVerifiedCertificate"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, bool bRequireVerifiedCertificate",
                "comments": "Set that https request should require verified SSL certificate via machines certificate trust store",
                "name": "SetHTTPRequestRequiresVerifiedCertificate",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "uint32",
                        "unMilliseconds"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, uint32 unMilliseconds",
                "comments": "Set an absolute timeout on the HTTP request, this is just a total time timeout different than the network activity timeout\n which can bump everytime we get more data",
                "name": "SetHTTPRequestAbsoluteTimeoutMS",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "HTTPRequestHandle",
                        "hRequest"
                    ],
                    [
                        "bool*",
                        "pbWasTimedOut"
                    ]
                ],
                "argsstr": "HTTPRequestHandle hRequest, bool *pbWasTimedOut",
                "comments": "Check if the reason the request failed was because we timed it out (rather than some harder failure)",
                "name": "GetHTTPRequestWasTimedOut",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 24
            }
        ]
    },
    "ISteamInventory": {
        "cppclass": "ISteamInventory",
        "cppinterface": "STEAMINVENTORY_INTERFACE_VERSION",
        "cppinterfacev": "STEAMINVENTORY_INTERFACE_V002",
        "funcs": [
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle",
                "comments": "INVENTORY ASYNC RESULT MANAGEMENT\n\n Asynchronous inventory queries always output a result handle which can be used with\n GetResultStatus, GetResultItems, etc. A SteamInventoryResultReady_t callback will\n be triggered when the asynchronous result becomes ready (or fails).\n\n\n Find out the status of an asynchronous inventory result handle. Possible values:\n  k_EResultPending - still in progress\n  k_EResultOK - done, result ready\n  k_EResultExpired - done, result ready, maybe out of date (see DeserializeResult)\n  k_EResultInvalidParam - ERROR: invalid API call parameters\n  k_EResultServiceUnavailable - ERROR: service temporarily down, you may retry later\n  k_EResultLimitExceeded - ERROR: operation would exceed per-user inventory limits\n  k_EResultFail - ERROR: unknown / generic error\nMETHOD_DESC(Find out the status of an asynchronous inventory result handle.)",
                "name": "GetResultStatus",
                "nargs": 1,
                "retval": "EResult",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ],
                    [
                        "SteamItemDetails_t*",
                        "pOutItemsArray"
                    ],
                    [
                        "uint32*",
                        "punOutItemsArraySize"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle,\n\t\t\t\t\t\t\t\t SteamItemDetails_t *pOutItemsArray,\n\t\t\t\t\t\t\t\tuint32 *punOutItemsArraySize",
                "comments": "Copies the contents of a result set into a flat array. The specific\n contents of the result set depend on which query which was used.\nMETHOD_DESC(Copies the contents of a result set into a flat array. The specific contents of the result set depend on which query which was used.)",
                "name": "GetResultItems",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ],
                    [
                        "uint32",
                        "unItemIndex"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "char*",
                        "pchValueBuffer"
                    ],
                    [
                        "uint32*",
                        "punValueBufferSizeOut"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle, \n\t\t\t\t\t\t\t\t\t\tuint32 unItemIndex, \n\t\t\t\t\t\t\t\t\t\tconst char *pchPropertyName,\n\t\t\t\t\t\t\t\t\t\t char *pchValueBuffer, uint32 *punValueBufferSizeOut",
                "comments": "In combination with GetResultItems, you can use GetResultItemProperty to retrieve\n dynamic string properties for a given item returned in the result set.\n \n Property names are always composed of ASCII letters, numbers, and/or underscores.\n\n Pass a NULL pointer for pchPropertyName to get a comma - separated list of available\n property names.\n\n If pchValueBuffer is NULL, *punValueBufferSize will contain the \n suggested buffer size. Otherwise it will be the number of bytes actually copied\n to pchValueBuffer. If the results do not fit in the given buffer, partial \n results may be copied.",
                "name": "GetResultItemProperty",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle",
                "comments": "Returns the server time at which the result was generated. Compare against\n the value of IClientUtils::GetServerRealTime() to determine age.\nMETHOD_DESC(Returns the server time at which the result was generated. Compare against the value of IClientUtils::GetServerRealTime() to determine age.)",
                "name": "GetResultTimestamp",
                "nargs": 1,
                "retval": "uint32",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ],
                    [
                        "CSteamID",
                        "steamIDExpected"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle, CSteamID steamIDExpected",
                "comments": "Returns true if the result belongs to the target steam ID, false if the\n result does not. This is important when using DeserializeResult, to verify\n that a remote player is not pretending to have a different user's inventory.\nMETHOD_DESC(Returns true if the result belongs to the target steam ID or false if the result does not. This is important when using DeserializeResult to verify that a remote player is not pretending to have a different users inventory.)",
                "name": "CheckResultSteamID",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle",
                "comments": "Destroys a result handle and frees all associated memory.\nMETHOD_DESC(Destroys a result handle and frees all associated memory.)",
                "name": "DestroyResult",
                "nargs": 1,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle",
                "comments": "INVENTORY ASYNC QUERY\n\n\n Captures the entire state of the current user's Steam inventory.\n You must call DestroyResult on this handle when you are done with it.\n Returns false and sets *pResultHandle to zero if inventory is unavailable.\n Note: calls to this function are subject to rate limits and may return\n cached results if called too frequently. It is suggested that you call\n this function only when you are about to display the user's full inventory,\n or if you expect that the inventory may have changed.\nMETHOD_DESC(Captures the entire state of the current users Steam inventory.)",
                "name": "GetAllItems",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "constSteamItemInstanceID_t*",
                        "pInstanceIDs"
                    ],
                    [
                        "uint32",
                        "unCountInstanceIDs"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemInstanceID_t *pInstanceIDs, uint32 unCountInstanceIDs",
                "comments": "Captures the state of a subset of the current user's Steam inventory,\n identified by an array of item instance IDs. The results from this call\n can be serialized and passed to other players to \"prove\" that the current\n user owns specific items, without exposing the user's entire inventory.\n For example, you could call GetItemsByID with the IDs of the user's\n currently equipped cosmetic items and serialize this to a buffer, and\n then transmit this buffer to other players upon joining a game.\nMETHOD_DESC(Captures the state of a subset of the current users Steam inventory identified by an array of item instance IDs.)",
                "name": "GetItemsByID",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t",
                        "resultHandle"
                    ],
                    [
                        "void*",
                        "pOutBuffer"
                    ],
                    [
                        "uint32*",
                        "punOutBufferSize"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t resultHandle,  void *pOutBuffer, uint32 *punOutBufferSize",
                "comments": "RESULT SERIALIZATION AND AUTHENTICATION\n\n Serialized result sets contain a short signature which can't be forged\n or replayed across different game sessions. A result set can be serialized\n on the local client, transmitted to other players via your game networking,\n and deserialized by the remote players. This is a secure way of preventing\n hackers from lying about posessing rare/high-value items.\n\n Serializes a result set with signature bytes to an output buffer. Pass\n NULL as an output buffer to get the required size via punOutBufferSize.\n The size of a serialized result depends on the number items which are being\n serialized. When securely transmitting items to other players, it is\n recommended to use \"GetItemsByID\" first to create a minimal result set.\n Results have a built-in timestamp which will be considered \"expired\" after\n an hour has elapsed. See DeserializeResult for expiration handling.",
                "name": "SerializeResult",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pOutResultHandle"
                    ],
                    [
                        "",
                        "BUFFER_COUNT(punOutBufferSize"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pOutResultHandle, BUFFER_COUNT(punOutBufferSize",
                "comments": "Deserializes a result set and verifies the signature bytes. Returns false\n if bRequireFullOnlineVerify is set but Steam is running in Offline mode.\n Otherwise returns true and then delivers error codes via GetResultStatus.\n\n The bRESERVED_MUST_BE_FALSE flag is reserved for future use and should not\n be set to true by your game at this time.\n\n DeserializeResult has a potential soft-failure mode where the handle status\n is set to k_EResultExpired. GetResultItems() still succeeds in this mode.\n The \"expired\" result could indicate that the data may be out of date - not\n just due to timed expiration (one hour), but also because one of the items\n in the result set may have been traded or consumed since the result set was\n generated. You could compare the timestamp from GetResultTimestamp() to\n ISteamUtils::GetServerRealTime() to determine how old the data is. You could\n simply ignore the \"expired\" result code and continue as normal, or you\n could challenge the player with expired data to send an updated result set.",
                "name": "DeserializeResult",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "constSteamItemDef_t*",
                        "pArrayItemDefs"
                    ],
                    [
                        "constuint32*",
                        "punArrayQuantity"
                    ],
                    [
                        "uint32",
                        "unArrayLength"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemDef_t *pArrayItemDefs,  const uint32 *punArrayQuantity, uint32 unArrayLength",
                "comments": "INVENTORY ASYNC MODIFICATION\n\n\n GenerateItems() creates one or more items and then generates a SteamInventoryCallback_t\n notification with a matching nCallbackContext parameter. This API is only intended\n for prototyping - it is only usable by Steam accounts that belong to the publisher group \n for your game.\n If punArrayQuantity is not NULL, it should be the same length as pArrayItems and should\n describe the quantity of each item to generate.",
                "name": "GenerateItems",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle",
                "comments": "GrantPromoItems() checks the list of promotional items for which the user may be eligible\n and grants the items (one time only).  On success, the result set will include items which\n were granted, if any. If no items were granted because the user isn't eligible for any\n promotions, this is still considered a success.\nMETHOD_DESC(GrantPromoItems() checks the list of promotional items for which the user may be eligible and grants the items (one time only).)",
                "name": "GrantPromoItems",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "SteamItemDef_t",
                        "itemDef"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemDef_t itemDef",
                "comments": "AddPromoItem() / AddPromoItems() are restricted versions of GrantPromoItems(). Instead of\n scanning for all eligible promotional items, the check is restricted to a single item\n definition or set of item definitions. This can be useful if your game has custom UI for\n showing a specific promo item to the user.",
                "name": "AddPromoItem",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "constSteamItemDef_t*",
                        "pArrayItemDefs"
                    ],
                    [
                        "uint32",
                        "unArrayLength"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemDef_t *pArrayItemDefs, uint32 unArrayLength",
                "name": "AddPromoItems",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "itemConsume"
                    ],
                    [
                        "uint32",
                        "unQuantity"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemInstanceID_t itemConsume, uint32 unQuantity",
                "comments": "ConsumeItem() removes items from the inventory, permanently. They cannot be recovered.\n Not for the faint of heart - if your game implements item removal at all, a high-friction\n UI confirmation process is highly recommended.\nMETHOD_DESC(ConsumeItem() removes items from the inventory permanently.)",
                "name": "ConsumeItem",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "constSteamItemDef_t*",
                        "pArrayGenerate"
                    ],
                    [
                        "constuint32*",
                        "punArrayGenerateQuantity"
                    ],
                    [
                        "uint32",
                        "unArrayGenerateLength"
                    ],
                    [
                        "constSteamItemInstanceID_t*",
                        "pArrayDestroy"
                    ],
                    [
                        "constuint32*",
                        "punArrayDestroyQuantity"
                    ],
                    [
                        "uint32",
                        "unArrayDestroyLength"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle,\n\t\t\t\t\t\t\t\t const SteamItemDef_t *pArrayGenerate,  const uint32 *punArrayGenerateQuantity, uint32 unArrayGenerateLength,\n\t\t\t\t\t\t\t\t const SteamItemInstanceID_t *pArrayDestroy,  const uint32 *punArrayDestroyQuantity, uint32 unArrayDestroyLength",
                "comments": "ExchangeItems() is an atomic combination of item generation and consumption. \n It can be used to implement crafting recipes or transmutations, or items which unpack \n themselves into other items (e.g., a chest). \n Exchange recipes are defined in the ItemDef, and explicitly list the required item \n types and resulting generated type. \n Exchange recipes are evaluated atomically by the Inventory Service; if the supplied\n components do not match the recipe, or do not contain sufficient quantity, the \n exchange will fail.",
                "name": "ExchangeItems",
                "nargs": 7,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "itemIdSource"
                    ],
                    [
                        "uint32",
                        "unQuantity"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "itemIdDest"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemInstanceID_t itemIdSource, uint32 unQuantity, SteamItemInstanceID_t itemIdDest",
                "comments": "TransferItemQuantity() is intended for use with items which are \"stackable\" (can have\n quantity greater than one). It can be used to split a stack into two, or to transfer\n quantity from one stack into another stack of identical items. To split one stack into\n two, pass k_SteamItemInstanceIDInvalid for itemIdDest and a new item will be generated.",
                "name": "TransferItemQuantity",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "TIMED DROPS AND PLAYTIME CREDIT\n\n\n Deprecated. Calling this method is not required for proper playtime accounting.\nMETHOD_DESC( Deprecated method. Playtime accounting is performed on the Steam servers. )",
                "name": "SendItemDropHeartbeat",
                "nargs": 0,
                "retval": "void",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "SteamItemDef_t",
                        "dropListDefinition"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemDef_t dropListDefinition",
                "comments": "Playtime credit must be consumed and turned into item drops by your game. Only item\n definitions which are marked as \"playtime item generators\" can be spawned. The call\n will return an empty result set if there is not enough playtime credit for a drop.\n Your game should call TriggerItemDrop at an appropriate time for the user to receive\n new items, such as between rounds or while the player is dead. Note that players who\n hack their clients could modify the value of \"dropListDefinition\", so do not use it\n to directly control rarity.\n See your Steamworks configuration to set playtime drop rates for individual itemdefs.\n The client library will suppress too-frequent calls to this method.\nMETHOD_DESC(Playtime credit must be consumed and turned into item drops by your game.)",
                "name": "TriggerItemDrop",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ],
                    [
                        "CSteamID",
                        "steamIDTradePartner"
                    ],
                    [
                        "constSteamItemInstanceID_t*",
                        "pArrayGive"
                    ],
                    [
                        "constuint32*",
                        "pArrayGiveQuantity"
                    ],
                    [
                        "uint32",
                        "nArrayGiveLength"
                    ],
                    [
                        "constSteamItemInstanceID_t*",
                        "pArrayGet"
                    ],
                    [
                        "constuint32*",
                        "pArrayGetQuantity"
                    ],
                    [
                        "uint32",
                        "nArrayGetLength"
                    ]
                ],
                "argsstr": "SteamInventoryResult_t *pResultHandle, CSteamID steamIDTradePartner,\n\t\t\t\t\t\t\t  const SteamItemInstanceID_t *pArrayGive,  const uint32 *pArrayGiveQuantity, uint32 nArrayGiveLength,\n\t\t\t\t\t\t\t  const SteamItemInstanceID_t *pArrayGet,  const uint32 *pArrayGetQuantity, uint32 nArrayGetLength",
                "comments": "Deprecated. This method is not supported.",
                "name": "TradeItems",
                "nargs": 8,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "ITEM DEFINITIONS\n\n Item definitions are a mapping of \"definition IDs\" (integers between 1 and 1000000)\n to a set of string properties. Some of these properties are required to display items\n on the Steam community web site. Other properties can be defined by applications.\n Use of these functions is optional; there is no reason to call LoadItemDefinitions\n if your game hardcodes the numeric definition IDs (eg, purple face mask = 20, blue\n weapon mod = 55) and does not allow for adding new item types without a client patch.\n\n\n LoadItemDefinitions triggers the automatic load and refresh of item definitions.\n Every time new item definitions are available (eg, from the dynamic addition of new\n item types while players are still in-game), a SteamInventoryDefinitionUpdate_t\n callback will be fired.\nMETHOD_DESC(LoadItemDefinitions triggers the automatic load and refresh of item definitions.)",
                "name": "LoadItemDefinitions",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "SteamItemDef_t*",
                        "pItemDefIDs"
                    ],
                    [
                        "DESC(Sizeofarrayispassedinandactualsizeusedisreturnedinthis",
                        "param"
                    ]
                ],
                "argsstr": "SteamItemDef_t *pItemDefIDs,\n\t\t\t\tDESC(Size of array is passed in and actual size used is returned in this param",
                "comments": "GetItemDefinitionIDs returns the set of all defined item definition IDs (which are\n defined via Steamworks configuration, and not necessarily contiguous integers).\n If pItemDefIDs is null, the call will return true and *punItemDefIDsArraySize will\n contain the total size necessary for a subsequent call. Otherwise, the call will\n return false if and only if there is not enough space in the output array.",
                "name": "GetItemDefinitionIDs",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "SteamItemDef_t",
                        "iDefinition"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "char*",
                        "pchValueBuffer"
                    ],
                    [
                        "uint32*",
                        "punValueBufferSizeOut"
                    ]
                ],
                "argsstr": "SteamItemDef_t iDefinition, const char *pchPropertyName,\n\t\t char *pchValueBuffer, uint32 *punValueBufferSizeOut",
                "comments": "GetItemDefinitionProperty returns a string property from a given item definition.\n Note that some properties (for example, \"name\") may be localized and will depend\n on the current Steam language settings (see ISteamApps::GetCurrentGameLanguage).\n Property names are always composed of ASCII letters, numbers, and/or underscores.\n Pass a NULL pointer for pchPropertyName to get a comma - separated list of available\n property names. If pchValueBuffer is NULL, *punValueBufferSize will contain the \n suggested buffer size. Otherwise it will be the number of bytes actually copied\n to pchValueBuffer. If the results do not fit in the given buffer, partial \n results may be copied.",
                "name": "GetItemDefinitionProperty",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "CSteamID steamID",
                "comments": "Request the list of \"eligible\" promo items that can be manually granted to the given\n user.  These are promo items of type \"manual\" that won't be granted automatically.\n An example usage of this is an item that becomes available every week.\nCALL_RESULT( SteamInventoryEligiblePromoItemDefIDs_t )",
                "name": "RequestEligiblePromoItemDefinitionsIDs",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ],
                    [
                        "SteamItemDef_t*",
                        "pItemDefIDs"
                    ],
                    [
                        "DESC(Sizeofarrayispassedinandactualsizeusedisreturnedinthis",
                        "param"
                    ]
                ],
                "argsstr": "CSteamID steamID,\n\t\t SteamItemDef_t *pItemDefIDs,\n\t\tDESC(Size of array is passed in and actual size used is returned in this param",
                "comments": "After handling a SteamInventoryEligiblePromoItemDefIDs_t call result, use this\n function to pull out the list of item definition ids that the user can be\n manually granted via the AddPromoItems() call.",
                "name": "GetEligiblePromoItemDefinitionIDs",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "constSteamItemDef_t*",
                        "pArrayItemDefs"
                    ],
                    [
                        "constuint32*",
                        "punArrayQuantity"
                    ],
                    [
                        "uint32",
                        "unArrayLength"
                    ]
                ],
                "argsstr": "const SteamItemDef_t *pArrayItemDefs,  const uint32 *punArrayQuantity, uint32 unArrayLength",
                "comments": "Starts the purchase process for the given item definitions.  The callback SteamInventoryStartPurchaseResult_t\n will be posted if Steam was able to initialize the transaction.\n \n Once the purchase has been authorized and completed by the user, the callback SteamInventoryResultReady_t \n will be posted.\nCALL_RESULT( SteamInventoryStartPurchaseResult_t )",
                "name": "StartPurchase",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 25
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Request current prices for all applicable item definitions\nCALL_RESULT( SteamInventoryRequestPricesResult_t )",
                "name": "RequestPrices",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 26
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the number of items with prices.  Need to call RequestPrices() first.",
                "name": "GetNumItemsWithPrices",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "SteamItemDef_t*",
                        "pArrayItemDefs"
                    ],
                    [
                        "uint64*",
                        "pPrices"
                    ],
                    [
                        "uint32",
                        "unArrayLength"
                    ]
                ],
                "argsstr": "SteamItemDef_t *pArrayItemDefs,\n\t\t\t\t\t\t\t\t\t   uint64 *pPrices,\n\t\t\t\t\t\t\t\t\t uint32 unArrayLength",
                "comments": "Returns item definition ids and their prices in the user's local currency.\n Need to call RequestPrices() first.",
                "name": "GetItemsWithPrices",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "SteamItemDef_t",
                        "iDefinition"
                    ],
                    [
                        "uint64*",
                        "pPrice"
                    ]
                ],
                "argsstr": "SteamItemDef_t iDefinition, uint64 *pPrice",
                "comments": "Retrieves the price for the item definition id\n Returns false if there is no price stored for the item definition.",
                "name": "GetItemPrice",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 29
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Create a request to update properties on items",
                "name": "StartUpdateProperties",
                "nargs": 0,
                "retval": "SteamInventoryUpdateHandle_t",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "nItemID"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName",
                "comments": "Remove the property on the item",
                "name": "RemoveProperty",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "nItemID"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "constchar*",
                        "pchPropertyValue"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, const char *pchPropertyValue",
                "comments": "Accessor methods to set properties on items",
                "name": "SetProperty",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "nItemID"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, bool bValue",
                "name": "SetProperty",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "nItemID"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "int64",
                        "nValue"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, int64 nValue",
                "name": "SetProperty",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamItemInstanceID_t",
                        "nItemID"
                    ],
                    [
                        "constchar*",
                        "pchPropertyName"
                    ],
                    [
                        "float",
                        "flValue"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, float flValue",
                "name": "SetProperty",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "SteamInventoryUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "SteamInventoryResult_t*",
                        "pResultHandle"
                    ]
                ],
                "argsstr": "SteamInventoryUpdateHandle_t handle, SteamInventoryResult_t * pResultHandle",
                "comments": "Submit the update request by handle",
                "name": "SubmitUpdateProperties",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 36
            }
        ]
    },
    "ISteamMatchmaking": {
        "cppclass": "ISteamMatchmaking",
        "cppinterface": "STEAMMATCHMAKING_INTERFACE_VERSION",
        "cppinterfacev": "SteamMatchMaking009",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Game server favorites storage\n saves basic details about a multiplayer game server locally\n\n returns the number of favorites servers the user has stored",
                "name": "GetFavoriteGameCount",
                "nargs": 0,
                "retval": "int",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "int",
                        "iGame"
                    ],
                    [
                        "AppId_t*",
                        "pnAppID"
                    ],
                    [
                        "uint32*",
                        "pnIP"
                    ],
                    [
                        "uint16*",
                        "pnConnPort"
                    ],
                    [
                        "uint16*",
                        "pnQueryPort"
                    ],
                    [
                        "uint32*",
                        "punFlags"
                    ],
                    [
                        "uint32*",
                        "pRTime32LastPlayedOnServer"
                    ]
                ],
                "argsstr": "int iGame, AppId_t *pnAppID, uint32 *pnIP, uint16 *pnConnPort, uint16 *pnQueryPort, uint32 *punFlags, uint32 *pRTime32LastPlayedOnServer",
                "comments": "Returns the details of the game server\n iGame is of range [0,GetFavoriteGameCount())\n *pnIP, *pnConnPort are filled in the with IP:port of the game server\n *punFlags specify whether the game server was stored as an explicit favorite or in the history of connections\n *pRTime32LastPlayedOnServer is filled in the with the Unix time the favorite was added",
                "name": "GetFavoriteGame",
                "nargs": 7,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ],
                    [
                        "uint32",
                        "nIP"
                    ],
                    [
                        "uint16",
                        "nConnPort"
                    ],
                    [
                        "uint16",
                        "nQueryPort"
                    ],
                    [
                        "uint32",
                        "unFlags"
                    ],
                    [
                        "uint32",
                        "rTime32LastPlayedOnServer"
                    ]
                ],
                "argsstr": "AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags, uint32 rTime32LastPlayedOnServer",
                "comments": "Adds the game server to the local list; updates the time played of the server if it already exists in the list",
                "name": "AddFavoriteGame",
                "nargs": 6,
                "retval": "int",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ],
                    [
                        "uint32",
                        "nIP"
                    ],
                    [
                        "uint16",
                        "nConnPort"
                    ],
                    [
                        "uint16",
                        "nQueryPort"
                    ],
                    [
                        "uint32",
                        "unFlags"
                    ]
                ],
                "argsstr": "AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags",
                "comments": "Removes the game server from the local storage; returns true if one was removed",
                "name": "RemoveFavoriteGame",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "/\n Game lobby functions\n\n Get a list of relevant lobbies\n this is an asynchronous request\n results will be returned by LobbyMatchList_t callback & call result, with the number of lobbies found\n this will never return lobbies that are full\n to add more filter, the filter calls below need to be call before each and every RequestLobbyList() call\n use the CCallResult<> object in steam_api.h to match the SteamAPICall_t call result to a function in an object, e.g.\n/*\nclass CMyLobbyListManager\n{\nCCallResult<CMyLobbyListManager, LobbyMatchList_t> m_CallResultLobbyMatchList;\nvoid FindLobbies()\n{\n SteamMatchmaking()->AddRequestLobbyListFilter*() functions would be called here, before RequestLobbyList()\nSteamAPICall_t hSteamAPICall = SteamMatchmaking()->RequestLobbyList();\nm_CallResultLobbyMatchList.Set( hSteamAPICall, this, &CMyLobbyListManager::OnLobbyMatchList );\n}\n\nvoid OnLobbyMatchList( LobbyMatchList_t *pLobbyMatchList, bool bIOFailure )\n{\n lobby list has be retrieved from Steam back-end, use results\n}\n}\n*/\n \nCALL_RESULT( LobbyMatchList_t )",
                "name": "RequestLobbyList",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchKeyToMatch"
                    ],
                    [
                        "constchar*",
                        "pchValueToMatch"
                    ],
                    [
                        "ELobbyComparison",
                        "eComparisonType"
                    ]
                ],
                "argsstr": "const char *pchKeyToMatch, const char *pchValueToMatch, ELobbyComparison eComparisonType",
                "comments": "Filters for lobbies\n this needs to be called before RequestLobbyList() to take effect\n these are cleared on each call to RequestLobbyList()",
                "name": "AddRequestLobbyListStringFilter",
                "nargs": 3,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchKeyToMatch"
                    ],
                    [
                        "int",
                        "nValueToMatch"
                    ],
                    [
                        "ELobbyComparison",
                        "eComparisonType"
                    ]
                ],
                "argsstr": "const char *pchKeyToMatch, int nValueToMatch, ELobbyComparison eComparisonType",
                "comments": "Numerical comparison",
                "name": "AddRequestLobbyListNumericalFilter",
                "nargs": 3,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchKeyToMatch"
                    ],
                    [
                        "int",
                        "nValueToBeCloseTo"
                    ]
                ],
                "argsstr": "const char *pchKeyToMatch, int nValueToBeCloseTo",
                "comments": "Returns results closest to the specified value. Multiple near filters can be added, with early filters taking precedence",
                "name": "AddRequestLobbyListNearValueFilter",
                "nargs": 2,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "int",
                        "nSlotsAvailable"
                    ]
                ],
                "argsstr": "int nSlotsAvailable",
                "comments": "Returns only lobbies with the specified number of slots available",
                "name": "AddRequestLobbyListFilterSlotsAvailable",
                "nargs": 1,
                "retval": "void",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "ELobbyDistanceFilter",
                        "eLobbyDistanceFilter"
                    ]
                ],
                "argsstr": "ELobbyDistanceFilter eLobbyDistanceFilter",
                "comments": "Sets the distance for which we should search for lobbies (based on users IP address to location map on the Steam backed)",
                "name": "AddRequestLobbyListDistanceFilter",
                "nargs": 1,
                "retval": "void",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "int",
                        "cMaxResults"
                    ]
                ],
                "argsstr": "int cMaxResults",
                "comments": "Sets how many results to return, the lower the count the faster it is to download the lobby results & details to the client",
                "name": "AddRequestLobbyListResultCountFilter",
                "nargs": 1,
                "retval": "void",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "name": "AddRequestLobbyListCompatibleMembersFilter",
                "nargs": 1,
                "retval": "void",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "int",
                        "iLobby"
                    ]
                ],
                "argsstr": "int iLobby",
                "comments": "Returns the CSteamID of a lobby, as retrieved by a RequestLobbyList call\n should only be called after a LobbyMatchList_t callback is received\n iLobby is of the range [0, LobbyMatchList_t::m_nLobbiesMatching)\n the returned CSteamID::IsValid() will be false if iLobby is out of range",
                "name": "GetLobbyByIndex",
                "nargs": 1,
                "retval": "CSteamID",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "ELobbyType",
                        "eLobbyType"
                    ],
                    [
                        "int",
                        "cMaxMembers"
                    ]
                ],
                "argsstr": "ELobbyType eLobbyType, int cMaxMembers",
                "comments": "Create a lobby on the Steam servers.\n If private, then the lobby will not be returned by any RequestLobbyList() call; the CSteamID\n of the lobby will need to be communicated via game channels or via InviteUserToLobby()\n this is an asynchronous request\n results will be returned by LobbyCreated_t callback and call result; lobby is joined & ready to use at this point\n a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)\nCALL_RESULT( LobbyCreated_t )",
                "name": "CreateLobby",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Joins an existing lobby\n this is an asynchronous request\n results will be returned by LobbyEnter_t callback & call result, check m_EChatRoomEnterResponse to see if was successful\n lobby metadata is available to use immediately on this call completing\nCALL_RESULT( LobbyEnter_t )",
                "name": "JoinLobby",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Leave a lobby; this will take effect immediately on the client side\n other users in the lobby will be notified by a LobbyChatUpdate_t callback",
                "name": "LeaveLobby",
                "nargs": 1,
                "retval": "void",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "CSteamID",
                        "steamIDInvitee"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, CSteamID steamIDInvitee",
                "comments": "Invite another user to the lobby\n the target user will receive a LobbyInvite_t callback\n will return true if the invite is successfully sent, whether or not the target responds\n returns false if the local user is not connected to the Steam servers\n if the other user clicks the join link, a GameLobbyJoinRequested_t will be posted if the user is in-game,\n or if the game isn't running yet the game will be launched with the parameter +connect_lobby <64-bit lobby id>",
                "name": "InviteUserToLobby",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Lobby iteration, for viewing details of users in a lobby\n only accessible if the lobby user is a member of the specified lobby\n persona information for other lobby members (name, avatar, etc.) will be asynchronously received\n and accessible via ISteamFriends interface\n\n returns the number of users in the specified lobby",
                "name": "GetNumLobbyMembers",
                "nargs": 1,
                "retval": "int",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "int",
                        "iMember"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, int iMember",
                "comments": "Returns the CSteamID of a user in the lobby\n iMember is of range [0,GetNumLobbyMembers())\n note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby",
                "name": "GetLobbyMemberByIndex",
                "nargs": 2,
                "retval": "CSteamID",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, const char *pchKey",
                "comments": "Get data associated with this lobby\n takes a simple key, and returns the string associated with it\n \"\" will be returned if no value is set, or if steamIDLobby is invalid",
                "name": "GetLobbyData",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, const char *pchKey, const char *pchValue",
                "comments": "Sets a key/value pair in the lobby metadata\n each user in the lobby will be broadcast this new value, and any new users joining will receive any existing data\n this can be used to set lobby names, map, etc.\n to reset a key, just set it to \"\"\n other users in the lobby will receive notification of the lobby data change via a LobbyDataUpdate_t callback",
                "name": "SetLobbyData",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Returns the number of metadata keys set on the specified lobby",
                "name": "GetLobbyDataCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "int",
                        "iLobbyData"
                    ],
                    [
                        "char*",
                        "pchKey"
                    ],
                    [
                        "int",
                        "cchKeyBufferSize"
                    ],
                    [
                        "char*",
                        "pchValue"
                    ],
                    [
                        "int",
                        "cchValueBufferSize"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, int iLobbyData, char *pchKey, int cchKeyBufferSize, char *pchValue, int cchValueBufferSize",
                "comments": "Returns a lobby metadata key/values pair by index, of range [0, GetLobbyDataCount())",
                "name": "GetLobbyDataByIndex",
                "nargs": 6,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, const char *pchKey",
                "comments": "Removes a metadata key from the lobby",
                "name": "DeleteLobbyData",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, CSteamID steamIDUser, const char *pchKey",
                "comments": "Gets per-user metadata for someone in this lobby",
                "name": "GetLobbyMemberData",
                "nargs": 3,
                "retval": "const char *",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, const char *pchKey, const char *pchValue",
                "comments": "Sets per-user metadata (for the local user implicitly)",
                "name": "SetLobbyMemberData",
                "nargs": 3,
                "retval": "void",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "constvoid*",
                        "pvMsgBody"
                    ],
                    [
                        "int",
                        "cubMsgBody"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, const void *pvMsgBody, int cubMsgBody",
                "comments": "Broadcasts a chat message to the all the users in the lobby\n users in the lobby (including the local user) will receive a LobbyChatMsg_t callback\n returns true if the message is successfully sent\n pvMsgBody can be binary or text data, up to 4k\n if pvMsgBody is text, cubMsgBody should be strlen( text ) + 1, to include the null terminator",
                "name": "SendLobbyChatMsg",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "int",
                        "iChatID"
                    ],
                    [
                        "CSteamID*",
                        "pSteamIDUser"
                    ],
                    [
                        "void*",
                        "pvData"
                    ],
                    [
                        "int",
                        "cubData"
                    ],
                    [
                        "EChatEntryType*",
                        "peChatEntryType"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, int iChatID,  CSteamID *pSteamIDUser, void *pvData, int cubData, EChatEntryType *peChatEntryType",
                "comments": "Get a chat message as specified in a LobbyChatMsg_t callback\n iChatID is the LobbyChatMsg_t::m_iChatID value in the callback\n *pSteamIDUser is filled in with the CSteamID of the member\n *pvData is filled in with the message itself\n return value is the number of bytes written into the buffer",
                "name": "GetLobbyChatEntry",
                "nargs": 6,
                "retval": "int",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Refreshes metadata for a lobby you're not necessarily in right now\n you never do this for lobbies you're a member of, only if your\n this will send down all the metadata associated with a lobby\n this is an asynchronous call\n returns false if the local user is not connected to the Steam servers\n results will be returned by a LobbyDataUpdate_t callback\n if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false",
                "name": "RequestLobbyData",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "uint32",
                        "unGameServerIP"
                    ],
                    [
                        "uint16",
                        "unGameServerPort"
                    ],
                    [
                        "CSteamID",
                        "steamIDGameServer"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, uint32 unGameServerIP, uint16 unGameServerPort, CSteamID steamIDGameServer",
                "comments": "Sets the game server associated with the lobby\n usually at this point, the users will join the specified game server\n either the IP/Port or the steamID of the game server has to be valid, depending on how you want the clients to be able to connect",
                "name": "SetLobbyGameServer",
                "nargs": 4,
                "retval": "void",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "uint32*",
                        "punGameServerIP"
                    ],
                    [
                        "uint16*",
                        "punGameServerPort"
                    ],
                    [
                        "CSteamID*",
                        "psteamIDGameServer"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, uint32 *punGameServerIP, uint16 *punGameServerPort,  CSteamID *psteamIDGameServer",
                "comments": "Returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist",
                "name": "GetLobbyGameServer",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "int",
                        "cMaxMembers"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, int cMaxMembers",
                "comments": "Set the limit on the # of users who can join the lobby",
                "name": "SetLobbyMemberLimit",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Returns the current limit on the # of users who can join the lobby; returns 0 if no limit is defined",
                "name": "GetLobbyMemberLimit",
                "nargs": 1,
                "retval": "int",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "ELobbyType",
                        "eLobbyType"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, ELobbyType eLobbyType",
                "comments": "Updates which type of lobby it is\n only lobbies that are k_ELobbyTypePublic or k_ELobbyTypeInvisible, and are set to joinable, will be returned by RequestLobbyList() calls",
                "name": "SetLobbyType",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "bool",
                        "bLobbyJoinable"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, bool bLobbyJoinable",
                "comments": "Sets whether or not a lobby is joinable - defaults to true for a new lobby\n if set to false, no user can join, even if they are a friend or have been invited",
                "name": "SetLobbyJoinable",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby",
                "comments": "Returns the current lobby owner\n you must be a member of the lobby to access this\n there always one lobby owner - if the current owner leaves, another user will become the owner\n it is possible (bur rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner",
                "name": "GetLobbyOwner",
                "nargs": 1,
                "retval": "CSteamID",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "CSteamID",
                        "steamIDNewOwner"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, CSteamID steamIDNewOwner",
                "comments": "Changes who the lobby owner is\n you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby\n after completion, the local user will no longer be the owner",
                "name": "SetLobbyOwner",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 36
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDLobby"
                    ],
                    [
                        "CSteamID",
                        "steamIDLobbyDependent"
                    ]
                ],
                "argsstr": "CSteamID steamIDLobby, CSteamID steamIDLobbyDependent",
                "comments": "Link two lobbies for the purposes of checking player compatibility\n you must be the lobby owner of both lobbies",
                "name": "SetLinkedLobby",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 37
            },
            {
                "args": [
                    [
                        "unsignedint",
                        "iGameBootAttributes"
                    ]
                ],
                "argsstr": "unsigned int iGameBootAttributes",
                "comments": "Changes who the lobby owner is\n you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby\n after completion, the local user will no longer be the owner",
                "name": "CheckForPSNGameBootInvite",
                "nargs": 1,
                "retval": "void",
                "vfindex": 38
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ],
                    [
                        "int",
                        "iServer"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest, int iServer",
                "comments": "-----------------------------------------------------------------------------\n Callback interfaces for server list functions (see ISteamMatchmakingServers below)\n\n The idea here is that your game code implements objects that implement these\n interfaces to receive callback notifications after calling asynchronous functions\n inside the ISteamMatchmakingServers() interface below.\n\n This is different than normal Steam callback handling due to the potentially\n large size of server lists.\n-----------------------------------------------------------------------------\n\n-----------------------------------------------------------------------------\n Typedef for handle type you will receive when requesting server list.\n-----------------------------------------------------------------------------\ntypedef void* HServerListRequest;\n\n-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after a server list refresh\n or an individual server update.\n\n Since you get these callbacks after requesting full list refreshes you will\n usually implement this interface inside an object like CServerBrowser.  If that\n object is getting destructed you should use ISteamMatchMakingServers()->CancelQuery()\n to cancel any in-progress queries so you don't get a callback into the destructed\n object and crash.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingServerListResponse\n{\npublic:\n Server has responded ok with updated data",
                "name": "ServerResponded",
                "nargs": 2,
                "retval": "void",
                "vfindex": 39
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ],
                    [
                        "int",
                        "iServer"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest, int iServer",
                "comments": "Server has failed to respond",
                "name": "ServerFailedToRespond",
                "nargs": 2,
                "retval": "void",
                "vfindex": 40
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ],
                    [
                        "EMatchMakingServerResponse",
                        "response"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest, EMatchMakingServerResponse response",
                "comments": "A list refresh you had initiated is now 100% completed",
                "name": "RefreshComplete",
                "nargs": 2,
                "retval": "void",
                "vfindex": 41
            },
            {
                "args": [
                    [
                        "gameserveritem_t",
                        "&server"
                    ]
                ],
                "argsstr": "gameserveritem_t &server",
                "comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after pinging an individual server \n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->PingServer() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingPingResponse\n{\npublic:\n Server has responded successfully and has updated data",
                "name": "ServerResponded",
                "nargs": 1,
                "retval": "void",
                "vfindex": 42
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Server failed to respond to the ping request",
                "name": "ServerFailedToRespond",
                "nargs": 0,
                "retval": "void",
                "vfindex": 43
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int",
                        "nScore"
                    ],
                    [
                        "float",
                        "flTimePlayed"
                    ]
                ],
                "argsstr": "const char *pchName, int nScore, float flTimePlayed",
                "comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after requesting details on\n who is playing on a particular server.\n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->PlayerDetails() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingPlayersResponse\n{\npublic:\n Got data on a new player on the server -- you'll get this callback once per player\n on the server which you have requested player data on.",
                "name": "AddPlayerToList",
                "nargs": 3,
                "retval": "void",
                "vfindex": 44
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "The server failed to respond to the request for player details",
                "name": "PlayersFailedToRespond",
                "nargs": 0,
                "retval": "void",
                "vfindex": 45
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "The server has finished responding to the player details request \n (ie, you won't get anymore AddPlayerToList callbacks)",
                "name": "PlayersRefreshComplete",
                "nargs": 0,
                "retval": "void",
                "vfindex": 46
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchRule"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "const char *pchRule, const char *pchValue",
                "comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after requesting rules\n details on a particular server.\n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->ServerRules() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingRulesResponse\n{\npublic:\n Got data on a rule on the server -- you'll get one of these per rule defined on\n the server you are querying",
                "name": "RulesResponded",
                "nargs": 2,
                "retval": "void",
                "vfindex": 47
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "The server failed to respond to the request for rule details",
                "name": "RulesFailedToRespond",
                "nargs": 0,
                "retval": "void",
                "vfindex": 48
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "The server has finished responding to the rule details request \n (ie, you won't get anymore RulesResponded callbacks)",
                "name": "RulesRefreshComplete",
                "nargs": 0,
                "retval": "void",
                "vfindex": 49
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "MatchMakingKeyValuePair_t*",
                        "*ppchFilters"
                    ],
                    [
                        "uint32",
                        "nFilters"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "comments": "-----------------------------------------------------------------------------\n Typedef for handle type you will receive when querying details on an individual server.\n-----------------------------------------------------------------------------\ntypedef int HServerQuery;\nconst int HSERVERQUERY_INVALID = 0xffffffff;\n\n-----------------------------------------------------------------------------\n Purpose: Functions for match making services for clients to get to game lists and details\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingServers\n{\npublic:\n Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\n Each call allocates a new asynchronous request object.\n Request object must be released by calling ReleaseRequest( hServerListRequest )",
                "name": "RequestInternetServerList",
                "nargs": 4,
                "retval": "HServerListRequest",
                "vfindex": 50
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "name": "RequestLANServerList",
                "nargs": 2,
                "retval": "HServerListRequest",
                "vfindex": 51
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "MatchMakingKeyValuePair_t*",
                        "*ppchFilters"
                    ],
                    [
                        "uint32",
                        "nFilters"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "name": "RequestFriendsServerList",
                "nargs": 4,
                "retval": "HServerListRequest",
                "vfindex": 52
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "MatchMakingKeyValuePair_t*",
                        "*ppchFilters"
                    ],
                    [
                        "uint32",
                        "nFilters"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "name": "RequestFavoritesServerList",
                "nargs": 4,
                "retval": "HServerListRequest",
                "vfindex": 53
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "MatchMakingKeyValuePair_t*",
                        "*ppchFilters"
                    ],
                    [
                        "uint32",
                        "nFilters"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "name": "RequestHistoryServerList",
                "nargs": 4,
                "retval": "HServerListRequest",
                "vfindex": 54
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "iApp"
                    ],
                    [
                        "MatchMakingKeyValuePair_t*",
                        "*ppchFilters"
                    ],
                    [
                        "uint32",
                        "nFilters"
                    ],
                    [
                        "ISteamMatchmakingServerListResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse",
                "name": "RequestSpectatorServerList",
                "nargs": 4,
                "retval": "HServerListRequest",
                "vfindex": 55
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hServerListRequest"
                    ]
                ],
                "argsstr": "HServerListRequest hServerListRequest",
                "comments": "Releases the asynchronous request object and cancels any pending query on it if there's a pending query in progress.\n RefreshComplete callback is not posted when request is released.",
                "name": "ReleaseRequest",
                "nargs": 1,
                "retval": "void",
                "vfindex": 56
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ],
                    [
                        "int",
                        "iServer"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest, int iServer",
                "comments": "Get details on a given server in the list, you can get the valid range of index\n values by calling GetServerCount().  You will also receive index values in \n ISteamMatchmakingServerListResponse::ServerResponded() callbacks",
                "name": "GetServerDetails",
                "nargs": 2,
                "retval": "gameserveritem_t *",
                "vfindex": 57
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest",
                "comments": "Cancel an request which is operation on the given list type.  You should call this to cancel\n any in-progress requests before destructing a callback object that may have been passed \n to one of the above list request calls.  Not doing so may result in a crash when a callback\n occurs on the destructed object.\n Canceling a query does not release the allocated request handle.\n The request handle must be released using ReleaseRequest( hRequest )",
                "name": "CancelQuery",
                "nargs": 1,
                "retval": "void",
                "vfindex": 58
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest",
                "comments": "Ping every server in your list again but don't update the list of servers\n Query callback installed when the server list was requested will be used\n again to post notifications and RefreshComplete, so the callback must remain\n valid until another RefreshComplete is called on it or the request\n is released with ReleaseRequest( hRequest )",
                "name": "RefreshQuery",
                "nargs": 1,
                "retval": "void",
                "vfindex": 59
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest",
                "comments": "Returns true if the list is currently refreshing its server list",
                "name": "IsRefreshing",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 60
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest",
                "comments": "How many servers in the given list, GetServerDetails above takes 0... GetServerCount() - 1",
                "name": "GetServerCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 61
            },
            {
                "args": [
                    [
                        "HServerListRequest",
                        "hRequest"
                    ],
                    [
                        "int",
                        "iServer"
                    ]
                ],
                "argsstr": "HServerListRequest hRequest, int iServer",
                "comments": "Refresh a single server inside of a query (rather than all the servers )",
                "name": "RefreshServer",
                "nargs": 2,
                "retval": "void",
                "vfindex": 62
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIP"
                    ],
                    [
                        "uint16",
                        "usPort"
                    ],
                    [
                        "ISteamMatchmakingPingResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingPingResponse *pRequestServersResponse",
                "comments": "-----------------------------------------------------------------------------\n Queries to individual servers directly via IP/Port\n-----------------------------------------------------------------------------\n\n Request updated ping time and other details from a single server",
                "name": "PingServer",
                "nargs": 3,
                "retval": "HServerQuery",
                "vfindex": 63
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIP"
                    ],
                    [
                        "uint16",
                        "usPort"
                    ],
                    [
                        "ISteamMatchmakingPlayersResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingPlayersResponse *pRequestServersResponse",
                "comments": "Request the list of players currently playing on a server",
                "name": "PlayerDetails",
                "nargs": 3,
                "retval": "HServerQuery",
                "vfindex": 64
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIP"
                    ],
                    [
                        "uint16",
                        "usPort"
                    ],
                    [
                        "ISteamMatchmakingRulesResponse*",
                        "pRequestServersResponse"
                    ]
                ],
                "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingRulesResponse *pRequestServersResponse",
                "comments": "Request the list of rules that the server is running (See ISteamGameServer::SetKeyValue() to set the rules server side)",
                "name": "ServerRules",
                "nargs": 3,
                "retval": "HServerQuery",
                "vfindex": 65
            },
            {
                "args": [
                    [
                        "HServerQuery",
                        "hServerQuery"
                    ]
                ],
                "argsstr": "HServerQuery hServerQuery",
                "comments": "Cancel an outstanding Ping/Players/Rules query from above.  You should call this to cancel\n any in-progress requests before destructing a callback object that may have been passed \n to one of the above calls to avoid crashing when callbacks occur.",
                "name": "CancelServerQuery",
                "nargs": 1,
                "retval": "void",
                "vfindex": 66
            }
        ]
    },
    "ISteamMusic": {
        "cppclass": "ISteamMusic",
        "cppinterface": "STEAMMUSIC_INTERFACE_VERSION",
        "cppinterfacev": "STEAMMUSIC_INTERFACE_VERSION001",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "name": "BIsEnabled",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsPlaying",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetPlaybackStatus",
                "nargs": 0,
                "retval": "AudioPlayback_Status",
                "vfindex": 2
            },
            {
                "args": [],
                "argsstr": "",
                "name": "Play",
                "nargs": 0,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [],
                "argsstr": "",
                "name": "Pause",
                "nargs": 0,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [],
                "argsstr": "",
                "name": "PlayPrevious",
                "nargs": 0,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [],
                "argsstr": "",
                "name": "PlayNext",
                "nargs": 0,
                "retval": "void",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "float",
                        "flVolume"
                    ]
                ],
                "argsstr": "float flVolume",
                "comments": "Volume is between 0.0 and 1.0",
                "name": "SetVolume",
                "nargs": 1,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetVolume",
                "nargs": 0,
                "retval": "float",
                "vfindex": 8
            }
        ]
    },
    "ISteamMusicRemote": {
        "cppclass": "ISteamMusicRemote",
        "cppinterface": "STEAMMUSICREMOTE_INTERFACE_VERSION",
        "cppinterfacev": "STEAMMUSICREMOTE_INTERFACE_VERSION001",
        "funcs": [
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "const char *pchName",
                "comments": "Service Definition",
                "name": "RegisterSteamMusicRemote",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "DeregisterSteamMusicRemote",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsCurrentMusicRemote",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "BActivationSuccess",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchDisplayName"
                    ]
                ],
                "argsstr": "const char *pchDisplayName",
                "name": "SetDisplayName",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "void*",
                        "pvBuffer"
                    ],
                    [
                        "uint32",
                        "cbBufferLength"
                    ]
                ],
                "argsstr": "void *pvBuffer, uint32 cbBufferLength",
                "name": "SetPNGIcon_64x64",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "comments": "Abilities for the user interface",
                "name": "EnablePlayPrevious",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "EnablePlayNext",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "EnableShuffled",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "EnableLooped",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "EnableQueue",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "EnablePlaylists",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "AudioPlayback_Status",
                        "nStatus"
                    ]
                ],
                "argsstr": "AudioPlayback_Status nStatus",
                "comments": "Status",
                "name": "UpdatePlaybackStatus",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "UpdateShuffled",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "bool",
                        "bValue"
                    ]
                ],
                "argsstr": "bool bValue",
                "name": "UpdateLooped",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "float",
                        "flValue"
                    ]
                ],
                "argsstr": "float flValue",
                "name": "UpdateVolume",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Volume is between 0.0 and 1.0\n\n Current Entry",
                "name": "CurrentEntryWillChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "bool",
                        "bAvailable"
                    ]
                ],
                "argsstr": "bool bAvailable",
                "name": "CurrentEntryIsAvailable",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchText"
                    ]
                ],
                "argsstr": "const char *pchText",
                "name": "UpdateCurrentEntryText",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "int",
                        "nValue"
                    ]
                ],
                "argsstr": "int nValue",
                "name": "UpdateCurrentEntryElapsedSeconds",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "void*",
                        "pvBuffer"
                    ],
                    [
                        "uint32",
                        "cbBufferLength"
                    ]
                ],
                "argsstr": "void *pvBuffer, uint32 cbBufferLength",
                "name": "UpdateCurrentEntryCoverArt",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [],
                "argsstr": "",
                "name": "CurrentEntryDidChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Queue",
                "name": "QueueWillChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [],
                "argsstr": "",
                "name": "ResetQueueEntries",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "int",
                        "nID"
                    ],
                    [
                        "int",
                        "nPosition"
                    ],
                    [
                        "constchar*",
                        "pchEntryText"
                    ]
                ],
                "argsstr": "int nID, int nPosition, const char *pchEntryText",
                "name": "SetQueueEntry",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "int",
                        "nID"
                    ]
                ],
                "argsstr": "int nID",
                "name": "SetCurrentQueueEntry",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 25
            },
            {
                "args": [],
                "argsstr": "",
                "name": "QueueDidChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Playlist",
                "name": "PlaylistWillChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [],
                "argsstr": "",
                "name": "ResetPlaylistEntries",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "int",
                        "nID"
                    ],
                    [
                        "int",
                        "nPosition"
                    ],
                    [
                        "constchar*",
                        "pchEntryText"
                    ]
                ],
                "argsstr": "int nID, int nPosition, const char *pchEntryText",
                "name": "SetPlaylistEntry",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "int",
                        "nID"
                    ]
                ],
                "argsstr": "int nID",
                "name": "SetCurrentPlaylistEntry",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 30
            },
            {
                "args": [],
                "argsstr": "",
                "name": "PlaylistDidChange",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 31
            }
        ]
    },
    "ISteamNetworking": {
        "cppclass": "ISteamNetworking",
        "cppinterface": "STEAMNETWORKING_INTERFACE_VERSION",
        "cppinterfacev": "SteamNetworking005",
        "funcs": [
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDRemote"
                    ],
                    [
                        "constvoid*",
                        "pubData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ],
                    [
                        "EP2PSend",
                        "eP2PSendType"
                    ],
                    [
                        "intnChannel=",
                        "0"
                    ]
                ],
                "argsstr": "CSteamID steamIDRemote, const void *pubData, uint32 cubData, EP2PSend eP2PSendType, int nChannel = 0",
                "comments": "Session-less connection functions\n    automatically establishes NAT-traversing or Relay server connections\n\n Sends a P2P packet to the specified user\n UDP-like, unreliable and a max packet size of 1200 bytes\n the first packet send may be delayed as the NAT-traversal code runs\n if we can't get through to the user, an error will be posted via the callback P2PSessionConnectFail_t\n see EP2PSend enum above for the descriptions of the different ways of sending packets\n\n nChannel is a routing number you can use to help route message to different systems - you'll have to call ReadP2PPacket() \n with the same channel number in order to retrieve the data on the other end\n using different channels to talk to the same user will still use the same underlying p2p connection, saving on resources",
                "name": "SendP2PPacket",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ],
                    [
                        "intnChannel=",
                        "0"
                    ]
                ],
                "argsstr": "uint32 *pcubMsgSize, int nChannel = 0",
                "comments": "Returns true if any data is available for read, and the amount of data that will need to be read",
                "name": "IsP2PPacketAvailable",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "void*",
                        "pubDest"
                    ],
                    [
                        "uint32",
                        "cubDest"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ],
                    [
                        "CSteamID*",
                        "psteamIDRemote"
                    ],
                    [
                        "intnChannel=",
                        "0"
                    ]
                ],
                "argsstr": "void *pubDest, uint32 cubDest, uint32 *pcubMsgSize, CSteamID *psteamIDRemote, int nChannel = 0",
                "comments": "Reads in a packet that has been sent from another user via SendP2PPacket()\n returns the size of the message and the steamID of the user who sent it in the last two parameters\n if the buffer passed in is too small, the message will be truncated\n this call is not blocking, and will return false if no data is available",
                "name": "ReadP2PPacket",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDRemote"
                    ]
                ],
                "argsstr": "CSteamID steamIDRemote",
                "comments": "AcceptP2PSessionWithUser() should only be called in response to a P2PSessionRequest_t callback\n P2PSessionRequest_t will be posted if another user tries to send you a packet that you haven't talked to yet\n if you don't want to talk to the user, just ignore the request\n if the user continues to send you packets, another P2PSessionRequest_t will be posted periodically\n this may be called multiple times for a single user\n (if you've called SendP2PPacket() on the other user, this implicitly accepts the session request)",
                "name": "AcceptP2PSessionWithUser",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDRemote"
                    ]
                ],
                "argsstr": "CSteamID steamIDRemote",
                "comments": "Call CloseP2PSessionWithUser() when you're done talking to a user, will free up resources under-the-hood\n if the remote user tries to send data to you again, another P2PSessionRequest_t callback will be posted",
                "name": "CloseP2PSessionWithUser",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDRemote"
                    ],
                    [
                        "int",
                        "nChannel"
                    ]
                ],
                "argsstr": "CSteamID steamIDRemote, int nChannel",
                "comments": "Call CloseP2PChannelWithUser() when you're done talking to a user on a specific channel. Once all channels\n open channels to a user have been closed, the open session to the user will be closed and new data from this\n user will trigger a P2PSessionRequest_t callback",
                "name": "CloseP2PChannelWithUser",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDRemote"
                    ],
                    [
                        "P2PSessionState_t*",
                        "pConnectionState"
                    ]
                ],
                "argsstr": "CSteamID steamIDRemote, P2PSessionState_t *pConnectionState",
                "comments": "Fills out P2PSessionState_t structure with details about the underlying connection to the user\n should only needed for debugging purposes\n returns false if no connection exists to the specified user",
                "name": "GetP2PSessionState",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "bool",
                        "bAllow"
                    ]
                ],
                "argsstr": "bool bAllow",
                "comments": "Allow P2P connections to fall back to being relayed through the Steam servers if a direct connection\n or NAT-traversal cannot be established. Only applies to connections created after setting this value,\n or to existing connections that need to automatically reconnect after this value is set.\n\n P2P packet relay is allowed by default",
                "name": "AllowP2PPacketRelay",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "int",
                        "nVirtualP2PPort"
                    ],
                    [
                        "uint32",
                        "nIP"
                    ],
                    [
                        "uint16",
                        "nPort"
                    ],
                    [
                        "bool",
                        "bAllowUseOfPacketRelay"
                    ]
                ],
                "argsstr": "int nVirtualP2PPort, uint32 nIP, uint16 nPort, bool bAllowUseOfPacketRelay",
                "comments": "LISTEN / CONNECT style interface functions\n\n This is an older set of functions designed around the Berkeley TCP sockets model\n it's preferential that you use the above P2P functions, they're more robust\n and these older functions will be removed eventually\n\n\n\n\n creates a socket and listens others to connect\n will trigger a SocketStatusCallback_t callback on another client connecting\n nVirtualP2PPort is the unique ID that the client will connect to, in case you have multiple ports\nthis can usually just be 0 unless you want multiple sets of connections\n unIP is the local IP address to bind to\npass in 0 if you just want the default local IP\n unPort is the port to use\npass in 0 if you don't want users to be able to connect via IP/Port, but expect to be always peer-to-peer connections only",
                "name": "CreateListenSocket",
                "nargs": 4,
                "retval": "SNetListenSocket_t",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDTarget"
                    ],
                    [
                        "int",
                        "nVirtualPort"
                    ],
                    [
                        "int",
                        "nTimeoutSec"
                    ],
                    [
                        "bool",
                        "bAllowUseOfPacketRelay"
                    ]
                ],
                "argsstr": "CSteamID steamIDTarget, int nVirtualPort, int nTimeoutSec, bool bAllowUseOfPacketRelay",
                "comments": "Creates a socket and begin connection to a remote destination\n can connect via a known steamID (client or game server), or directly to an IP\n on success will trigger a SocketStatusCallback_t callback\n on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in m_eSNetSocketState",
                "name": "CreateP2PConnectionSocket",
                "nargs": 4,
                "retval": "SNetSocket_t",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "uint32",
                        "nIP"
                    ],
                    [
                        "uint16",
                        "nPort"
                    ],
                    [
                        "int",
                        "nTimeoutSec"
                    ]
                ],
                "argsstr": "uint32 nIP, uint16 nPort, int nTimeoutSec",
                "name": "CreateConnectionSocket",
                "nargs": 3,
                "retval": "SNetSocket_t",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ],
                    [
                        "bool",
                        "bNotifyRemoteEnd"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket, bool bNotifyRemoteEnd",
                "comments": "Disconnects the connection to the socket, if any, and invalidates the handle\n any unread data on the socket will be thrown away\n if bNotifyRemoteEnd is set, socket will not be completely destroyed until the remote end acknowledges the disconnect",
                "name": "DestroySocket",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "SNetListenSocket_t",
                        "hSocket"
                    ],
                    [
                        "bool",
                        "bNotifyRemoteEnd"
                    ]
                ],
                "argsstr": "SNetListenSocket_t hSocket, bool bNotifyRemoteEnd",
                "comments": "Destroying a listen socket will automatically kill all the regular sockets generated from it",
                "name": "DestroyListenSocket",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ],
                    [
                        "void*",
                        "pubData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ],
                    [
                        "bool",
                        "bReliable"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket, void *pubData, uint32 cubData, bool bReliable",
                "comments": "Sending data\n must be a handle to a connected socket\n data is all sent via UDP, and thus send sizes are limited to 1200 bytes; after this, many routers will start dropping packets\n use the reliable flag with caution; although the resend rate is pretty aggressive,\n it can still cause stalls in receiving data (like TCP)",
                "name": "SendDataOnSocket",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket, uint32 *pcubMsgSize",
                "comments": "Receiving data\n returns false if there is no data remaining\n fills out *pcubMsgSize with the size of the next message, in bytes",
                "name": "IsDataAvailableOnSocket",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ],
                    [
                        "void*",
                        "pubDest"
                    ],
                    [
                        "uint32",
                        "cubDest"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize",
                "comments": "Fills in pubDest with the contents of the message\n messages are always complete, of the same size as was sent (i.e. packetized, not streaming)\n if *pcubMsgSize < cubDest, only partial data is written\n returns false if no data is available",
                "name": "RetrieveDataFromSocket",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "SNetListenSocket_t",
                        "hListenSocket"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ],
                    [
                        "SNetSocket_t*",
                        "phSocket"
                    ]
                ],
                "argsstr": "SNetListenSocket_t hListenSocket, uint32 *pcubMsgSize, SNetSocket_t *phSocket",
                "comments": "Checks for data from any socket that has been connected off this listen socket\n returns false if there is no data remaining\n fills out *pcubMsgSize with the size of the next message, in bytes\n fills out *phSocket with the socket that data is available on",
                "name": "IsDataAvailable",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "SNetListenSocket_t",
                        "hListenSocket"
                    ],
                    [
                        "void*",
                        "pubDest"
                    ],
                    [
                        "uint32",
                        "cubDest"
                    ],
                    [
                        "uint32*",
                        "pcubMsgSize"
                    ],
                    [
                        "SNetSocket_t*",
                        "phSocket"
                    ]
                ],
                "argsstr": "SNetListenSocket_t hListenSocket, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize, SNetSocket_t *phSocket",
                "comments": "Retrieves data from any socket that has been connected off this listen socket\n fills in pubDest with the contents of the message\n messages are always complete, of the same size as was sent (i.e. packetized, not streaming)\n if *pcubMsgSize < cubDest, only partial data is written\n returns false if no data is available\n fills out *phSocket with the socket that data is available on",
                "name": "RetrieveData",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ],
                    [
                        "CSteamID*",
                        "pSteamIDRemote"
                    ],
                    [
                        "int*",
                        "peSocketStatus"
                    ],
                    [
                        "uint32*",
                        "punIPRemote"
                    ],
                    [
                        "uint16*",
                        "punPortRemote"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket, CSteamID *pSteamIDRemote, int *peSocketStatus, uint32 *punIPRemote, uint16 *punPortRemote",
                "comments": "Returns information about the specified socket, filling out the contents of the pointers",
                "name": "GetSocketInfo",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "SNetListenSocket_t",
                        "hListenSocket"
                    ],
                    [
                        "uint32*",
                        "pnIP"
                    ],
                    [
                        "uint16*",
                        "pnPort"
                    ]
                ],
                "argsstr": "SNetListenSocket_t hListenSocket, uint32 *pnIP, uint16 *pnPort",
                "comments": "Returns which local port the listen socket is bound to\n *pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only",
                "name": "GetListenSocketInfo",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket",
                "comments": "Returns true to describe how the socket ended up connecting",
                "name": "GetSocketConnectionType",
                "nargs": 1,
                "retval": "ESNetSocketConnectionType",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "SNetSocket_t",
                        "hSocket"
                    ]
                ],
                "argsstr": "SNetSocket_t hSocket",
                "comments": "Max packet size, in bytes",
                "name": "GetMaxPacketSize",
                "nargs": 1,
                "retval": "int",
                "vfindex": 21
            }
        ]
    },
    "ISteamPS3OverlayRenderHost": {
        "cppclass": "ISteamPS3OverlayRenderHost",
        "cppinterface": null,
        "cppinterfacev": null,
        "funcs": [
            {
                "args": [
                    [
                        "int",
                        "x0"
                    ],
                    [
                        "int",
                        "y0"
                    ],
                    [
                        "int",
                        "x1"
                    ],
                    [
                        "int",
                        "y1"
                    ],
                    [
                        "float",
                        "u0"
                    ],
                    [
                        "float",
                        "v0"
                    ],
                    [
                        "float",
                        "u1"
                    ],
                    [
                        "float",
                        "v1"
                    ],
                    [
                        "int32",
                        "iTextureID"
                    ],
                    [
                        "DWORD",
                        "colorStart"
                    ],
                    [
                        "DWORD",
                        "colorEnd"
                    ],
                    [
                        "EOverlayGradientDirection",
                        "eDirection"
                    ]
                ],
                "argsstr": "int x0, int y0, int x1, int y1, float u0, float v0, float u1, float v1, int32 iTextureID, DWORD colorStart, DWORD colorEnd, EOverlayGradientDirection eDirection",
                "comments": "Interface for game engine to implement which Steam requires to render.\n\n Draw a textured rect.  This may use only part of the texture and will pass texture coords, it will also possibly request a gradient and will specify colors for vertexes.",
                "name": "DrawTexturedRect",
                "nargs": 12,
                "retval": "void",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "int32",
                        "iTextureID"
                    ],
                    [
                        "bool",
                        "bIsFullTexture"
                    ],
                    [
                        "int",
                        "x0"
                    ],
                    [
                        "int",
                        "y0"
                    ],
                    [
                        "uint32",
                        "uWidth"
                    ],
                    [
                        "uint32",
                        "uHeight"
                    ],
                    [
                        "int32",
                        "iBytes"
                    ],
                    [
                        "char*",
                        "pData"
                    ]
                ],
                "argsstr": "int32 iTextureID, bool bIsFullTexture, int x0, int y0, uint32 uWidth, uint32 uHeight, int32 iBytes, char *pData",
                "comments": "Load a RGBA texture for Steam, or update a previously loaded one.  Updates may be partial.  You must not evict or remove this texture once Steam has uploaded it.",
                "name": "LoadOrUpdateTexture",
                "nargs": 8,
                "retval": "void",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "int32",
                        "iTextureID"
                    ]
                ],
                "argsstr": "int32 iTextureID",
                "comments": "Delete a texture Steam previously uploaded",
                "name": "DeleteTexture",
                "nargs": 1,
                "retval": "void",
                "vfindex": 2
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Delete all previously uploaded textures",
                "name": "DeleteAllTextures",
                "nargs": 0,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "uint32",
                        "unScreenWidth"
                    ],
                    [
                        "uint32",
                        "unScreenHeight"
                    ],
                    [
                        "uint32",
                        "unRefreshRate"
                    ],
                    [
                        "ISteamPS3OverlayRenderHost*",
                        "pRenderHost"
                    ],
                    [
                        "void*",
                        "CellFontLib"
                    ]
                ],
                "argsstr": "uint32 unScreenWidth, uint32 unScreenHeight, uint32 unRefreshRate, ISteamPS3OverlayRenderHost *pRenderHost, void *CellFontLib",
                "comments": "-----------------------------------------------------------------------------\n Purpose: Interface Steam exposes for the game to tell it when to render, etc.\n-----------------------------------------------------------------------------\nclass ISteamPS3OverlayRender\n{\npublic:\n\n Call once at startup to initialize the Steam overlay and pass it your host interface ptr",
                "name": "BHostInitialize",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Call this once a frame when you are ready for the Steam overlay to render (ie, right before flipping buffers, after all your rendering)",
                "name": "Render",
                "nargs": 0,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "constCellPadData",
                        "&padData"
                    ]
                ],
                "argsstr": "const CellPadData &padData",
                "comments": "Call this everytime you read input on PS3.\n \n If this returns true, then the overlay is active and has consumed the input, your game\n should then ignore all the input until BHandleCellPadData once again returns false, which\n will mean the overlay is deactivated.",
                "name": "BHandleCellPadData",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Call this if you detect no controllers connected or that the XMB is intercepting input\n \n This is important to clear input state for the overlay, so keys left down during XMB activation\n are not continued to be processed.",
                "name": "BResetInputState",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 7
            }
        ]
    },
    "ISteamParentalSettings": {
        "cppclass": "ISteamParentalSettings",
        "cppinterface": "STEAMPARENTALSETTINGS_INTERFACE_VERSION",
        "cppinterfacev": "STEAMPARENTALSETTINGS_INTERFACE_VERSION001",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "name": "BIsParentalLockEnabled",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "BIsParentalLockLocked",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "name": "BIsAppBlocked",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "AppId_t nAppID",
                "name": "BIsAppInBlockList",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "EParentalFeature",
                        "eFeature"
                    ]
                ],
                "argsstr": "EParentalFeature eFeature",
                "name": "BIsFeatureBlocked",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "EParentalFeature",
                        "eFeature"
                    ]
                ],
                "argsstr": "EParentalFeature eFeature",
                "name": "BIsFeatureInBlockList",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 5
            }
        ]
    },
    "ISteamRemoteStorage": {
        "cppclass": "ISteamRemoteStorage",
        "cppinterface": "STEAMREMOTESTORAGE_INTERFACE_VERSION",
        "cppinterfacev": "STEAMREMOTESTORAGE_INTERFACE_VERSION014",
        "funcs": [
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ],
                    [
                        "constvoid*",
                        "pvData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ]
                ],
                "argsstr": "const char *pchFile, const void *pvData, uint32 cubData",
                "comments": "NOTE\n\n Filenames are case-insensitive, and will be converted to lowercase automatically.\n So \"foo.bar\" and \"Foo.bar\" are the same file, and if you write \"Foo.bar\" then\n iterate the files, the filename returned will be \"foo.bar\".\n\n\n file operations\nvirtual boolFileWrite( const char *pchFile, const void *pvData, int32 cubData ) = 0;\nvirtual int32FileRead( const char *pchFile, void *pvData, int32 cubDataToRead ) = 0;\n\nCALL_RESULT( RemoteStorageFileWriteAsyncComplete_t )",
                "name": "FileWriteAsync",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ],
                    [
                        "uint32",
                        "nOffset"
                    ],
                    [
                        "uint32",
                        "cubToRead"
                    ]
                ],
                "argsstr": "const char *pchFile, uint32 nOffset, uint32 cubToRead",
                "name": "FileReadAsync",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "const char *pchFile",
                "name": "FileShare",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "const char *pchFile",
                "comments": "File operations that cause network IO",
                "name": "FileWriteStreamOpen",
                "nargs": 1,
                "retval": "UGCFileWriteStreamHandle_t",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "UGCFileWriteStreamHandle_t",
                        "writeHandle"
                    ],
                    [
                        "constvoid*",
                        "pvData"
                    ],
                    [
                        "int32",
                        "cubData"
                    ]
                ],
                "argsstr": "UGCFileWriteStreamHandle_t writeHandle, const void *pvData, int32 cubData",
                "name": "FileWriteStreamWriteChunk",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "UGCFileWriteStreamHandle_t",
                        "writeHandle"
                    ]
                ],
                "argsstr": "UGCFileWriteStreamHandle_t writeHandle",
                "name": "FileWriteStreamClose",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "UGCFileWriteStreamHandle_t",
                        "writeHandle"
                    ]
                ],
                "argsstr": "UGCFileWriteStreamHandle_t writeHandle",
                "name": "FileWriteStreamCancel",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "const char *pchFile",
                "comments": "File information\nvirtual boolFileExists( const char *pchFile ) = 0;\nvirtual boolFilePersisted( const char *pchFile ) = 0;\nvirtual int32GetFileSize( const char *pchFile ) = 0;\nvirtual int64GetFileTimestamp( const char *pchFile ) = 0;",
                "name": "GetSyncPlatforms",
                "nargs": 1,
                "retval": "ERemoteStoragePlatform",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Iteration",
                "name": "GetFileCount",
                "nargs": 0,
                "retval": "int32",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "int",
                        "iFile"
                    ],
                    [
                        "int32*",
                        "pnFileSizeInBytes"
                    ]
                ],
                "argsstr": "int iFile, int32 *pnFileSizeInBytes",
                "name": "GetFileNameAndSize",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "uint64*",
                        "pnTotalBytes"
                    ],
                    [
                        "uint64*",
                        "puAvailableBytes"
                    ]
                ],
                "argsstr": "uint64 *pnTotalBytes, uint64 *puAvailableBytes",
                "comments": "Configuration management",
                "name": "GetQuota",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [],
                "argsstr": "",
                "name": "IsCloudEnabledForAccount",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [],
                "argsstr": "",
                "name": "IsCloudEnabledForApp",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "bool",
                        "bEnabled"
                    ]
                ],
                "argsstr": "bool bEnabled",
                "name": "SetCloudEnabledForApp",
                "nargs": 1,
                "retval": "void",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "UGCHandle_t",
                        "hContent"
                    ],
                    [
                        "uint32",
                        "unPriority"
                    ]
                ],
                "argsstr": "UGCHandle_t hContent, uint32 unPriority",
                "comments": "User generated content\n\n Downloads a UGC file.  A priority value of 0 will download the file immediately,\n otherwise it will wait to download the file until all downloads with a lower priority\n value are completed.  Downloads with equal priority will occur simultaneously.\nCALL_RESULT( RemoteStorageDownloadUGCResult_t )",
                "name": "UGCDownload",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 14
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets the amount of data downloaded so far for a piece of content. pnBytesExpected can be 0 if function returns false\n or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage\nvirtual boolGetUGCDownloadProgress( UGCHandle_t hContent, int32 *pnBytesDownloaded, int32 *pnBytesExpected ) = 0;\n\n Gets metadata for a file after it has been downloaded. This is the same metadata given in the RemoteStorageDownloadUGCResult_t call result\nvirtual boolGetUGCDetails( UGCHandle_t hContent, AppId_t *pnAppID,  char **ppchName, int32 *pnFileSizeInBytes,  CSteamID *pSteamIDOwner ) = 0;\n\n After download, gets the content of the file.  \n Small files can be read all at once by calling this function with an offset of 0 and cubDataToRead equal to the size of the file.\n Larger files can be read in chunks to reduce memory usage (since both sides of the IPC client and the game itself must allocate\n enough memory for each chunk).  Once the last byte is read, the file is implicitly closed and further calls to UGCRead will fail\n unless UGCDownload is called again.\n For especially large files (anything over 100MB) it is a requirement that the file is read in chunks.\nvirtual int32UGCRead( UGCHandle_t hContent, void *pvData, int32 cubDataToRead, uint32 cOffset, EUGCReadAction eAction ) = 0;\n\n Functions to iterate through UGC that has finished downloading but has not yet been read via UGCRead()\nvirtual int32GetCachedUGCCount() = 0;\nvirtualUGCHandle_t GetCachedUGCHandle( int32 iCachedContent ) = 0;\n\n The following functions are only necessary on the Playstation 3. On PC & Mac, the Steam client will handle these operations for you\n On Playstation 3, the game controls which files are stored in the cloud, via FilePersist, FileFetch, and FileForget.\n\n#if defined(_PS3) || defined(_SERVER)\n Connect to Steam and get a list of files in the Cloud - results in a RemoteStorageAppSyncStatusCheck_t callback",
                "name": "GetFileListFromServer",
                "nargs": 0,
                "retval": "void",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "const char *pchFile",
                "comments": "Indicate this file should be downloaded in the next sync",
                "name": "FileFetch",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "const char *pchFile",
                "comments": "Indicate this file should be persisted in the next sync",
                "name": "FilePersist",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Pull any requested files down from the Cloud - results in a RemoteStorageAppSyncedClient_t callback",
                "name": "SynchronizeToClient",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Upload any requested files to the Cloud - results in a RemoteStorageAppSyncedServer_t callback",
                "name": "SynchronizeToServer",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Reset any fetch/persist/etc requests",
                "name": "ResetFileRequestState",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "unPublishedFileId"
                    ]
                ],
                "argsstr": "PublishedFileId_t unPublishedFileId",
                "comments": "Publishing UGC\nCALL_RESULT( RemoteStoragePublishFileProgress_t )\nvirtual SteamAPICall_tPublishWorkshopFile( const char *pchFile, const char *pchPreviewFile, AppId_t nConsumerAppId, const char *pchTitle, const char *pchDescription, ERemoteStoragePublishedFileVisibility eVisibility, SteamParamStringArray_t *pTags, EWorkshopFileType eWorkshopFileType ) = 0;",
                "name": "CreatePublishedFileUpdateRequest",
                "nargs": 1,
                "retval": "PublishedFileUpdateHandle_t",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constchar*",
                        "pchFile"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchFile",
                "name": "UpdatePublishedFileFile",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constchar*",
                        "pchPreviewFile"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchPreviewFile",
                "name": "UpdatePublishedFilePreviewFile",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constchar*",
                        "pchTitle"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchTitle",
                "name": "UpdatePublishedFileTitle",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constchar*",
                        "pchDescription"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchDescription",
                "name": "UpdatePublishedFileDescription",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "ERemoteStoragePublishedFileVisibility",
                        "eVisibility"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, ERemoteStoragePublishedFileVisibility eVisibility",
                "name": "UpdatePublishedFileVisibility",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "SteamParamStringArray_t*",
                        "pTags"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, SteamParamStringArray_t *pTags",
                "name": "UpdatePublishedFileTags",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "PublishedFileUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constchar*",
                        "pchChangeDescription"
                    ]
                ],
                "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchChangeDescription",
                "comments": "Gets published file details for the given publishedfileid.  If unMaxSecondsOld is greater than 0,\n cached data may be returned, depending on how long ago it was cached.  A value of 0 will force a refresh.\n A value of k_WorkshopForceLoadPublishedFileDetailsFromCache will use cached data if it exists, no matter how old it is.\nCALL_RESULT( RemoteStorageGetPublishedFileDetailsResult_t )\nvirtual SteamAPICall_tGetPublishedFileDetails( PublishedFileId_t unPublishedFileId, uint32 unMaxSecondsOld ) = 0;\nCALL_RESULT( RemoteStorageDeletePublishedFileResult_t )\nvirtual SteamAPICall_tDeletePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;\n enumerate the files that the current user published with this app\nCALL_RESULT( RemoteStorageEnumerateUserPublishedFilesResult_t )\nvirtual SteamAPICall_tEnumerateUserPublishedFiles( uint32 unStartIndex ) = 0;\nCALL_RESULT( RemoteStorageSubscribePublishedFileResult_t )\nvirtual SteamAPICall_tSubscribePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;\nCALL_RESULT( RemoteStorageEnumerateUserSubscribedFilesResult_t )\nvirtual SteamAPICall_tEnumerateUserSubscribedFiles( uint32 unStartIndex ) = 0;\nCALL_RESULT( RemoteStorageUnsubscribePublishedFileResult_t )\nvirtual SteamAPICall_tUnsubscribePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;",
                "name": "UpdatePublishedFileSetChangeDescription",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "UGCHandle_t",
                        "hContent"
                    ],
                    [
                        "constchar*",
                        "pchLocation"
                    ],
                    [
                        "uint32",
                        "unPriority"
                    ]
                ],
                "argsstr": "UGCHandle_t hContent, const char *pchLocation, uint32 unPriority",
                "comments": "This method enumerates the public view of workshop files\nCALL_RESULT( RemoteStorageEnumerateWorkshopFilesResult_t )\nvirtual SteamAPICall_tEnumeratePublishedWorkshopFiles( EWorkshopEnumerationType eEnumerationType, uint32 unStartIndex, uint32 unCount, uint32 unDays, SteamParamStringArray_t *pTags, SteamParamStringArray_t *pUserTags ) = 0;\n\nCALL_RESULT( RemoteStorageDownloadUGCResult_t )",
                "name": "UGCDownloadToLocation",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 29
            }
        ]
    },
    "ISteamScreenshots": {
        "cppclass": "ISteamScreenshots",
        "cppinterface": "STEAMSCREENSHOTS_INTERFACE_VERSION",
        "cppinterfacev": "STEAMSCREENSHOTS_INTERFACE_VERSION003",
        "funcs": [
            {
                "args": [
                    [
                        "void*",
                        "pubRGB"
                    ],
                    [
                        "uint32",
                        "cubRGB"
                    ],
                    [
                        "int",
                        "nWidth"
                    ],
                    [
                        "int",
                        "nHeight"
                    ]
                ],
                "argsstr": "void *pubRGB, uint32 cubRGB, int nWidth, int nHeight",
                "comments": "Writes a screenshot to the user's screenshot library given the raw image data, which must be in RGB format.\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.",
                "name": "WriteScreenshot",
                "nargs": 4,
                "retval": "ScreenshotHandle",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchFilename"
                    ],
                    [
                        "constchar*",
                        "pchThumbnailFilename"
                    ],
                    [
                        "int",
                        "nWidth"
                    ],
                    [
                        "int",
                        "nHeight"
                    ]
                ],
                "argsstr": "const char *pchFilename, const char *pchThumbnailFilename, int nWidth, int nHeight",
                "comments": "Adds a screenshot to the user's screenshot library from disk.  If a thumbnail is provided, it must be 200 pixels wide and the same aspect ratio\n as the screenshot, otherwise a thumbnail will be generated if the user uploads the screenshot.  The screenshots must be in either JPEG or TGA format.\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.\n JPEG, TGA, and PNG formats are supported.",
                "name": "AddScreenshotToLibrary",
                "nargs": 4,
                "retval": "ScreenshotHandle",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Causes the Steam overlay to take a screenshot.  If screenshots are being hooked by the game then a ScreenshotRequested_t callback is sent back to the game instead.",
                "name": "TriggerScreenshot",
                "nargs": 0,
                "retval": "void",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "bool",
                        "bHook"
                    ]
                ],
                "argsstr": "bool bHook",
                "comments": "Toggles whether the overlay handles screenshots when the user presses the screenshot hotkey, or the game handles them.  If the game is hooking screenshots,\n then the ScreenshotRequested_t callback will be sent if the user presses the hotkey, and the game is expected to call WriteScreenshot or AddScreenshotToLibrary\n in response.",
                "name": "HookScreenshots",
                "nargs": 1,
                "retval": "void",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "ScreenshotHandle",
                        "hScreenshot"
                    ],
                    [
                        "constchar*",
                        "pchLocation"
                    ]
                ],
                "argsstr": "ScreenshotHandle hScreenshot, const char *pchLocation",
                "comments": "Sets metadata about a screenshot's location (for example, the name of the map)",
                "name": "SetLocation",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "ScreenshotHandle",
                        "hScreenshot"
                    ],
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "ScreenshotHandle hScreenshot, CSteamID steamID",
                "comments": "Tags a user as being visible in the screenshot",
                "name": "TagUser",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "ScreenshotHandle",
                        "hScreenshot"
                    ],
                    [
                        "PublishedFileId_t",
                        "unPublishedFileID"
                    ]
                ],
                "argsstr": "ScreenshotHandle hScreenshot, PublishedFileId_t unPublishedFileID",
                "comments": "Tags a published file as being visible in the screenshot",
                "name": "TagPublishedFile",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if the app has hooked the screenshot",
                "name": "IsScreenshotsHooked",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "EVRScreenshotType",
                        "eType"
                    ],
                    [
                        "constchar*",
                        "pchFilename"
                    ],
                    [
                        "constchar*",
                        "pchVRFilename"
                    ]
                ],
                "argsstr": "EVRScreenshotType eType, const char *pchFilename, const char *pchVRFilename",
                "comments": "Adds a VR screenshot to the user's screenshot library from disk in the supported type.\n pchFilename should be the normal 2D image used in the library view\n pchVRFilename should contain the image that matches the correct type\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.\n JPEG, TGA, and PNG formats are supported.",
                "name": "AddVRScreenshotToLibrary",
                "nargs": 3,
                "retval": "ScreenshotHandle",
                "vfindex": 8
            }
        ]
    },
    "ISteamUGC": {
        "cppclass": "ISteamUGC",
        "cppinterface": "STEAMUGC_INTERFACE_VERSION",
        "cppinterfacev": "STEAMUGC_INTERFACE_VERSION010",
        "funcs": [
            {
                "args": [
                    [
                        "AccountID_t",
                        "unAccountID"
                    ],
                    [
                        "EUserUGCList",
                        "eListType"
                    ],
                    [
                        "EUGCMatchingUGCType",
                        "eMatchingUGCType"
                    ],
                    [
                        "EUserUGCListSortOrder",
                        "eSortOrder"
                    ],
                    [
                        "AppId_t",
                        "nCreatorAppID"
                    ],
                    [
                        "AppId_t",
                        "nConsumerAppID"
                    ],
                    [
                        "uint32",
                        "unPage"
                    ]
                ],
                "argsstr": "AccountID_t unAccountID, EUserUGCList eListType, EUGCMatchingUGCType eMatchingUGCType, EUserUGCListSortOrder eSortOrder, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage",
                "comments": "Query UGC associated with a user. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.",
                "name": "CreateQueryUserUGCRequest",
                "nargs": 7,
                "retval": "UGCQueryHandle_t",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "EUGCQuery",
                        "eQueryType"
                    ],
                    [
                        "EUGCMatchingUGCType",
                        "eMatchingeMatchingUGCTypeFileType"
                    ],
                    [
                        "AppId_t",
                        "nCreatorAppID"
                    ],
                    [
                        "AppId_t",
                        "nConsumerAppID"
                    ],
                    [
                        "uint32",
                        "unPage"
                    ]
                ],
                "argsstr": "EUGCQuery eQueryType, EUGCMatchingUGCType eMatchingeMatchingUGCTypeFileType, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage",
                "comments": "Query for all matching UGC. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.",
                "name": "CreateQueryAllUGCRequest",
                "nargs": 5,
                "retval": "UGCQueryHandle_t",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "PublishedFileId_t*",
                        "pvecPublishedFileID"
                    ],
                    [
                        "uint32",
                        "unNumPublishedFileIDs"
                    ]
                ],
                "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs",
                "comments": "Query for the details of the given published file ids (the RequestUGCDetails call is deprecated and replaced with this)",
                "name": "CreateQueryUGCDetailsRequest",
                "nargs": 2,
                "retval": "UGCQueryHandle_t",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle",
                "comments": "Send the query to Steam\nCALL_RESULT( SteamUGCQueryCompleted_t )",
                "name": "SendQueryUGCRequest",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "SteamUGCDetails_t*",
                        "pDetails"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index, SteamUGCDetails_t *pDetails",
                "comments": "Retrieve an individual result after receiving the callback for querying UGC",
                "name": "GetQueryUGCResult",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "char*",
                        "pchURL"
                    ],
                    [
                        "uint32",
                        "cchURLSize"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index,  char *pchURL, uint32 cchURLSize",
                "name": "GetQueryUGCPreviewURL",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "char*",
                        "pchMetadata"
                    ],
                    [
                        "uint32",
                        "cchMetadatasize"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index,  char *pchMetadata, uint32 cchMetadatasize",
                "name": "GetQueryUGCMetadata",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "PublishedFileId_t*",
                        "pvecPublishedFileID"
                    ],
                    [
                        "uint32",
                        "cMaxEntries"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index, PublishedFileId_t* pvecPublishedFileID, uint32 cMaxEntries",
                "name": "GetQueryUGCChildren",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "EItemStatistic",
                        "eStatType"
                    ],
                    [
                        "uint64*",
                        "pStatValue"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index, EItemStatistic eStatType, uint64 *pStatValue",
                "name": "GetQueryUGCStatistic",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index",
                "name": "GetQueryUGCNumAdditionalPreviews",
                "nargs": 2,
                "retval": "uint32",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "uint32",
                        "previewIndex"
                    ],
                    [
                        "char*",
                        "pchURLOrVideoID"
                    ],
                    [
                        "uint32",
                        "cchURLSize"
                    ],
                    [
                        "char*",
                        "pchOriginalFileName"
                    ],
                    [
                        "uint32",
                        "cchOriginalFileNameSize"
                    ],
                    [
                        "EItemPreviewType*",
                        "pPreviewType"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index, uint32 previewIndex,  char *pchURLOrVideoID, uint32 cchURLSize,  char *pchOriginalFileName, uint32 cchOriginalFileNameSize, EItemPreviewType *pPreviewType",
                "name": "GetQueryUGCAdditionalPreview",
                "nargs": 8,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index",
                "name": "GetQueryUGCNumKeyValueTags",
                "nargs": 2,
                "retval": "uint32",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "uint32",
                        "keyValueTagIndex"
                    ],
                    [
                        "char*",
                        "pchKey"
                    ],
                    [
                        "uint32",
                        "cchKeySize"
                    ],
                    [
                        "char*",
                        "pchValue"
                    ],
                    [
                        "uint32",
                        "cchValueSize"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 index, uint32 keyValueTagIndex,  char *pchKey, uint32 cchKeySize,  char *pchValue, uint32 cchValueSize",
                "name": "GetQueryUGCKeyValueTag",
                "nargs": 7,
                "retval": "bool",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle",
                "comments": "Release the request to free up memory, after retrieving results",
                "name": "ReleaseQueryUGCRequest",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pTagName"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pTagName",
                "comments": "Options to set for querying UGC",
                "name": "AddRequiredTag",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pTagName"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pTagName",
                "name": "AddExcludedTag",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnOnlyIDs"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnOnlyIDs",
                "name": "SetReturnOnlyIDs",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnKeyValueTags"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnKeyValueTags",
                "name": "SetReturnKeyValueTags",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnLongDescription"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnLongDescription",
                "name": "SetReturnLongDescription",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnMetadata"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnMetadata",
                "name": "SetReturnMetadata",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnChildren"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnChildren",
                "name": "SetReturnChildren",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnAdditionalPreviews"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnAdditionalPreviews",
                "name": "SetReturnAdditionalPreviews",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bReturnTotalOnly"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bReturnTotalOnly",
                "name": "SetReturnTotalOnly",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "unDays"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 unDays",
                "name": "SetReturnPlaytimeStats",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchLanguage"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pchLanguage",
                "name": "SetLanguage",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "unMaxAgeSeconds"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 unMaxAgeSeconds",
                "name": "SetAllowCachedResponse",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pMatchCloudFileName"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pMatchCloudFileName",
                "comments": "Options only for querying user UGC",
                "name": "SetCloudFileNameFilter",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "bool",
                        "bMatchAnyTag"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, bool bMatchAnyTag",
                "comments": "Options only for querying all UGC",
                "name": "SetMatchAnyTag",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pSearchText"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pSearchText",
                "name": "SetSearchText",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "unDays"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, uint32 unDays",
                "name": "SetRankedByTrendDays",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "UGCQueryHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pKey"
                    ],
                    [
                        "constchar*",
                        "pValue"
                    ]
                ],
                "argsstr": "UGCQueryHandle_t handle, const char *pKey, const char *pValue",
                "name": "AddRequiredKeyValueTag",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "uint32",
                        "unMaxAgeSeconds"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, uint32 unMaxAgeSeconds",
                "comments": "DEPRECATED - Use CreateQueryUGCDetailsRequest call above instead!",
                "name": "RequestUGCDetails",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nConsumerAppId"
                    ],
                    [
                        "EWorkshopFileType",
                        "eFileType"
                    ]
                ],
                "argsstr": "AppId_t nConsumerAppId, EWorkshopFileType eFileType",
                "comments": "Steam Workshop Creator API\nCALL_RESULT( CreateItemResult_t )",
                "name": "CreateItem",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 32
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nConsumerAppId"
                    ],
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "AppId_t nConsumerAppId, PublishedFileId_t nPublishedFileID",
                "comments": "Create new item for this app with no content attached yet",
                "name": "StartItemUpdate",
                "nargs": 2,
                "retval": "UGCUpdateHandle_t",
                "vfindex": 33
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchTitle"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchTitle",
                "comments": "Start an UGC item update. Set changed properties before commiting update with CommitItemUpdate()",
                "name": "SetItemTitle",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchDescription"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchDescription",
                "comments": "Change the title of an UGC item",
                "name": "SetItemDescription",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchLanguage"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchLanguage",
                "comments": "Change the description of an UGC item",
                "name": "SetItemUpdateLanguage",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 36
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchMetaData"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchMetaData",
                "comments": "Specify the language of the title or description that will be set",
                "name": "SetItemMetadata",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 37
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "ERemoteStoragePublishedFileVisibility",
                        "eVisibility"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, ERemoteStoragePublishedFileVisibility eVisibility",
                "comments": "Change the metadata of an UGC item (max = k_cchDeveloperMetadataMax)",
                "name": "SetItemVisibility",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 38
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "updateHandle"
                    ],
                    [
                        "constSteamParamStringArray_t*",
                        "pTags"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t updateHandle, const SteamParamStringArray_t *pTags",
                "comments": "Change the visibility of an UGC item",
                "name": "SetItemTags",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 39
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pszContentFolder"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pszContentFolder",
                "comments": "Change the tags of an UGC item",
                "name": "SetItemContent",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 40
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pszPreviewFile"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pszPreviewFile",
                "comments": "Update item content from this local folder",
                "name": "SetItemPreview",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 41
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchKey",
                "comments": "Change preview image file for this item. pszPreviewFile points to local image file, which must be under 1MB in size",
                "name": "RemoveItemKeyValueTags",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 42
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ],
                    [
                        "constchar*",
                        "pchValue"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchKey, const char *pchValue",
                "comments": "Remove any existing key-value tags with the specified key",
                "name": "AddItemKeyValueTag",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 43
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pszPreviewFile"
                    ],
                    [
                        "EItemPreviewType",
                        "type"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pszPreviewFile, EItemPreviewType type",
                "comments": "Add new key-value tags for the item. Note that there can be multiple values for a tag.",
                "name": "AddItemPreviewFile",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 44
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pszVideoID"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pszVideoID",
                "comments": "Add preview file for this item. pszPreviewFile points to local file, which must be under 1MB in size",
                "name": "AddItemPreviewVideo",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 45
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "constchar*",
                        "pszPreviewFile"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, uint32 index, const char *pszPreviewFile",
                "comments": "Add preview video for this item",
                "name": "UpdateItemPreviewFile",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 46
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ],
                    [
                        "constchar*",
                        "pszVideoID"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, uint32 index, const char *pszVideoID",
                "comments": "Updates an existing preview file for this item. pszPreviewFile points to local file, which must be under 1MB in size",
                "name": "UpdateItemPreviewVideo",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 47
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "uint32",
                        "index"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, uint32 index",
                "comments": "Updates an existing preview video for this item",
                "name": "RemoveItemPreview",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 48
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "constchar*",
                        "pchChangeNote"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, const char *pchChangeNote",
                "comments": "Remove a preview by index starting at 0 (previews are sorted)\n\nCALL_RESULT( SubmitItemUpdateResult_t )",
                "name": "SubmitItemUpdate",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 49
            },
            {
                "args": [
                    [
                        "UGCUpdateHandle_t",
                        "handle"
                    ],
                    [
                        "uint64*",
                        "punBytesProcessed"
                    ],
                    [
                        "uint64*",
                        "punBytesTotal"
                    ]
                ],
                "argsstr": "UGCUpdateHandle_t handle, uint64 *punBytesProcessed, uint64* punBytesTotal",
                "comments": "Commit update process started with StartItemUpdate()",
                "name": "GetItemUpdateProgress",
                "nargs": 3,
                "retval": "EItemUpdateStatus",
                "vfindex": 50
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "bool",
                        "bVoteUp"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, bool bVoteUp",
                "comments": "Steam Workshop Consumer API\nCALL_RESULT( SetUserItemVoteResult_t )",
                "name": "SetUserItemVote",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 51
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "name": "GetUserItemVote",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 52
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppId"
                    ],
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "AppId_t nAppId, PublishedFileId_t nPublishedFileID",
                "name": "AddItemToFavorites",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 53
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "nAppId"
                    ],
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "AppId_t nAppId, PublishedFileId_t nPublishedFileID",
                "name": "RemoveItemFromFavorites",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 54
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "name": "SubscribeItem",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 55
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "comments": "Subscribe to this item, will be installed ASAP\nCALL_RESULT( RemoteStorageUnsubscribePublishedFileResult_t )",
                "name": "UnsubscribeItem",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 56
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Unsubscribe from this item, will be uninstalled after game quits",
                "name": "GetNumSubscribedItems",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 57
            },
            {
                "args": [
                    [
                        "PublishedFileId_t*",
                        "pvecPublishedFileID"
                    ],
                    [
                        "uint32",
                        "cMaxEntries"
                    ]
                ],
                "argsstr": "PublishedFileId_t* pvecPublishedFileID, uint32 cMaxEntries",
                "comments": "Number of subscribed items",
                "name": "GetSubscribedItems",
                "nargs": 2,
                "retval": "uint32",
                "vfindex": 58
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "comments": "All subscribed item PublishFileIDs\n\n get EItemState flags about item on this client",
                "name": "GetItemState",
                "nargs": 1,
                "retval": "uint32",
                "vfindex": 59
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "uint64*",
                        "punSizeOnDisk"
                    ],
                    [
                        "char*",
                        "pchFolder"
                    ],
                    [
                        "uint32",
                        "cchFolderSize"
                    ],
                    [
                        "uint32*",
                        "punTimeStamp"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, uint64 *punSizeOnDisk,  char *pchFolder, uint32 cchFolderSize, uint32 *punTimeStamp",
                "comments": "Get info about currently installed content on disc for items that have k_EItemStateInstalled set\n if k_EItemStateLegacyItem is set, pchFolder contains the path to the legacy file itself (not a folder)",
                "name": "GetItemInstallInfo",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 60
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "uint64*",
                        "punBytesDownloaded"
                    ],
                    [
                        "uint64*",
                        "punBytesTotal"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, uint64 *punBytesDownloaded, uint64 *punBytesTotal",
                "comments": "Get info about pending update for items that have k_EItemStateNeedsUpdate set. punBytesTotal will be valid after download started once",
                "name": "GetItemDownloadInfo",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 61
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "bool",
                        "bHighPriority"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, bool bHighPriority",
                "comments": "Download new or update already installed item. If function returns true, wait for DownloadItemResult_t. If the item is already installed,\n then files on disk should not be used until callback received. If item is not subscribed to, it will be cached for some time.\n If bHighPriority is set, any other item download will be suspended and this item downloaded ASAP.",
                "name": "DownloadItem",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 62
            },
            {
                "args": [
                    [
                        "DepotId_t",
                        "unWorkshopDepotID"
                    ],
                    [
                        "constchar*",
                        "pszFolder"
                    ]
                ],
                "argsstr": "DepotId_t unWorkshopDepotID, const char *pszFolder",
                "comments": "Game servers can set a specific workshop folder before issuing any UGC commands.\n This is helpful if you want to support multiple game servers running out of the same install folder",
                "name": "BInitWorkshopForGameServer",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 63
            },
            {
                "args": [
                    [
                        "bool",
                        "bSuspend"
                    ]
                ],
                "argsstr": "bool bSuspend",
                "comments": "SuspendDownloads( true ) will suspend all workshop downloads until SuspendDownloads( false ) is called or the game ends",
                "name": "SuspendDownloads",
                "nargs": 1,
                "retval": "void",
                "vfindex": 64
            },
            {
                "args": [
                    [
                        "PublishedFileId_t*",
                        "pvecPublishedFileID"
                    ],
                    [
                        "uint32",
                        "unNumPublishedFileIDs"
                    ]
                ],
                "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs",
                "comments": "Usage tracking\nCALL_RESULT( StartPlaytimeTrackingResult_t )",
                "name": "StartPlaytimeTracking",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 65
            },
            {
                "args": [
                    [
                        "PublishedFileId_t*",
                        "pvecPublishedFileID"
                    ],
                    [
                        "uint32",
                        "unNumPublishedFileIDs"
                    ]
                ],
                "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs",
                "name": "StopPlaytimeTracking",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 66
            },
            {
                "args": [],
                "argsstr": "",
                "name": "StopPlaytimeTrackingForAllItems",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 67
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nParentPublishedFileID"
                    ],
                    [
                        "PublishedFileId_t",
                        "nChildPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nParentPublishedFileID, PublishedFileId_t nChildPublishedFileID",
                "comments": "Parent-child relationship or dependency management\nCALL_RESULT( AddUGCDependencyResult_t )",
                "name": "AddDependency",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 68
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nParentPublishedFileID"
                    ],
                    [
                        "PublishedFileId_t",
                        "nChildPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nParentPublishedFileID, PublishedFileId_t nChildPublishedFileID",
                "name": "RemoveDependency",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 69
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, AppId_t nAppID",
                "comments": "Add/remove app dependence/requirements (usually DLC)\nCALL_RESULT( AddAppDependencyResult_t )",
                "name": "AddAppDependency",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 70
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ],
                    [
                        "AppId_t",
                        "nAppID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID, AppId_t nAppID",
                "name": "RemoveAppDependency",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 71
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "comments": "Request app dependencies. note that whatever callback you register for GetAppDependenciesResult_t may be called multiple times\n until all app dependencies have been returned\nCALL_RESULT( GetAppDependenciesResult_t )",
                "name": "GetAppDependencies",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 72
            },
            {
                "args": [
                    [
                        "PublishedFileId_t",
                        "nPublishedFileID"
                    ]
                ],
                "argsstr": "PublishedFileId_t nPublishedFileID",
                "comments": "Delete the item without prompting the user\nCALL_RESULT( DeleteItemResult_t )",
                "name": "DeleteItem",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 73
            }
        ]
    },
    "ISteamUser": {
        "cppclass": "ISteamUser",
        "cppinterface": "STEAMUSER_INTERFACE_VERSION",
        "cppinterfacev": "SteamUser019",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the HSteamUser this interface represents\n this is only used internally by the API, and by a few select interfaces that support multi-user",
                "name": "GetHSteamUser",
                "nargs": 0,
                "retval": "HSteamUser",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if the Steam client current has a live connection to the Steam servers. \n If false, it means there is no active connection due to either a networking issue on the local machine, or the Steam server is down/busy.\n The Steam client will automatically be trying to recreate the connection as often as possible.",
                "name": "BLoggedOn",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the CSteamID of the account currently logged into the Steam client\n a CSteamID is a unique identifier for an account, and used to differentiate users in all parts of the Steamworks API",
                "name": "GetSteamID",
                "nargs": 0,
                "retval": "CSteamID",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "void*",
                        "pAuthBlob"
                    ],
                    [
                        "int",
                        "cbMaxAuthBlob"
                    ],
                    [
                        "CSteamID",
                        "steamIDGameServer"
                    ],
                    [
                        "uint32",
                        "unIPServer"
                    ],
                    [
                        "uint16",
                        "usPortServer"
                    ],
                    [
                        "bool",
                        "bSecure"
                    ]
                ],
                "argsstr": "void *pAuthBlob, int cbMaxAuthBlob, CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer, bool bSecure",
                "comments": "Multiplayer Authentication functions\n\n InitiateGameConnection() starts the state machine for authenticating the game client with the game server\n It is the client portion of a three-way handshake between the client, the game server, and the steam servers\n\n Parameters:\n void *pAuthBlob - a pointer to empty memory that will be filled in with the authentication token.\n int cbMaxAuthBlob - the number of bytes of allocated memory in pBlob. Should be at least 2048 bytes.\n CSteamID steamIDGameServer - the steamID of the game server, received from the game server by the client\n CGameID gameID - the ID of the current game. For games without mods, this is just CGameID( <appID> )\n uint32 unIPServer, uint16 usPortServer - the IP address of the game server\n bool bSecure - whether or not the client thinks that the game server is reporting itself as secure (i.e. VAC is running)\n\n return value - returns the number of bytes written to pBlob. If the return is 0, then the buffer passed in was too small, and the call has failed\n The contents of pBlob should then be sent to the game server, for it to use to complete the authentication process.",
                "name": "InitiateGameConnection",
                "nargs": 6,
                "retval": "int",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "uint32",
                        "unIPServer"
                    ],
                    [
                        "uint16",
                        "usPortServer"
                    ]
                ],
                "argsstr": "uint32 unIPServer, uint16 usPortServer",
                "comments": "Notify of disconnect\n needs to occur when the game client leaves the specified game server, needs to match with the InitiateGameConnection() call",
                "name": "TerminateGameConnection",
                "nargs": 2,
                "retval": "void",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "CGameID",
                        "gameID"
                    ],
                    [
                        "int",
                        "eAppUsageEvent"
                    ],
                    [
                        "constchar*pchExtraInfo=",
                        "\"\""
                    ]
                ],
                "argsstr": "CGameID gameID, int eAppUsageEvent, const char *pchExtraInfo = \"\"",
                "comments": "Legacy functions\n\n used by only a few games to track usage events",
                "name": "TrackAppUsageEvent",
                "nargs": 3,
                "retval": "void",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "char*",
                        "pchBuffer"
                    ],
                    [
                        "int",
                        "cubBuffer"
                    ]
                ],
                "argsstr": "char *pchBuffer, int cubBuffer",
                "comments": "Get the local storage folder for current Steam account to write application data, e.g. save games, configs etc.\n this will usually be something like \"C:\\Progam Files\\Steam\\userdata\\<SteamID>\\<AppID>\\local\"",
                "name": "GetUserDataFolder",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Starts voice recording. Once started, use GetVoice() to get the data",
                "name": "StartVoiceRecording",
                "nargs": 0,
                "retval": "void",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Stops voice recording. Because people often release push-to-talk keys early, the system will keep recording for\n a little bit after this function is called. GetVoice() should continue to be called until it returns\n k_eVoiceResultNotRecording",
                "name": "StopVoiceRecording",
                "nargs": 0,
                "retval": "void",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "uint32*",
                        "pcbCompressed"
                    ],
                    [
                        "uint32*pcbUncompressed_Deprecated=",
                        "0"
                    ],
                    [
                        "uint32nUncompressedVoiceDesiredSampleRate_Deprecated=",
                        "0"
                    ]
                ],
                "argsstr": "uint32 *pcbCompressed, uint32 *pcbUncompressed_Deprecated = 0, uint32 nUncompressedVoiceDesiredSampleRate_Deprecated = 0",
                "comments": "Determine the size of captured audio data that is available from GetVoice.\n Most applications will only use compressed data and should ignore the other\n parameters, which exist primarily for backwards compatibility. See comments\n below for further explanation of \"uncompressed\" data.",
                "name": "GetAvailableVoice",
                "nargs": 3,
                "retval": "EVoiceResult",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "bool",
                        "bWantCompressed"
                    ],
                    [
                        "void*",
                        "pDestBuffer"
                    ],
                    [
                        "uint32",
                        "cbDestBufferSize"
                    ],
                    [
                        "uint32*",
                        "nBytesWritten"
                    ],
                    [
                        "boolbWantUncompressed_Deprecated=",
                        "false"
                    ],
                    [
                        "void*pUncompressedDestBuffer_Deprecated=",
                        "0"
                    ],
                    [
                        "uint32cbUncompressedDestBufferSize_Deprecated=",
                        "0"
                    ],
                    [
                        "uint32*nUncompressBytesWritten_Deprecated=",
                        "0"
                    ],
                    [
                        "uint32nUncompressedVoiceDesiredSampleRate_Deprecated=",
                        "0"
                    ]
                ],
                "argsstr": "bool bWantCompressed, void *pDestBuffer, uint32 cbDestBufferSize, uint32 *nBytesWritten, bool bWantUncompressed_Deprecated = false, void *pUncompressedDestBuffer_Deprecated = 0, uint32 cbUncompressedDestBufferSize_Deprecated = 0, uint32 *nUncompressBytesWritten_Deprecated = 0, uint32 nUncompressedVoiceDesiredSampleRate_Deprecated = 0",
                "comments": "---------------------------------------------------------------------------\n NOTE: \"uncompressed\" audio is a deprecated feature and should not be used\n by most applications. It is raw single-channel 16-bit PCM wave data which\n may have been run through preprocessing filters and/or had silence removed,\n so the uncompressed audio could have a shorter duration than you expect.\n There may be no data at all during long periods of silence. Also, fetching\n uncompressed audio will cause GetVoice to discard any leftover compressed\n audio, so you must fetch both types at once. Finally, GetAvailableVoice is\n not precisely accurate when the uncompressed size is requested. So if you\n really need to use uncompressed audio, you should call GetVoice frequently\n with two very large (20kb+) output buffers instead of trying to allocate\n perfectly-sized buffers. But most applications should ignore all of these\n details and simply leave the \"uncompressed\" parameters as NULL/zero.\n ---------------------------------------------------------------------------\n\n Read captured audio data from the microphone buffer. This should be called\n at least once per frame, and preferably every few milliseconds, to keep the\n microphone input delay as low as possible. Most applications will only use\n compressed data and should pass NULL/zero for the \"uncompressed\" parameters.\n Compressed data can be transmitted by your application and decoded into raw\n using the DecompressVoice function below.",
                "name": "GetVoice",
                "nargs": 9,
                "retval": "EVoiceResult",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "constvoid*",
                        "pCompressed"
                    ],
                    [
                        "uint32",
                        "cbCompressed"
                    ],
                    [
                        "void*",
                        "pDestBuffer"
                    ],
                    [
                        "uint32",
                        "cbDestBufferSize"
                    ],
                    [
                        "uint32*",
                        "nBytesWritten"
                    ],
                    [
                        "uint32",
                        "nDesiredSampleRate"
                    ]
                ],
                "argsstr": "const void *pCompressed, uint32 cbCompressed, void *pDestBuffer, uint32 cbDestBufferSize, uint32 *nBytesWritten, uint32 nDesiredSampleRate",
                "comments": "Decodes the compressed voice data returned by GetVoice. The output data is\n raw single-channel 16-bit PCM audio. The decoder supports any sample rate\n from 11025 to 48000; see GetVoiceOptimalSampleRate() below for details.\n If the output buffer is not large enough, then *nBytesWritten will be set\n to the required buffer size, and k_EVoiceResultBufferTooSmall is returned.\n It is suggested to start with a 20kb buffer and reallocate as necessary.",
                "name": "DecompressVoice",
                "nargs": 6,
                "retval": "EVoiceResult",
                "vfindex": 11
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "This returns the native sample rate of the Steam voice decompressor; using\n this sample rate for DecompressVoice will perform the least CPU processing.\n However, the final audio quality will depend on how well the audio device\n (and/or your application's audio output SDK) deals with lower sample rates.\n You may find that you get the best audio output quality when you ignore\n this function and use the native sample rate of your audio output device,\n which is usually 48000 or 44100.",
                "name": "GetVoiceOptimalSampleRate",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "void*",
                        "pTicket"
                    ],
                    [
                        "int",
                        "cbMaxTicket"
                    ],
                    [
                        "uint32*",
                        "pcbTicket"
                    ]
                ],
                "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket",
                "comments": "Retrieve ticket to be sent to the entity who wishes to authenticate you. \n pcbTicket retrieves the length of the actual ticket.",
                "name": "GetAuthSessionTicket",
                "nargs": 3,
                "retval": "HAuthTicket",
                "vfindex": 13
            },
            {
                "args": [
                    [
                        "constvoid*",
                        "pAuthTicket"
                    ],
                    [
                        "int",
                        "cbAuthTicket"
                    ],
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "const void *pAuthTicket, int cbAuthTicket, CSteamID steamID",
                "comments": "Authenticate ticket from entity steamID to be sure it is valid and isnt reused\n Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )",
                "name": "BeginAuthSession",
                "nargs": 3,
                "retval": "EBeginAuthSessionResult",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ]
                ],
                "argsstr": "CSteamID steamID",
                "comments": "Stop tracking started by BeginAuthSession - called when no longer playing game with this entity",
                "name": "EndAuthSession",
                "nargs": 1,
                "retval": "void",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "HAuthTicket",
                        "hAuthTicket"
                    ]
                ],
                "argsstr": "HAuthTicket hAuthTicket",
                "comments": "Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to",
                "name": "CancelAuthTicket",
                "nargs": 1,
                "retval": "void",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamID"
                    ],
                    [
                        "AppId_t",
                        "appID"
                    ]
                ],
                "argsstr": "CSteamID steamID, AppId_t appID",
                "comments": "After receiving a user's authentication data, and passing it to BeginAuthSession, use this function\n to determine if the user owns downloadable content specified by the provided AppID.",
                "name": "UserHasLicenseForApp",
                "nargs": 2,
                "retval": "EUserHasLicenseForAppResult",
                "vfindex": 17
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if this users looks like they are behind a NAT device. Only valid once the user has connected to steam \n (i.e a SteamServersConnected_t has been issued) and may not catch all forms of NAT.",
                "name": "BIsBehindNAT",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDGameServer"
                    ],
                    [
                        "uint32",
                        "unIPServer"
                    ],
                    [
                        "uint16",
                        "usPortServer"
                    ]
                ],
                "argsstr": "CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer",
                "comments": "Set data to be replicated to friends so that they can join your game\n CSteamID steamIDGameServer - the steamID of the game server, received from the game server by the client\n uint32 unIPServer, uint16 usPortServer - the IP address of the game server",
                "name": "AdvertiseGame",
                "nargs": 3,
                "retval": "void",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "void*",
                        "pDataToInclude"
                    ],
                    [
                        "int",
                        "cbDataToInclude"
                    ]
                ],
                "argsstr": "void *pDataToInclude, int cbDataToInclude",
                "comments": "Requests a ticket encrypted with an app specific shared key\n pDataToInclude, cbDataToInclude will be encrypted into the ticket\n ( This is asynchronous, you must wait for the ticket to be completed by the server )\nCALL_RESULT( EncryptedAppTicketResponse_t )",
                "name": "RequestEncryptedAppTicket",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "void*",
                        "pTicket"
                    ],
                    [
                        "int",
                        "cbMaxTicket"
                    ],
                    [
                        "uint32*",
                        "pcbTicket"
                    ]
                ],
                "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket",
                "comments": "Retrieve a finished ticket",
                "name": "GetEncryptedAppTicket",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "int",
                        "nSeries"
                    ],
                    [
                        "bool",
                        "bFoil"
                    ]
                ],
                "argsstr": "int nSeries, bool bFoil",
                "comments": "Trading Card badges data access\n if you only have one set of cards, the series will be 1\n the user has can have two different badges for a series; the regular (max level 5) and the foil (max level 1)",
                "name": "GetGameBadgeLevel",
                "nargs": 2,
                "retval": "int",
                "vfindex": 22
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets the Steam Level of the user, as shown on their profile",
                "name": "GetPlayerSteamLevel",
                "nargs": 0,
                "retval": "int",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchRedirectURL"
                    ]
                ],
                "argsstr": "const char *pchRedirectURL",
                "comments": "Requests a URL which authenticates an in-game browser for store check-out,\n and then redirects to the specified URL. As long as the in-game browser\n accepts and handles session cookies, Steam microtransaction checkout pages\n will automatically recognize the user instead of presenting a login page.\n The result of this API call will be a StoreAuthURLResponse_t callback.\n NOTE: The URL has a very short lifetime to prevent history-snooping attacks,\n so you should only call this API when you are about to launch the browser,\n or else immediately navigate to the result URL using a hidden browser window.\n NOTE 2: The resulting authorization cookie has an expiration time of one day,\n so it would be a good idea to request and visit a new auth URL every 12 hours.\nCALL_RESULT( StoreAuthURLResponse_t )",
                "name": "RequestStoreAuthURL",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 24
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets whether the users phone number is verified",
                "name": "BIsPhoneVerified",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 25
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets whether the user has two factor enabled on their account",
                "name": "BIsTwoFactorEnabled",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets whether the users phone number is identifying",
                "name": "BIsPhoneIdentifying",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 27
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Gets whether the users phone number is awaiting (re)verification",
                "name": "BIsPhoneRequiringVerification",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 28
            }
        ]
    },
    "ISteamUserStats": {
        "cppclass": "ISteamUserStats",
        "cppinterface": "STEAMUSERSTATS_INTERFACE_VERSION",
        "cppinterfacev": "STEAMUSERSTATS_INTERFACE_VERSION011",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Ask the server to send down this user's data and achievements for this game\nCALL_BACK( UserStatsReceived_t )",
                "name": "RequestCurrentStats",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int32*",
                        "pData"
                    ]
                ],
                "argsstr": "const char *pchName, int32 *pData",
                "comments": "Data accessors",
                "name": "GetStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float*",
                        "pData"
                    ]
                ],
                "argsstr": "const char *pchName, float *pData",
                "name": "GetStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int32",
                        "nData"
                    ]
                ],
                "argsstr": "const char *pchName, int32 nData",
                "comments": "Set / update data",
                "name": "SetStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 3
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float",
                        "fData"
                    ]
                ],
                "argsstr": "const char *pchName, float fData",
                "name": "SetStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float",
                        "flCountThisSession"
                    ],
                    [
                        "double",
                        "dSessionLength"
                    ]
                ],
                "argsstr": "const char *pchName, float flCountThisSession, double dSessionLength",
                "name": "UpdateAvgRateStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ]
                ],
                "argsstr": "const char *pchName, bool *pbAchieved",
                "comments": "Achievement flag accessors",
                "name": "GetAchievement",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "const char *pchName",
                "name": "SetAchievement",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "const char *pchName",
                "name": "ClearAchievement",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 8
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ],
                    [
                        "uint32*",
                        "punUnlockTime"
                    ]
                ],
                "argsstr": "const char *pchName, bool *pbAchieved, uint32 *punUnlockTime",
                "comments": "Get the achievement status, and the time it was unlocked if unlocked.\n If the return value is true, but the unlock time is zero, that means it was unlocked before Steam \n began tracking achievement unlock times (December 2009). Time is seconds since January 1, 1970.",
                "name": "GetAchievementAndUnlockTime",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 9
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Store the current data on the server, will get a callback when set\n And one callback for every new achievement\n\n If the callback has a result of k_EResultInvalidParam, one or more stats \n uploaded has been rejected, either because they broke constraints\n or were out of date. In this case the server sends back updated values.\n The stats should be re-iterated to keep in sync.",
                "name": "StoreStats",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ]
                ],
                "argsstr": "const char *pchName",
                "comments": "Achievement / GroupAchievement metadata\n\n Gets the icon of the achievement, which is a handle to be used in ISteamUtils::GetImageRGBA(), or 0 if none set. \n A return value of 0 may indicate we are still fetching data, and you can wait for the UserAchievementIconFetched_t callback\n which will notify you when the bits are ready. If the callback still returns zero, then there is no image set for the\n specified achievement.",
                "name": "GetAchievementIcon",
                "nargs": 1,
                "retval": "int",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "constchar*",
                        "pchKey"
                    ]
                ],
                "argsstr": "const char *pchName, const char *pchKey",
                "comments": "Get general attributes for an achievement. Accepts the following keys:\n - \"name\" and \"desc\" for retrieving the localized achievement name and description (returned in UTF8)\n - \"hidden\" for retrieving if an achievement is hidden (returns \"0\" when not hidden, \"1\" when hidden)",
                "name": "GetAchievementDisplayAttribute",
                "nargs": 2,
                "retval": "const char *",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "uint32",
                        "nCurProgress"
                    ],
                    [
                        "uint32",
                        "nMaxProgress"
                    ]
                ],
                "argsstr": "const char *pchName, uint32 nCurProgress, uint32 nMaxProgress",
                "comments": "Achievement progress - triggers an AchievementProgress callback, that is all.\n Calling this w/ N out of N progress will NOT set the achievement, the game must still do that.",
                "name": "IndicateAchievementProgress",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Used for iterating achievements. In general games should not need these functions because they should have a\n list of existing achievements compiled into them",
                "name": "GetNumAchievements",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 14
            },
            {
                "args": [
                    [
                        "uint32",
                        "iAchievement"
                    ]
                ],
                "argsstr": "uint32 iAchievement",
                "comments": "Get achievement name iAchievement in [0,GetNumAchievements)",
                "name": "GetAchievementName",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser",
                "comments": "Friends stats & achievements\n\n downloads stats for the user\n returns a UserStatsReceived_t received when completed\n if the other user has no stats, UserStatsReceived_t.m_eResult will be set to k_EResultFail\n these stats won't be auto-updated; you'll need to call RequestUserStats() again to refresh any data\nCALL_RESULT( UserStatsReceived_t )",
                "name": "RequestUserStats",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 16
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "int32*",
                        "pData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, int32 *pData",
                "comments": "Requests stat information for a user, usable after a successful call to RequestUserStats()",
                "name": "GetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float*",
                        "pData"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, float *pData",
                "name": "GetUserStat",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved",
                "name": "GetUserAchievement",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "CSteamID",
                        "steamIDUser"
                    ],
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ],
                    [
                        "uint32*",
                        "punUnlockTime"
                    ]
                ],
                "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved, uint32 *punUnlockTime",
                "comments": "See notes for GetAchievementAndUnlockTime above",
                "name": "GetUserAchievementAndUnlockTime",
                "nargs": 4,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [
                    [
                        "bool",
                        "bAchievementsToo"
                    ]
                ],
                "argsstr": "bool bAchievementsToo",
                "comments": "Reset stats",
                "name": "ResetAllStats",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchLeaderboardName"
                    ],
                    [
                        "ELeaderboardSortMethod",
                        "eLeaderboardSortMethod"
                    ],
                    [
                        "ELeaderboardDisplayType",
                        "eLeaderboardDisplayType"
                    ]
                ],
                "argsstr": "const char *pchLeaderboardName, ELeaderboardSortMethod eLeaderboardSortMethod, ELeaderboardDisplayType eLeaderboardDisplayType",
                "comments": "Leaderboard functions\n\n asks the Steam back-end for a leaderboard by name, and will create it if it's not yet\n This call is asynchronous, with the result returned in LeaderboardFindResult_t\nCALL_RESULT(LeaderboardFindResult_t)",
                "name": "FindOrCreateLeaderboard",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 22
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchLeaderboardName"
                    ]
                ],
                "argsstr": "const char *pchLeaderboardName",
                "comments": "As above, but won't create the leaderboard if it's not found\n This call is asynchronous, with the result returned in LeaderboardFindResult_t\nCALL_RESULT( LeaderboardFindResult_t )",
                "name": "FindLeaderboard",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 23
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard",
                "comments": "Returns the name of a leaderboard",
                "name": "GetLeaderboardName",
                "nargs": 1,
                "retval": "const char *",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard",
                "comments": "Returns the total number of entries in a leaderboard, as of the last request",
                "name": "GetLeaderboardEntryCount",
                "nargs": 1,
                "retval": "int",
                "vfindex": 25
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard",
                "comments": "Returns the sort method of the leaderboard",
                "name": "GetLeaderboardSortMethod",
                "nargs": 1,
                "retval": "ELeaderboardSortMethod",
                "vfindex": 26
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard",
                "comments": "Returns the display type of the leaderboard",
                "name": "GetLeaderboardDisplayType",
                "nargs": 1,
                "retval": "ELeaderboardDisplayType",
                "vfindex": 27
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ],
                    [
                        "ELeaderboardDataRequest",
                        "eLeaderboardDataRequest"
                    ],
                    [
                        "int",
                        "nRangeStart"
                    ],
                    [
                        "int",
                        "nRangeEnd"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard, ELeaderboardDataRequest eLeaderboardDataRequest, int nRangeStart, int nRangeEnd",
                "comments": "Asks the Steam back-end for a set of rows in the leaderboard.\n This call is asynchronous, with the result returned in LeaderboardScoresDownloaded_t\n LeaderboardScoresDownloaded_t will contain a handle to pull the results from GetDownloadedLeaderboardEntries() (below)\n You can ask for more entries than exist, and it will return as many as do exist.\n k_ELeaderboardDataRequestGlobal requests rows in the leaderboard from the full table, with nRangeStart & nRangeEnd in the range [1, TotalEntries]\n k_ELeaderboardDataRequestGlobalAroundUser requests rows around the current user, nRangeStart being negate\n   e.g. DownloadLeaderboardEntries( hLeaderboard, k_ELeaderboardDataRequestGlobalAroundUser, -3, 3 ) will return 7 rows, 3 before the user, 3 after\n k_ELeaderboardDataRequestFriends requests all the rows for friends of the current user \nCALL_RESULT( LeaderboardScoresDownloaded_t )",
                "name": "DownloadLeaderboardEntries",
                "nargs": 4,
                "retval": "SteamAPICall_t",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ],
                    [
                        "CSteamID*",
                        "prgUsers"
                    ],
                    [
                        "int",
                        "cUsers"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    CSteamID *prgUsers, int cUsers",
                "comments": "As above, but downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers\n if a user doesn't have a leaderboard entry, they won't be included in the result\n a max of 100 users can be downloaded at a time, with only one outstanding call at a time\nMETHOD_DESC(Downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers)\nCALL_RESULT( LeaderboardScoresDownloaded_t )",
                "name": "DownloadLeaderboardEntriesForUsers",
                "nargs": 3,
                "retval": "SteamAPICall_t",
                "vfindex": 29
            },
            {
                "args": [
                    [
                        "SteamLeaderboardEntries_t",
                        "hSteamLeaderboardEntries"
                    ],
                    [
                        "int",
                        "index"
                    ],
                    [
                        "LeaderboardEntry_t*",
                        "pLeaderboardEntry"
                    ],
                    [
                        "int32*",
                        "pDetails"
                    ],
                    [
                        "int",
                        "cDetailsMax"
                    ]
                ],
                "argsstr": "SteamLeaderboardEntries_t hSteamLeaderboardEntries, int index, LeaderboardEntry_t *pLeaderboardEntry, int32 *pDetails, int cDetailsMax",
                "comments": "Returns data about a single leaderboard entry\n use a for loop from 0 to LeaderboardScoresDownloaded_t::m_cEntryCount to get all the downloaded entries\n e.g.\nvoid OnLeaderboardScoresDownloaded( LeaderboardScoresDownloaded_t *pLeaderboardScoresDownloaded )\n{\nfor ( int index = 0; index < pLeaderboardScoresDownloaded->m_cEntryCount; index++ )\n{\nLeaderboardEntry_t leaderboardEntry;\nint32 details[3]; we know this is how many we've stored previously\nGetDownloadedLeaderboardEntry( pLeaderboardScoresDownloaded->m_hSteamLeaderboardEntries, index, &leaderboardEntry, details, 3 );\nassert( leaderboardEntry.m_cDetails == 3 );\n...\n}\n once you've accessed all the entries, the data will be free'd, and the SteamLeaderboardEntries_t handle will become invalid",
                "name": "GetDownloadedLeaderboardEntry",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 30
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ],
                    [
                        "ELeaderboardUploadScoreMethod",
                        "eLeaderboardUploadScoreMethod"
                    ],
                    [
                        "int32",
                        "nScore"
                    ],
                    [
                        "constint32*",
                        "pScoreDetails"
                    ],
                    [
                        "int",
                        "cScoreDetailsCount"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard, ELeaderboardUploadScoreMethod eLeaderboardUploadScoreMethod, int32 nScore, const int32 *pScoreDetails, int cScoreDetailsCount",
                "comments": "Uploads a user score to the Steam back-end.\n This call is asynchronous, with the result returned in LeaderboardScoreUploaded_t\n Details are extra game-defined information regarding how the user got that score\n pScoreDetails points to an array of int32's, cScoreDetailsCount is the number of int32's in the list\nCALL_RESULT( LeaderboardScoreUploaded_t )",
                "name": "UploadLeaderboardScore",
                "nargs": 5,
                "retval": "SteamAPICall_t",
                "vfindex": 31
            },
            {
                "args": [
                    [
                        "SteamLeaderboard_t",
                        "hSteamLeaderboard"
                    ],
                    [
                        "UGCHandle_t",
                        "hUGC"
                    ]
                ],
                "argsstr": "SteamLeaderboard_t hSteamLeaderboard, UGCHandle_t hUGC",
                "comments": "Attaches a piece of user generated content the user's entry on a leaderboard.\n hContent is a handle to a piece of user generated content that was shared using ISteamUserRemoteStorage::FileShare().\n This call is asynchronous, with the result returned in LeaderboardUGCSet_t.\nCALL_RESULT( LeaderboardUGCSet_t )",
                "name": "AttachLeaderboardUGC",
                "nargs": 2,
                "retval": "SteamAPICall_t",
                "vfindex": 32
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Retrieves the number of players currently playing your game (online + offline)\n This call is asynchronous, with the result returned in NumberOfCurrentPlayers_t\nCALL_RESULT( NumberOfCurrentPlayers_t )",
                "name": "GetNumberOfCurrentPlayers",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 33
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Requests that Steam fetch data on the percentage of players who have received each achievement\n for the game globally.\n This call is asynchronous, with the result returned in GlobalAchievementPercentagesReady_t.\nCALL_RESULT( GlobalAchievementPercentagesReady_t )",
                "name": "RequestGlobalAchievementPercentages",
                "nargs": 0,
                "retval": "SteamAPICall_t",
                "vfindex": 34
            },
            {
                "args": [
                    [
                        "char*",
                        "pchName"
                    ],
                    [
                        "uint32",
                        "unNameBufLen"
                    ],
                    [
                        "float*",
                        "pflPercent"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ]
                ],
                "argsstr": "char *pchName, uint32 unNameBufLen, float *pflPercent, bool *pbAchieved",
                "comments": "Get the info on the most achieved achievement for the game, returns an iterator index you can use to fetch\n the next most achieved afterwards.  Will return -1 if there is no data on achievement \n percentages (ie, you haven't called RequestGlobalAchievementPercentages and waited on the callback).",
                "name": "GetMostAchievedAchievementInfo",
                "nargs": 4,
                "retval": "int",
                "vfindex": 35
            },
            {
                "args": [
                    [
                        "int",
                        "iIteratorPrevious"
                    ],
                    [
                        "char*",
                        "pchName"
                    ],
                    [
                        "uint32",
                        "unNameBufLen"
                    ],
                    [
                        "float*",
                        "pflPercent"
                    ],
                    [
                        "bool*",
                        "pbAchieved"
                    ]
                ],
                "argsstr": "int iIteratorPrevious, char *pchName, uint32 unNameBufLen, float *pflPercent, bool *pbAchieved",
                "comments": "Get the info on the next most achieved achievement for the game. Call this after GetMostAchievedAchievementInfo or another\n GetNextMostAchievedAchievementInfo call passing the iterator from the previous call. Returns -1 after the last\n achievement has been iterated.",
                "name": "GetNextMostAchievedAchievementInfo",
                "nargs": 5,
                "retval": "int",
                "vfindex": 36
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchName"
                    ],
                    [
                        "float*",
                        "pflPercent"
                    ]
                ],
                "argsstr": "const char *pchName, float *pflPercent",
                "comments": "Returns the percentage of users who have achieved the specified achievement.",
                "name": "GetAchievementAchievedPercent",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 37
            },
            {
                "args": [
                    [
                        "int",
                        "nHistoryDays"
                    ]
                ],
                "argsstr": "int nHistoryDays",
                "comments": "Requests global stats data, which is available for stats marked as \"aggregated\".\n This call is asynchronous, with the results returned in GlobalStatsReceived_t.\n nHistoryDays specifies how many days of day-by-day history to retrieve in addition\n to the overall totals. The limit is 60.\nCALL_RESULT( GlobalStatsReceived_t )",
                "name": "RequestGlobalStats",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 38
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchStatName"
                    ],
                    [
                        "int64*",
                        "pData"
                    ]
                ],
                "argsstr": "const char *pchStatName, int64 *pData",
                "comments": "Gets the lifetime totals for an aggregated stat",
                "name": "GetGlobalStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 39
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchStatName"
                    ],
                    [
                        "double*",
                        "pData"
                    ]
                ],
                "argsstr": "const char *pchStatName, double *pData",
                "name": "GetGlobalStat",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 40
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchStatName"
                    ],
                    [
                        "int64*",
                        "pData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ]
                ],
                "argsstr": "const char *pchStatName,  int64 *pData, uint32 cubData",
                "comments": "Gets history for an aggregated stat. pData will be filled with daily values, starting with today.\n So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, \n etc. cubData is the size in bytes of the pubData buffer. Returns the number of \n elements actually set.",
                "name": "GetGlobalStatHistory",
                "nargs": 3,
                "retval": "int32",
                "vfindex": 41
            },
            {
                "args": [
                    [
                        "constchar*",
                        "pchStatName"
                    ],
                    [
                        "double*",
                        "pData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ]
                ],
                "argsstr": "const char *pchStatName,  double *pData, uint32 cubData",
                "name": "GetGlobalStatHistory",
                "nargs": 3,
                "retval": "int32",
                "vfindex": 42
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Call to kick off installation of the PS3 trophies. This call is asynchronous, and the results will be returned in a PS3TrophiesInstalled_t\n callback.",
                "name": "InstallPS3Trophies",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 43
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the amount of space required at boot to install trophies. This value can be used when comparing the amount of space needed\n by the game to the available space value passed to the game at boot. The value is set during InstallPS3Trophies().",
                "name": "GetTrophySpaceRequiredBeforeInstall",
                "nargs": 0,
                "retval": "uint64",
                "vfindex": 44
            },
            {
                "args": [
                    [
                        "constvoid*",
                        "pvData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ]
                ],
                "argsstr": "const void *pvData, uint32 cubData",
                "comments": "On PS3, user stats & achievement progress through Steam must be stored with the user's saved game data.\n At startup, before calling RequestCurrentStats(), you must pass the user's stats data to Steam via this method.\n If you do not have any user data, call this function with pvData = NULL and cubData = 0",
                "name": "SetUserStatsData",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 45
            },
            {
                "args": [
                    [
                        "void*",
                        "pvData"
                    ],
                    [
                        "uint32",
                        "cubData"
                    ],
                    [
                        "uint32*",
                        "pcubWritten"
                    ]
                ],
                "argsstr": "void *pvData, uint32 cubData, uint32 *pcubWritten",
                "comments": "Call to get the user's current stats data. You should retrieve this data after receiving successful UserStatsReceived_t & UserStatsStored_t\n callbacks, and store the data with the user's save game data. You can call this method with pvData = NULL and cubData = 0 to get the required\n buffer size.",
                "name": "GetUserStatsData",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 46
            }
        ]
    },
    "ISteamUtils": {
        "cppclass": "ISteamUtils",
        "cppinterface": "STEAMUTILS_INTERFACE_VERSION",
        "cppinterfacev": "SteamUtils009",
        "funcs": [
            {
                "args": [],
                "argsstr": "",
                "comments": "Return the number of seconds since the user",
                "name": "GetSecondsSinceAppActive",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 0
            },
            {
                "args": [],
                "argsstr": "",
                "name": "GetSecondsSinceComputerActive",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 1
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "The universe this client is connecting to",
                "name": "GetConnectedUniverse",
                "nargs": 0,
                "retval": "EUniverse",
                "vfindex": 2
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Steam server time.  Number of seconds since January 1, 1970, GMT (i.e unix time)",
                "name": "GetServerRealTime",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 3
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the 2 digit ISO 3166-1-alpha-2 format country code this client is running in (as looked up via an IP-to-location database)\n e.g \"US\" or \"UK\".",
                "name": "GetIPCountry",
                "nargs": 0,
                "retval": "const char *",
                "vfindex": 4
            },
            {
                "args": [
                    [
                        "int",
                        "iImage"
                    ],
                    [
                        "uint32*",
                        "pnWidth"
                    ],
                    [
                        "uint32*",
                        "pnHeight"
                    ]
                ],
                "argsstr": "int iImage, uint32 *pnWidth, uint32 *pnHeight",
                "comments": "Returns true if the image exists, and valid sizes were filled out",
                "name": "GetImageSize",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 5
            },
            {
                "args": [
                    [
                        "int",
                        "iImage"
                    ],
                    [
                        "uint8*",
                        "pubDest"
                    ],
                    [
                        "int",
                        "nDestBufferSize"
                    ]
                ],
                "argsstr": "int iImage, uint8 *pubDest, int nDestBufferSize",
                "comments": "Returns true if the image exists, and the buffer was successfully filled out\n results are returned in RGBA format\n the destination buffer size should be 4 * height * width * sizeof(char)",
                "name": "GetImageRGBA",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 6
            },
            {
                "args": [
                    [
                        "uint32*",
                        "unIP"
                    ],
                    [
                        "uint16*",
                        "usPort"
                    ]
                ],
                "argsstr": "uint32 *unIP, uint16 *usPort",
                "comments": "Returns the IP of the reporting server for valve - currently only used in Source engine games",
                "name": "GetCSERIPPort",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 7
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Return the amount of battery power left in the current system in % [0..100], 255 for being on AC power",
                "name": "GetCurrentBatteryPower",
                "nargs": 0,
                "retval": "uint8",
                "vfindex": 8
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the appID of the current process",
                "name": "GetAppID",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 9
            },
            {
                "args": [
                    [
                        "ENotificationPosition",
                        "eNotificationPosition"
                    ]
                ],
                "argsstr": "ENotificationPosition eNotificationPosition",
                "comments": "Sets the position where the overlay instance for the currently calling game should show notifications.\n This position is per-game and if this function is called from outside of a game context it will do nothing.",
                "name": "SetOverlayNotificationPosition",
                "nargs": 1,
                "retval": "void",
                "vfindex": 10
            },
            {
                "args": [
                    [
                        "SteamAPICall_t",
                        "hSteamAPICall"
                    ],
                    [
                        "bool*",
                        "pbFailed"
                    ]
                ],
                "argsstr": "SteamAPICall_t hSteamAPICall, bool *pbFailed",
                "comments": "API asynchronous call results\n can be used directly, but more commonly used via the callback dispatch API (see steam_api.h)",
                "name": "IsAPICallCompleted",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 11
            },
            {
                "args": [
                    [
                        "SteamAPICall_t",
                        "hSteamAPICall"
                    ]
                ],
                "argsstr": "SteamAPICall_t hSteamAPICall",
                "name": "GetAPICallFailureReason",
                "nargs": 1,
                "retval": "ESteamAPICallFailure",
                "vfindex": 12
            },
            {
                "args": [
                    [
                        "SteamAPICall_t",
                        "hSteamAPICall"
                    ],
                    [
                        "void*",
                        "pCallback"
                    ],
                    [
                        "int",
                        "cubCallback"
                    ],
                    [
                        "int",
                        "iCallbackExpected"
                    ],
                    [
                        "bool*",
                        "pbFailed"
                    ]
                ],
                "argsstr": "SteamAPICall_t hSteamAPICall, void *pCallback, int cubCallback, int iCallbackExpected, bool *pbFailed",
                "name": "GetAPICallResult",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 13
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Deprecated. Applications should use SteamAPI_RunCallbacks() instead. Game servers do not need to call this function.\nSTEAM_PRIVATE_API(",
                "name": "RunFrame",
                "nargs": 0,
                "retval": "void",
                "vfindex": 14
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the number of IPC calls made since the last time this function was called\n Used for perf debugging so you can understand how many IPC calls your game makes per frame\n Every IPC call is at minimum a thread context switch if not a process one so you want to rate\n control how often you do them.",
                "name": "GetIPCCallCount",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 15
            },
            {
                "args": [
                    [
                        "SteamAPIWarningMessageHook_t",
                        "pFunction"
                    ]
                ],
                "argsstr": "SteamAPIWarningMessageHook_t pFunction",
                "comments": "API warning handling\n 'int' is the severity; 0 for msg, 1 for warning\n 'const char *' is the text of the message\n callbacks will occur directly after the API function is called that generated the warning or message",
                "name": "SetWarningMessageHook",
                "nargs": 1,
                "retval": "void",
                "vfindex": 16
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if the overlay is running & the user can access it. The overlay process could take a few seconds to\n start & hook the game process, so this function will initially return false while the overlay is loading.",
                "name": "IsOverlayEnabled",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 17
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Normally this call is unneeded if your game has a constantly running frame loop that calls the \n D3D Present API, or OGL SwapBuffers API every frame.\n\n However, if you have a game that only refreshes the screen on an event driven basis then that can break \n the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also\n need to Present() to the screen any time an even needing a notification happens or when the overlay is\n brought up over the game by a user.  You can use this API to ask the overlay if it currently need a present\n in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you\n refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.",
                "name": "BOverlayNeedsPresent",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 18
            },
            {
                "args": [
                    [
                        "constchar*",
                        "szFileName"
                    ]
                ],
                "argsstr": "const char *szFileName",
                "comments": "Asynchronous call to check if an executable file has been signed using the public key set on the signing tab\n of the partner site, for example to refuse to load modified executable files.  \n The result is returned in CheckFileSignature_t.\n   k_ECheckFileSignatureNoSignaturesFoundForThisApp - This app has not been configured on the signing tab of the partner site to enable this function.\n   k_ECheckFileSignatureNoSignaturesFoundForThisFile - This file is not listed on the signing tab for the partner site.\n   k_ECheckFileSignatureFileNotFound - The file does not exist on disk.\n   k_ECheckFileSignatureInvalidSignature - The file exists, and the signing tab has been set for this file, but the file is either not signed or the signature does not match.\n   k_ECheckFileSignatureValidSignature - The file is signed and the signature is valid.\nCALL_RESULT( CheckFileSignature_t )",
                "name": "CheckFileSignature",
                "nargs": 1,
                "retval": "SteamAPICall_t",
                "vfindex": 19
            },
            {
                "args": [
                    [
                        "EGamepadTextInputMode",
                        "eInputMode"
                    ],
                    [
                        "EGamepadTextInputLineMode",
                        "eLineInputMode"
                    ],
                    [
                        "constchar*",
                        "pchDescription"
                    ],
                    [
                        "uint32",
                        "unCharMax"
                    ],
                    [
                        "constchar*",
                        "pchExistingText"
                    ]
                ],
                "argsstr": "EGamepadTextInputMode eInputMode, EGamepadTextInputLineMode eLineInputMode, const char *pchDescription, uint32 unCharMax, const char *pchExistingText",
                "comments": "Activates the Big Picture text input dialog which only supports gamepad input",
                "name": "ShowGamepadTextInput",
                "nargs": 5,
                "retval": "bool",
                "vfindex": 20
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns previously entered text & length",
                "name": "GetEnteredGamepadTextLength",
                "nargs": 0,
                "retval": "uint32",
                "vfindex": 21
            },
            {
                "args": [
                    [
                        "char*",
                        "pchText"
                    ],
                    [
                        "uint32",
                        "cchText"
                    ]
                ],
                "argsstr": "char *pchText, uint32 cchText",
                "name": "GetEnteredGamepadTextInput",
                "nargs": 2,
                "retval": "bool",
                "vfindex": 22
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns the language the steam client is running in, you probably want ISteamApps::GetCurrentGameLanguage instead, this is for very special usage cases",
                "name": "GetSteamUILanguage",
                "nargs": 0,
                "retval": "const char *",
                "vfindex": 23
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if Steam itself is running in VR mode",
                "name": "IsSteamRunningInVR",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 24
            },
            {
                "args": [
                    [
                        "int",
                        "nHorizontalInset"
                    ],
                    [
                        "int",
                        "nVerticalInset"
                    ]
                ],
                "argsstr": "int nHorizontalInset, int nVerticalInset",
                "comments": "Sets the inset of the overlay notification from the corner specified by SetOverlayNotificationPosition.",
                "name": "SetOverlayNotificationInset",
                "nargs": 2,
                "retval": "void",
                "vfindex": 25
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if Steam & the Steam Overlay are running in Big Picture mode\n Games much be launched through the Steam client to enable the Big Picture overlay. During development,\n a game can be added as a non-steam game to the developers library to test this feature",
                "name": "IsSteamInBigPictureMode",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 26
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Ask SteamUI to create and render its OpenVR dashboard",
                "name": "StartVRDashboard",
                "nargs": 0,
                "retval": "void",
                "vfindex": 27
            },
            {
                "args": [],
                "argsstr": "",
                "comments": "Returns true if the HMD content will be streamed via Steam In-Home Streaming",
                "name": "IsVRHeadsetStreamingEnabled",
                "nargs": 0,
                "retval": "bool",
                "vfindex": 28
            },
            {
                "args": [
                    [
                        "bool",
                        "bEnabled"
                    ]
                ],
                "argsstr": "bool bEnabled",
                "comments": "Set whether the HMD content will be streamed via Steam In-Home Streaming\n If this is set to true, then the scene in the HMD headset will be streamed, and remote input will not be allowed.\n If this is set to false, then the application window will be streamed instead, and remote input will be allowed.\n The default is true unless \"VRHeadsetStreaming\" \"0\" is in the extended appinfo for a game.\n (this is useful for games that have asymmetric multiplayer gameplay)",
                "name": "SetVRHeadsetStreamingEnabled",
                "nargs": 1,
                "retval": "void",
                "vfindex": 29
            }
        ]
    },
    "ISteamVideo": {
        "cppclass": "ISteamVideo",
        "cppinterface": "STEAMVIDEO_INTERFACE_VERSION",
        "cppinterfacev": "STEAMVIDEO_INTERFACE_V002",
        "funcs": [
            {
                "args": [
                    [
                        "AppId_t",
                        "unVideoAppID"
                    ]
                ],
                "argsstr": "AppId_t unVideoAppID",
                "comments": "Get a URL suitable for streaming the given Video app ID's video",
                "name": "GetVideoURL",
                "nargs": 1,
                "retval": "void",
                "vfindex": 0
            },
            {
                "args": [
                    [
                        "int*",
                        "pnNumViewers"
                    ]
                ],
                "argsstr": "int *pnNumViewers",
                "comments": "Returns true if user is uploading a live broadcast",
                "name": "IsBroadcasting",
                "nargs": 1,
                "retval": "bool",
                "vfindex": 1
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "unVideoAppID"
                    ]
                ],
                "argsstr": "AppId_t unVideoAppID",
                "comments": "Get the OPF Details for 360 Video Playback\nCALL_BACK( GetOPFSettingsResult_t )",
                "name": "GetOPFSettings",
                "nargs": 1,
                "retval": "void",
                "vfindex": 2
            },
            {
                "args": [
                    [
                        "AppId_t",
                        "unVideoAppID"
                    ],
                    [
                        "char*",
                        "pchBuffer"
                    ],
                    [
                        "int32*",
                        "pnBufferSize"
                    ]
                ],
                "argsstr": "AppId_t unVideoAppID, char *pchBuffer, int32 *pnBufferSize",
                "name": "GetOPFStringForApp",
                "nargs": 3,
                "retval": "bool",
                "vfindex": 3
            }
        ]
    }
}