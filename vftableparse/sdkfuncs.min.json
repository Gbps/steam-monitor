{"ISteamAppList": {"funcs": [{"retval": "uint32", "name": "GetNumInstalledApps", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "uint32", "name": "GetInstalledApps", "argsstr": "AppId_t *pvecAppID, uint32 unMaxAppIDs", "nargs": 2, "args": [["AppId_t*", "pvecAppID"], ["uint32", "unMaxAppIDs"]], "vfindex": 1}, {"comments": "Returns -1 if no name was found\nvirtual int  GetAppInstallDir( AppId_t nAppID, char *pchDirectory, int cchNameMax ) = 0;  returns -1 if no dir was found", "retval": "int", "name": "GetAppBuildId", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 2}], "cppinterface": "STEAMAPPLIST_INTERFACE_VERSION", "cppinterfacev": "STEAMAPPLIST_INTERFACE_VERSION001", "cppclass": "ISteamAppList"}, "ISteamApps": {"funcs": [{"retval": "bool", "name": "BIsSubscribed", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "bool", "name": "BIsLowViolence", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"retval": "bool", "name": "BIsCybercafe", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"retval": "bool", "name": "BIsVACBanned", "argsstr": "", "args": [], "nargs": 0, "vfindex": 3}, {"retval": "const char *", "name": "GetCurrentGameLanguage", "argsstr": "", "args": [], "nargs": 0, "vfindex": 4}, {"retval": "const char *", "name": "GetAvailableGameLanguages", "argsstr": "", "args": [], "nargs": 0, "vfindex": 5}, {"comments": "Only use this member if you need to check ownership of another game related to yours, a demo for example", "retval": "bool", "name": "BIsSubscribedApp", "argsstr": "AppId_t appID", "nargs": 1, "args": [["AppId_t", "appID"]], "vfindex": 6}, {"comments": "Takes AppID of DLC and checks if the user owns the DLC & if the DLC is installed", "retval": "bool", "name": "BIsDlcInstalled", "argsstr": "AppId_t appID", "nargs": 1, "args": [["AppId_t", "appID"]], "vfindex": 7}, {"comments": "Returns the Unix time of the purchase of the app", "retval": "uint32", "name": "GetEarliestPurchaseUnixTime", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 8}, {"comments": "Checks if the user is subscribed to the current app through a free weekend\n This function will return false for users who have a retail or other type of license\n Before using, please ask your Valve technical contact how to package and secure your free weekened", "retval": "bool", "name": "BIsSubscribedFromFreeWeekend", "argsstr": "", "args": [], "nargs": 0, "vfindex": 9}, {"comments": "Returns the number of DLC pieces for the running app", "retval": "int", "name": "GetDLCCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 10}, {"comments": "Returns metadata for DLC by index, of range [0, GetDLCCount()]", "retval": "bool", "name": "BGetDLCDataByIndex", "argsstr": "int iDLC, AppId_t *pAppID, bool *pbAvailable, char *pchName, int cchNameBufferSize", "nargs": 5, "args": [["int", "iDLC"], ["AppId_t*", "pAppID"], ["bool*", "pbAvailable"], ["char*", "pchName"], ["int", "cchNameBufferSize"]], "vfindex": 11}, {"comments": "Install/Uninstall control for optional DLC", "retval": "void", "name": "InstallDLC", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 12}, {"retval": "void", "name": "UninstallDLC", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 13}, {"comments": "Request legacy cd-key for yourself or owned DLC. If you are interested in this\n data then make sure you provide us with a list of valid keys to be distributed\n to users when they purchase the game, before the game ships.\n You'll receive an AppProofOfPurchaseKeyResponse_t callback when\n the key is available (which may be immediately).", "retval": "void", "name": "RequestAppProofOfPurchaseKey", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 14}, {"retval": "bool", "name": "GetCurrentBetaName", "argsstr": "char *pchName, int cchNameBufferSize", "nargs": 2, "args": [["char*", "pchName"], ["int", "cchNameBufferSize"]], "vfindex": 15}, {"comments": "Returns current beta branch name, 'public' is the default branch", "retval": "bool", "name": "MarkContentCorrupt", "argsstr": "bool bMissingFilesOnly", "nargs": 1, "args": [["bool", "bMissingFilesOnly"]], "vfindex": 16}, {"comments": "Signal Steam that game files seems corrupt or missing", "retval": "uint32", "name": "GetInstalledDepots", "argsstr": "AppId_t appID, DepotId_t *pvecDepots, uint32 cMaxDepots", "nargs": 3, "args": [["AppId_t", "appID"], ["DepotId_t*", "pvecDepots"], ["uint32", "cMaxDepots"]], "vfindex": 17}, {"comments": "Return installed depots in mount order\n\n returns current app install folder for AppID, returns folder name length", "retval": "uint32", "name": "GetAppInstallDir", "argsstr": "AppId_t appID, char *pchFolder, uint32 cchFolderBufferSize", "nargs": 3, "args": [["AppId_t", "appID"], ["char*", "pchFolder"], ["uint32", "cchFolderBufferSize"]], "vfindex": 18}, {"retval": "bool", "name": "BIsAppInstalled", "argsstr": "AppId_t appID", "nargs": 1, "args": [["AppId_t", "appID"]], "vfindex": 19}, {"comments": "Returns true if that app is installed (not necessarily owned)", "retval": "CSteamID", "name": "GetAppOwner", "argsstr": "", "args": [], "nargs": 0, "vfindex": 20}, {"comments": "Returns the SteamID of the original owner. If different from current user, it's borrowed\n\n Returns the associated launch param if the game is run via steam:run/<appid>?param1=value1;param2=value2;param3=value3 etc.\n Parameter names starting with the character '@' are reserved for internal use and will always return and empty string.\n Parameter names starting with an underscore '_' are reserved for steam features -- they can be queried by the game,\n but it is advised that you not param names beginning with an underscore for your own features.", "retval": "const char *", "name": "GetLaunchQueryParam", "argsstr": "const char *pchKey", "nargs": 1, "args": [["constchar*", "pchKey"]], "vfindex": 21}, {"comments": "Get download progress for optional DLC", "retval": "bool", "name": "GetDlcDownloadProgress", "argsstr": "AppId_t nAppID, uint64 *punBytesDownloaded, uint64 *punBytesTotal", "nargs": 3, "args": [["AppId_t", "nAppID"], ["uint64*", "punBytesDownloaded"], ["uint64*", "punBytesTotal"]], "vfindex": 22}, {"comments": "Return the buildid of this app, may change at any time based on backend updates to the game", "retval": "int", "name": "GetAppBuildId", "argsstr": "", "args": [], "nargs": 0, "vfindex": 23}, {"comments": "Request all proof of purchase keys for the calling appid and asociated DLC.\n A series of AppProofOfPurchaseKeyResponse_t callbacks will be sent with\n appropriate appid values, ending with a final callback where the m_nAppId\n member is k_uAppIdInvalid (zero).", "retval": "void", "name": "RequestAllProofOfPurchaseKeys", "argsstr": "", "args": [], "nargs": 0, "vfindex": 24}, {"retval": "SteamAPICall_t", "name": "GetFileDetails", "argsstr": "const char* pszFileName", "nargs": 1, "args": [["constchar*", "pszFileName"]], "vfindex": 25}], "cppinterface": "STEAMAPPS_INTERFACE_VERSION", "cppinterfacev": "STEAMAPPS_INTERFACE_VERSION008", "cppclass": "ISteamApps"}, "ISteamAppTicket": {"funcs": [{"retval": "uint32", "name": "GetAppOwnershipTicketData", "argsstr": "uint32 nAppID, void *pvBuffer, uint32 cbBufferLength, uint32 *piAppId, uint32 *piSteamId, uint32 *piSignature, uint32 *pcbSignature", "nargs": 7, "args": [["uint32", "nAppID"], ["void*", "pvBuffer"], ["uint32", "cbBufferLength"], ["uint32*", "piAppId"], ["uint32*", "piSteamId"], ["uint32*", "piSignature"], ["uint32*", "pcbSignature"]], "vfindex": 0}], "cppinterface": "STEAMAPPTICKET_INTERFACE_VERSION", "cppinterfacev": "STEAMAPPTICKET_INTERFACE_VERSION001", "cppclass": "ISteamAppTicket"}, "ISteamClient": {"funcs": [{"comments": "Creates a communication pipe to the Steam client.\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling", "retval": "HSteamPipe", "name": "CreateSteamPipe", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"comments": "Releases a previously created communications pipe\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling", "retval": "bool", "name": "BReleaseSteamPipe", "argsstr": "HSteamPipe hSteamPipe", "nargs": 1, "args": [["HSteamPipe", "hSteamPipe"]], "vfindex": 1}, {"comments": "Connects to an existing global user, failing if none exists\n used by the game to coordinate with the steamUI\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling", "retval": "HSteamUser", "name": "ConnectToGlobalUser", "argsstr": "HSteamPipe hSteamPipe", "nargs": 1, "args": [["HSteamPipe", "hSteamPipe"]], "vfindex": 2}, {"comments": "Used by game servers, create a steam user that won't be shared with anyone else\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling", "retval": "HSteamUser", "name": "CreateLocalUser", "argsstr": "HSteamPipe *phSteamPipe, EAccountType eAccountType", "nargs": 2, "args": [["HSteamPipe*", "phSteamPipe"], ["EAccountType", "eAccountType"]], "vfindex": 3}, {"comments": "Removes an allocated user\n NOT THREADSAFE - ensure that no other threads are accessing Steamworks API when calling", "retval": "void", "name": "ReleaseUser", "argsstr": "HSteamPipe hSteamPipe, HSteamUser hUser", "nargs": 2, "args": [["HSteamPipe", "hSteamPipe"], ["HSteamUser", "hUser"]], "vfindex": 4}, {"comments": "Retrieves the ISteamUser interface associated with the handle", "retval": "ISteamUser *", "name": "GetISteamUser", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 5}, {"comments": "Retrieves the ISteamGameServer interface associated with the handle", "retval": "ISteamGameServer *", "name": "GetISteamGameServer", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 6}, {"comments": "Set the local IP and Port to bind to\n this must be set before CreateLocalUser()", "retval": "void", "name": "SetLocalIPBinding", "argsstr": "uint32 unIP, uint16 usPort", "nargs": 2, "args": [["uint32", "unIP"], ["uint16", "usPort"]], "vfindex": 7}, {"comments": "Returns the ISteamFriends interface", "retval": "ISteamFriends *", "name": "GetISteamFriends", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 8}, {"comments": "Returns the ISteamUtils interface", "retval": "ISteamUtils *", "name": "GetISteamUtils", "argsstr": "HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 2, "args": [["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 9}, {"comments": "Returns the ISteamMatchmaking interface", "retval": "ISteamMatchmaking *", "name": "GetISteamMatchmaking", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 10}, {"comments": "Returns the ISteamMatchmakingServers interface", "retval": "ISteamMatchmakingServers *", "name": "GetISteamMatchmakingServers", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 11}, {"comments": "Returns the a generic interface", "retval": "void *", "name": "GetISteamGenericInterface", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 12}, {"comments": "Returns the ISteamUserStats interface", "retval": "ISteamUserStats *", "name": "GetISteamUserStats", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 13}, {"comments": "Returns the ISteamGameServerStats interface", "retval": "ISteamGameServerStats *", "name": "GetISteamGameServerStats", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 14}, {"comments": "Returns apps interface", "retval": "ISteamApps *", "name": "GetISteamApps", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 15}, {"comments": "Networking", "retval": "ISteamNetworking *", "name": "GetISteamNetworking", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 16}, {"comments": "Remote storage", "retval": "ISteamRemoteStorage *", "name": "GetISteamRemoteStorage", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 17}, {"comments": "User screenshots", "retval": "ISteamScreenshots *", "name": "GetISteamScreenshots", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 18}, {"comments": "Deprecated. Applications should use SteamAPI_RunCallbacks() or SteamGameServer_RunCallbacks() instead.\nSTEAM_PRIVATE_API(", "retval": "void", "name": "RunFrame", "argsstr": "", "args": [], "nargs": 0, "vfindex": 19}, {"comments": "Returns the number of IPC calls made since the last time this function was called\n Used for perf debugging so you can understand how many IPC calls your game makes per frame\n Every IPC call is at minimum a thread context switch if not a process one so you want to rate\n control how often you do them.", "retval": "uint32", "name": "GetIPCCallCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 20}, {"comments": "API warning handling\n 'int' is the severity; 0 for msg, 1 for warning\n 'const char *' is the text of the message\n callbacks will occur directly after the API function is called that generated the warning or message.", "retval": "void", "name": "SetWarningMessageHook", "argsstr": "SteamAPIWarningMessageHook_t pFunction", "nargs": 1, "args": [["SteamAPIWarningMessageHook_t", "pFunction"]], "vfindex": 21}, {"comments": "Trigger global shutdown for the DLL", "retval": "bool", "name": "BShutdownIfAllPipesClosed", "argsstr": "", "args": [], "nargs": 0, "vfindex": 22}, {"comments": "Expose HTTP interface", "retval": "ISteamHTTP *", "name": "GetISteamHTTP", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 23}, {"comments": "Deprecated - the ISteamUnifiedMessages interface is no longer intended for public consumption.\nSTEAM_PRIVATE_API(", "retval": "void *", "name": "DEPRECATED_GetISteamUnifiedMessages", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 24}, {"comments": "Exposes the ISteamController interface", "retval": "ISteamController *", "name": "GetISteamController", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 25}, {"comments": "Exposes the ISteamUGC interface", "retval": "ISteamUGC *", "name": "GetISteamUGC", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 26}, {"comments": "Returns app list interface, only available on specially registered apps", "retval": "ISteamAppList *", "name": "GetISteamAppList", "argsstr": "HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamUser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 27}, {"comments": "Music Player", "retval": "ISteamMusic *", "name": "GetISteamMusic", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 28}, {"comments": "Music Player Remote", "retval": "ISteamMusicRemote *", "name": "GetISteamMusicRemote", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 29}, {"comments": "Html page display", "retval": "ISteamHTMLSurface *", "name": "GetISteamHTMLSurface", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 30}, {"comments": "Helper functions for internal Steam usage\nSTEAM_PRIVATE_API(", "retval": "void", "name": "DEPRECATED_Set_SteamAPI_CPostAPIResultInProcess", "argsstr": "void (*", "nargs": 1, "args": [["void", "(*"]], "vfindex": 31}, {"retval": "void", "name": "DEPRECATED_Remove_SteamAPI_CPostAPIResultInProcess", "argsstr": "void (*", "nargs": 1, "args": [["void", "(*"]], "vfindex": 32}, {"retval": "void", "name": "Set_SteamAPI_CCheckCallbackRegisteredInProcess", "argsstr": "SteamAPI_CheckCallbackRegistered_t func", "nargs": 1, "args": [["SteamAPI_CheckCallbackRegistered_t", "func"]], "vfindex": 33}, {"comments": "Inventory", "retval": "ISteamInventory *", "name": "GetISteamInventory", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 34}, {"comments": "Video", "retval": "ISteamVideo *", "name": "GetISteamVideo", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 35}, {"comments": "Parental controls", "retval": "ISteamParentalSettings *", "name": "GetISteamParentalSettings", "argsstr": "HSteamUser hSteamuser, HSteamPipe hSteamPipe, const char *pchVersion", "nargs": 3, "args": [["HSteamUser", "hSteamuser"], ["HSteamPipe", "hSteamPipe"], ["constchar*", "pchVersion"]], "vfindex": 36}], "cppinterface": null, "cppinterfacev": null, "cppclass": "ISteamClient"}, "ISteamController": {"funcs": [{"comments": "Init and Shutdown must be called when starting/ending use of this interface", "retval": "bool", "name": "Init", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "bool", "name": "Shutdown", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"comments": "Synchronize API state with the latest Steam Controller inputs available. This\n is performed automatically by SteamAPI_RunCallbacks, but for the absolute lowest\n possible latency, you call this directly before reading controller state.", "retval": "void", "name": "RunFrame", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "Enumerate currently connected controllers\n handlesOut should point to a STEAM_CONTROLLER_MAX_COUNT sized array of ControllerHandle_t handles\n Returns the number of handles written to handlesOut", "retval": "int", "name": "GetConnectedControllers", "argsstr": "ControllerHandle_t *handlesOut", "nargs": 1, "args": [["ControllerHandle_t*", "handlesOut"]], "vfindex": 3}, {"comments": "Invokes the Steam overlay and brings up the binding screen\n Returns false is overlay is disabled / unavailable, or the user is not in Big Picture mode", "retval": "bool", "name": "ShowBindingPanel", "argsstr": "ControllerHandle_t controllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "controllerHandle"]], "vfindex": 4}, {"comments": "ACTION SETS\n Lookup the handle for an Action Set. Best to do this once on startup, and store the handles for all future API calls.", "retval": "ControllerActionSetHandle_t", "name": "GetActionSetHandle", "argsstr": "const char *pszActionSetName", "nargs": 1, "args": [["constchar*", "pszActionSetName"]], "vfindex": 5}, {"comments": "Reconfigure the controller to use the specified action set (ie 'Menu', 'Walk' or 'Drive')\n This is cheap, and can be safely called repeatedly. It's often easier to repeatedly call it in\n your state loops, instead of trying to place it in all of your state transitions.", "retval": "void", "name": "ActivateActionSet", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t", "actionSetHandle"]], "vfindex": 6}, {"retval": "ControllerActionSetHandle_t", "name": "GetCurrentActionSet", "argsstr": "ControllerHandle_t controllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "controllerHandle"]], "vfindex": 7}, {"retval": "void", "name": "ActivateActionSetLayer", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t", "actionSetLayerHandle"]], "vfindex": 8}, {"retval": "void", "name": "DeactivateActionSetLayer", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetLayerHandle", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t", "actionSetLayerHandle"]], "vfindex": 9}, {"retval": "void", "name": "DeactivateAllActionSetLayers", "argsstr": "ControllerHandle_t controllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "controllerHandle"]], "vfindex": 10}, {"retval": "int", "name": "GetActiveActionSetLayers", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t *handlesOut", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t*", "handlesOut"]], "vfindex": 11}, {"comments": "ACTIONS\n Lookup the handle for a digital action. Best to do this once on startup, and store the handles for all future API calls.", "retval": "ControllerDigitalActionHandle_t", "name": "GetDigitalActionHandle", "argsstr": "const char *pszActionName", "nargs": 1, "args": [["constchar*", "pszActionName"]], "vfindex": 12}, {"comments": "Returns the current state of the supplied digital game action", "retval": "ControllerDigitalActionData_t", "name": "GetDigitalActionData", "argsstr": "ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerDigitalActionHandle_t", "digitalActionHandle"]], "vfindex": 13}, {"comments": "Get the origin(s) for a digital action within an action set. Returns the number of origins supplied in originsOut. Use this to display the appropriate on-screen prompt for the action.\n originsOut should point to a STEAM_CONTROLLER_MAX_ORIGINS sized array of EControllerActionOrigin handles", "retval": "int", "name": "GetDigitalActionOrigins", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerDigitalActionHandle_t digitalActionHandle, EControllerActionOrigin *originsOut", "nargs": 4, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t", "actionSetHandle"], ["ControllerDigitalActionHandle_t", "digitalActionHandle"], ["EControllerActionOrigin*", "originsOut"]], "vfindex": 14}, {"comments": "Lookup the handle for an analog action. Best to do this once on startup, and store the handles for all future API calls.", "retval": "ControllerAnalogActionHandle_t", "name": "GetAnalogActionHandle", "argsstr": "const char *pszActionName", "nargs": 1, "args": [["constchar*", "pszActionName"]], "vfindex": 15}, {"comments": "Returns the current state of these supplied analog game action", "retval": "ControllerAnalogActionData_t", "name": "GetAnalogActionData", "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerAnalogActionHandle_t", "analogActionHandle"]], "vfindex": 16}, {"comments": "Get the origin(s) for an analog action within an action set. Returns the number of origins supplied in originsOut. Use this to display the appropriate on-screen prompt for the action.\n originsOut should point to a STEAM_CONTROLLER_MAX_ORIGINS sized array of EControllerActionOrigin handles", "retval": "int", "name": "GetAnalogActionOrigins", "argsstr": "ControllerHandle_t controllerHandle, ControllerActionSetHandle_t actionSetHandle, ControllerAnalogActionHandle_t analogActionHandle, EControllerActionOrigin *originsOut", "nargs": 4, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerActionSetHandle_t", "actionSetHandle"], ["ControllerAnalogActionHandle_t", "analogActionHandle"], ["EControllerActionOrigin*", "originsOut"]], "vfindex": 17}, {"retval": "void", "name": "StopAnalogActionMomentum", "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t eAction", "nargs": 2, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerAnalogActionHandle_t", "eAction"]], "vfindex": 18}, {"comments": "Trigger a haptic pulse on a controller", "retval": "void", "name": "TriggerHapticPulse", "argsstr": "ControllerHandle_t controllerHandle, ESteamControllerPad eTargetPad, unsigned short usDurationMicroSec", "nargs": 3, "args": [["ControllerHandle_t", "controllerHandle"], ["ESteamControllerPad", "eTargetPad"], ["unsignedshort", "usDurationMicroSec"]], "vfindex": 19}, {"comments": "Trigger a pulse with a duty cycle of usDurationMicroSec / usOffMicroSec, unRepeat times.\n nFlags is currently unused and reserved for future use.", "retval": "void", "name": "TriggerRepeatedHapticPulse", "argsstr": "ControllerHandle_t controllerHandle, ESteamControllerPad eTargetPad, unsigned short usDurationMicroSec, unsigned short usOffMicroSec, unsigned short unRepeat, unsigned int nFlags", "nargs": 6, "args": [["ControllerHandle_t", "controllerHandle"], ["ESteamControllerPad", "eTargetPad"], ["unsignedshort", "usDurationMicroSec"], ["unsignedshort", "usOffMicroSec"], ["unsignedshort", "unRepeat"], ["unsignedint", "nFlags"]], "vfindex": 20}, {"comments": "Tigger a vibration event on supported controllers.", "retval": "void", "name": "TriggerVibration", "argsstr": "ControllerHandle_t controllerHandle, unsigned short usLeftSpeed, unsigned short usRightSpeed", "nargs": 3, "args": [["ControllerHandle_t", "controllerHandle"], ["unsignedshort", "usLeftSpeed"], ["unsignedshort", "usRightSpeed"]], "vfindex": 21}, {"comments": "Set the controller LED color on supported controllers.", "retval": "void", "name": "SetLEDColor", "argsstr": "ControllerHandle_t controllerHandle, uint8 nColorR, uint8 nColorG, uint8 nColorB, unsigned int nFlags", "nargs": 5, "args": [["ControllerHandle_t", "controllerHandle"], ["uint8", "nColorR"], ["uint8", "nColorG"], ["uint8", "nColorB"], ["unsignedint", "nFlags"]], "vfindex": 22}, {"comments": "Returns the associated gamepad index for the specified controller, if emulating a gamepad", "retval": "int", "name": "GetGamepadIndexForController", "argsstr": "ControllerHandle_t ulControllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "ulControllerHandle"]], "vfindex": 23}, {"comments": "Returns the associated controller handle for the specified emulated gamepad", "retval": "ControllerHandle_t", "name": "GetControllerForGamepadIndex", "argsstr": "int nIndex", "nargs": 1, "args": [["int", "nIndex"]], "vfindex": 24}, {"comments": "Returns raw motion data from the specified controller", "retval": "ControllerMotionData_t", "name": "GetMotionData", "argsstr": "ControllerHandle_t controllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "controllerHandle"]], "vfindex": 25}, {"comments": "Attempt to display origins of given action in the controller HUD, for the currently active action set\n Returns false is overlay is disabled / unavailable, or the user is not in Big Picture mode", "retval": "bool", "name": "ShowDigitalActionOrigins", "argsstr": "ControllerHandle_t controllerHandle, ControllerDigitalActionHandle_t digitalActionHandle, float flScale, float flXPosition, float flYPosition", "nargs": 5, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerDigitalActionHandle_t", "digitalActionHandle"], ["float", "flScale"], ["float", "flXPosition"], ["float", "flYPosition"]], "vfindex": 26}, {"retval": "bool", "name": "ShowAnalogActionOrigins", "argsstr": "ControllerHandle_t controllerHandle, ControllerAnalogActionHandle_t analogActionHandle, float flScale, float flXPosition, float flYPosition", "nargs": 5, "args": [["ControllerHandle_t", "controllerHandle"], ["ControllerAnalogActionHandle_t", "analogActionHandle"], ["float", "flScale"], ["float", "flXPosition"], ["float", "flYPosition"]], "vfindex": 27}, {"comments": "Returns a localized string (from Steam's language setting) for the specified origin", "retval": "const char *", "name": "GetStringForActionOrigin", "argsstr": "EControllerActionOrigin eOrigin", "nargs": 1, "args": [["EControllerActionOrigin", "eOrigin"]], "vfindex": 28}, {"comments": "Get a local path to art for on-screen glyph for a particular origin", "retval": "const char *", "name": "GetGlyphForActionOrigin", "argsstr": "EControllerActionOrigin eOrigin", "nargs": 1, "args": [["EControllerActionOrigin", "eOrigin"]], "vfindex": 29}, {"comments": "Returns the input type for a particular handle", "retval": "ESteamInputType", "name": "GetInputTypeForHandle", "argsstr": "ControllerHandle_t controllerHandle", "nargs": 1, "args": [["ControllerHandle_t", "controllerHandle"]], "vfindex": 30}], "cppinterface": "STEAMCONTROLLER_INTERFACE_VERSION", "cppinterfacev": "SteamController006", "cppclass": "ISteamController"}, "ISteamFriends": {"funcs": [{"comments": "Returns the local players name - guaranteed to not be NULL.\n this is the same name as on the users community profile page\n this is stored in UTF-8 format\n like all the other interface functions that return a char *, it's important that this pointer is not saved\n off; it will eventually be free'd or re-allocated", "retval": "const char *", "name": "GetPersonaName", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"comments": "Sets the player name, stores it on the server and publishes the changes to all friends who are online.\n Changes take place locally immediately, and a PersonaStateChange_t is posted, presuming success.\n\n The final results are available through the return value SteamAPICall_t, using SetPersonaNameResponse_t.\n\n If the name change fails to happen on the server, then an additional global PersonaStateChange_t will be posted\n to change the name back, in addition to the SetPersonaNameResponse_t callback.\nCALL_RESULT( SetPersonaNameResponse_t )", "retval": "SteamAPICall_t", "name": "SetPersonaName", "argsstr": "const char *pchPersonaName", "nargs": 1, "args": [["constchar*", "pchPersonaName"]], "vfindex": 1}, {"comments": "Gets the status of the current user", "retval": "EPersonaState", "name": "GetPersonaState", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "Friend iteration\n takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria\n then GetFriendByIndex() can then be used to return the id's of each of those users", "retval": "int", "name": "GetFriendCount", "argsstr": "int iFriendFlags", "nargs": 1, "args": [["int", "iFriendFlags"]], "vfindex": 3}, {"comments": "Returns the steamID of a user\n iFriend is a index of range [0, GetFriendCount())\n iFriendsFlags must be the same value as used in GetFriendCount()\n the returned CSteamID can then be used by all the functions below to access details about the user", "retval": "CSteamID", "name": "GetFriendByIndex", "argsstr": "int iFriend, int iFriendFlags", "nargs": 2, "args": [["int", "iFriend"], ["int", "iFriendFlags"]], "vfindex": 4}, {"comments": "Returns a relationship to a user", "retval": "EFriendRelationship", "name": "GetFriendRelationship", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 5}, {"comments": "Returns the current status of the specified user\n this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user", "retval": "EPersonaState", "name": "GetFriendPersonaState", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 6}, {"comments": "Returns the name another user - guaranteed to not be NULL.\n same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user\n note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously", "retval": "const char *", "name": "GetFriendPersonaName", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 7}, {"comments": "Returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details", "retval": "bool", "name": "GetFriendGamePlayed", "argsstr": "CSteamID steamIDFriend,  FriendGameInfo_t *pFriendGameInfo", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["FriendGameInfo_t*", "pFriendGameInfo"]], "vfindex": 8}, {"comments": "Accesses old friends names - returns an empty string when their are no more items in the history", "retval": "const char *", "name": "GetFriendPersonaNameHistory", "argsstr": "CSteamID steamIDFriend, int iPersonaName", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["int", "iPersonaName"]], "vfindex": 9}, {"comments": "Friends steam level", "retval": "int", "name": "GetFriendSteamLevel", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 10}, {"comments": "Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.", "retval": "const char *", "name": "GetPlayerNickname", "argsstr": "CSteamID steamIDPlayer", "nargs": 1, "args": [["CSteamID", "steamIDPlayer"]], "vfindex": 11}, {"comments": "Friend grouping (tag) apis\n returns the number of friends groups", "retval": "int", "name": "GetFriendsGroupCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 12}, {"comments": "Returns the friends group ID for the given index (invalid indices return k_FriendsGroupID_Invalid)", "retval": "FriendsGroupID_t", "name": "GetFriendsGroupIDByIndex", "argsstr": "int iFG", "nargs": 1, "args": [["int", "iFG"]], "vfindex": 13}, {"comments": "Returns the name for the given friends group (NULL in the case of invalid friends group IDs)", "retval": "const char *", "name": "GetFriendsGroupName", "argsstr": "FriendsGroupID_t friendsGroupID", "nargs": 1, "args": [["FriendsGroupID_t", "friendsGroupID"]], "vfindex": 14}, {"comments": "Returns the number of members in a given friends group", "retval": "int", "name": "GetFriendsGroupMembersCount", "argsstr": "FriendsGroupID_t friendsGroupID", "nargs": 1, "args": [["FriendsGroupID_t", "friendsGroupID"]], "vfindex": 15}, {"comments": "Gets up to nMembersCount members of the given friends group, if fewer exist than requested those positions' SteamIDs will be invalid", "retval": "void", "name": "GetFriendsGroupMembersList", "argsstr": "FriendsGroupID_t friendsGroupID,  CSteamID *pOutSteamIDMembers, int nMembersCount", "nargs": 3, "args": [["FriendsGroupID_t", "friendsGroupID"], ["CSteamID*", "pOutSteamIDMembers"], ["int", "nMembersCount"]], "vfindex": 16}, {"comments": "Returns true if the specified user meets any of the criteria specified in iFriendFlags\n iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values", "retval": "bool", "name": "HasFriend", "argsstr": "CSteamID steamIDFriend, int iFriendFlags", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["int", "iFriendFlags"]], "vfindex": 17}, {"comments": "Clan (group) iteration and access functions", "retval": "int", "name": "GetClanCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 18}, {"retval": "CSteamID", "name": "GetClanByIndex", "argsstr": "int iClan", "nargs": 1, "args": [["int", "iClan"]], "vfindex": 19}, {"retval": "const char *", "name": "GetClanName", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 20}, {"retval": "const char *", "name": "GetClanTag", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 21}, {"comments": "Returns the most recent information we have about what's happening in a clan", "retval": "bool", "name": "GetClanActivityCounts", "argsstr": "CSteamID steamIDClan, int *pnOnline, int *pnInGame, int *pnChatting", "nargs": 4, "args": [["CSteamID", "steamIDClan"], ["int*", "pnOnline"], ["int*", "pnInGame"], ["int*", "pnChatting"]], "vfindex": 22}, {"comments": "For clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest", "retval": "SteamAPICall_t", "name": "DownloadClanActivityCounts", "argsstr": "CSteamID *psteamIDClans, int cClansToRequest", "nargs": 2, "args": [["CSteamID*", "psteamIDClans"], ["int", "cClansToRequest"]], "vfindex": 23}, {"comments": "Iterators for getting users in a chat room, lobby, game server or clan\n note that large clans that cannot be iterated by the local user\n note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby\n steamIDSource can be the steamID of a group, game server, lobby or chat room", "retval": "int", "name": "GetFriendCountFromSource", "argsstr": "CSteamID steamIDSource", "nargs": 1, "args": [["CSteamID", "steamIDSource"]], "vfindex": 24}, {"retval": "CSteamID", "name": "GetFriendFromSourceByIndex", "argsstr": "CSteamID steamIDSource, int iFriend", "nargs": 2, "args": [["CSteamID", "steamIDSource"], ["int", "iFriend"]], "vfindex": 25}, {"comments": "Returns true if the local user can see that steamIDUser is a member or in steamIDSource", "retval": "bool", "name": "IsUserInSource", "argsstr": "CSteamID steamIDUser, CSteamID steamIDSource", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["CSteamID", "steamIDSource"]], "vfindex": 26}, {"comments": "User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)", "retval": "void", "name": "SetInGameVoiceSpeaking", "argsstr": "CSteamID steamIDUser, bool bSpeaking", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["bool", "bSpeaking"]], "vfindex": 27}, {"comments": "Activates the game overlay, with an optional dialog to open \n valid options are \"Friends\", \"Community\", \"Players\", \"Settings\", \"OfficialGameGroup\", \"Stats\", \"Achievements\"", "retval": "void", "name": "ActivateGameOverlay", "argsstr": "const char *pchDialog", "nargs": 1, "args": [["constchar*", "pchDialog"]], "vfindex": 28}, {"comments": "Activates game overlay to a specific place\n valid options are\n\"steamid\" - opens the overlay web browser to the specified user or groups profile\n\"chat\" - opens a chat window to the specified user, or joins the group chat \n\"jointrade\" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API\n\"stats\" - opens the overlay web browser to the specified user's stats\n\"achievements\" - opens the overlay web browser to the specified user's achievements\n\"friendadd\" - opens the overlay in minimal mode prompting the user to add the target user as a friend\n\"friendremove\" - opens the overlay in minimal mode prompting the user to remove the target friend\n\"friendrequestaccept\" - opens the overlay in minimal mode prompting the user to accept an incoming friend invite\n\"friendrequestignore\" - opens the overlay in minimal mode prompting the user to ignore an incoming friend invite", "retval": "void", "name": "ActivateGameOverlayToUser", "argsstr": "const char *pchDialog, CSteamID steamID", "nargs": 2, "args": [["constchar*", "pchDialog"], ["CSteamID", "steamID"]], "vfindex": 29}, {"comments": "Activates game overlay web browser directly to the specified URL\n full address with protocol type is required, e.g. http:www.steamgames.com/", "retval": "void", "name": "ActivateGameOverlayToWebPage", "argsstr": "const char *pchURL", "nargs": 1, "args": [["constchar*", "pchURL"]], "vfindex": 30}, {"comments": "Activates game overlay to store page for app", "retval": "void", "name": "ActivateGameOverlayToStore", "argsstr": "AppId_t nAppID, EOverlayToStoreFlag eFlag", "nargs": 2, "args": [["AppId_t", "nAppID"], ["EOverlayToStoreFlag", "eFlag"]], "vfindex": 31}, {"comments": "Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is \n in game", "retval": "void", "name": "SetPlayedWith", "argsstr": "CSteamID steamIDUserPlayedWith", "nargs": 1, "args": [["CSteamID", "steamIDUserPlayedWith"]], "vfindex": 32}, {"comments": "Activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.", "retval": "void", "name": "ActivateGameOverlayInviteDialog", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 33}, {"comments": "Gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set", "retval": "int", "name": "GetSmallFriendAvatar", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 34}, {"comments": "Gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set", "retval": "int", "name": "GetMediumFriendAvatar", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 35}, {"comments": "Gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set\n returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again", "retval": "int", "name": "GetLargeFriendAvatar", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 36}, {"comments": "Requests information about a user - persona name & avatar\n if bRequireNameOnly is set, then the avatar of a user isn't downloaded \n - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them\n if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved\n if returns false, it means that we already have all the details about that user, and functions can be called immediately", "retval": "bool", "name": "RequestUserInformation", "argsstr": "CSteamID steamIDUser, bool bRequireNameOnly", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["bool", "bRequireNameOnly"]], "vfindex": 37}, {"comments": "Requests information about a clan officer list\n when complete, data is returned in ClanOfficerListResponse_t call result\n this makes available the calls below\n you can only ask about clans that a user is a member of\n note that this won't download avatars automatically; if you get an officer,\n and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar\nCALL_RESULT( ClanOfficerListResponse_t )", "retval": "SteamAPICall_t", "name": "RequestClanOfficerList", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 38}, {"comments": "Iteration of clan officers - can only be done when a RequestClanOfficerList() call has completed\n\n returns the steamID of the clan owner", "retval": "CSteamID", "name": "GetClanOwner", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 39}, {"comments": "Returns the number of officers in a clan (including the owner)", "retval": "int", "name": "GetClanOfficerCount", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 40}, {"comments": "Returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)", "retval": "CSteamID", "name": "GetClanOfficerByIndex", "argsstr": "CSteamID steamIDClan, int iOfficer", "nargs": 2, "args": [["CSteamID", "steamIDClan"], ["int", "iOfficer"]], "vfindex": 41}, {"comments": "If current user is chat restricted, he can't send or receive any text/voice chat messages.\n the user can't see custom avatars. But the user can be online and send/recv game invites.\n a chat restricted user can't add friends or join any groups.", "retval": "uint32", "name": "GetUserRestrictions", "argsstr": "", "args": [], "nargs": 0, "vfindex": 42}, {"comments": "Rich Presence data is automatically shared between friends who are in the same game\n Each user has a set of Key/Value pairs\n Note the following limits: k_cchMaxRichPresenceKeys, k_cchMaxRichPresenceKeyLength, k_cchMaxRichPresenceValueLength\n There are two magic keys:\n\"status\"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list\n\"connect\" - a UTF-8 string that contains the command-line for how a friend can connect to a game\n GetFriendRichPresence() returns an empty string \"\" if no value is set\n SetRichPresence() to a NULL or an empty string deletes the key\n You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()\n and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)", "retval": "bool", "name": "SetRichPresence", "argsstr": "const char *pchKey, const char *pchValue", "nargs": 2, "args": [["constchar*", "pchKey"], ["constchar*", "pchValue"]], "vfindex": 43}, {"retval": "void", "name": "ClearRichPresence", "argsstr": "", "args": [], "nargs": 0, "vfindex": 44}, {"retval": "const char *", "name": "GetFriendRichPresence", "argsstr": "CSteamID steamIDFriend, const char *pchKey", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["constchar*", "pchKey"]], "vfindex": 45}, {"retval": "int", "name": "GetFriendRichPresenceKeyCount", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 46}, {"retval": "const char *", "name": "GetFriendRichPresenceKeyByIndex", "argsstr": "CSteamID steamIDFriend, int iKey", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["int", "iKey"]], "vfindex": 47}, {"comments": "Requests rich presence for a specific user.", "retval": "void", "name": "RequestFriendRichPresence", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 48}, {"comments": "Rich invite support\n if the target accepts the invite, the pchConnectString gets added to the command-line for launching the game\n if the game is already running, a GameRichPresenceJoinRequested_t callback is posted containing the connect string\n invites can only be sent to friends", "retval": "bool", "name": "InviteUserToGame", "argsstr": "CSteamID steamIDFriend, const char *pchConnectString", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["constchar*", "pchConnectString"]], "vfindex": 49}, {"comments": "Recently-played-with friends iteration\n this iterates the entire list of users recently played with, across games\n GetFriendCoplayTime() returns as a unix time", "retval": "int", "name": "GetCoplayFriendCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 50}, {"retval": "CSteamID", "name": "GetCoplayFriend", "argsstr": "int iCoplayFriend", "nargs": 1, "args": [["int", "iCoplayFriend"]], "vfindex": 51}, {"retval": "int", "name": "GetFriendCoplayTime", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 52}, {"retval": "AppId_t", "name": "GetFriendCoplayGame", "argsstr": "CSteamID steamIDFriend", "nargs": 1, "args": [["CSteamID", "steamIDFriend"]], "vfindex": 53}, {"comments": "Chat interface for games\n this allows in-game access to group (clan) chats from in the game\n the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay\n use ActivateGameOverlayToUser( \"chat\", steamIDClan ) to open the in-game overlay version of the chat\nCALL_RESULT( JoinClanChatRoomCompletionResult_t )", "retval": "SteamAPICall_t", "name": "JoinClanChatRoom", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 54}, {"retval": "bool", "name": "LeaveClanChatRoom", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 55}, {"retval": "int", "name": "GetClanChatMemberCount", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 56}, {"retval": "CSteamID", "name": "GetChatMemberByIndex", "argsstr": "CSteamID steamIDClan, int iUser", "nargs": 2, "args": [["CSteamID", "steamIDClan"], ["int", "iUser"]], "vfindex": 57}, {"retval": "bool", "name": "SendClanChatMessage", "argsstr": "CSteamID steamIDClanChat, const char *pchText", "nargs": 2, "args": [["CSteamID", "steamIDClanChat"], ["constchar*", "pchText"]], "vfindex": 58}, {"retval": "int", "name": "GetClanChatMessage", "argsstr": "CSteamID steamIDClanChat, int iMessage, void *prgchText, int cchTextMax, EChatEntryType *peChatEntryType,  CSteamID *psteamidChatter", "nargs": 6, "args": [["CSteamID", "steamIDClanChat"], ["int", "iMessage"], ["void*", "prgchText"], ["int", "cchTextMax"], ["EChatEntryType*", "peChatEntryType"], ["CSteamID*", "psteamidChatter"]], "vfindex": 59}, {"retval": "bool", "name": "IsClanChatAdmin", "argsstr": "CSteamID steamIDClanChat, CSteamID steamIDUser", "nargs": 2, "args": [["CSteamID", "steamIDClanChat"], ["CSteamID", "steamIDUser"]], "vfindex": 60}, {"comments": "Interact with the Steam (game overlay / desktop)", "retval": "bool", "name": "IsClanChatWindowOpenInSteam", "argsstr": "CSteamID steamIDClanChat", "nargs": 1, "args": [["CSteamID", "steamIDClanChat"]], "vfindex": 61}, {"retval": "bool", "name": "OpenClanChatWindowInSteam", "argsstr": "CSteamID steamIDClanChat", "nargs": 1, "args": [["CSteamID", "steamIDClanChat"]], "vfindex": 62}, {"retval": "bool", "name": "CloseClanChatWindowInSteam", "argsstr": "CSteamID steamIDClanChat", "nargs": 1, "args": [["CSteamID", "steamIDClanChat"]], "vfindex": 63}, {"comments": "Peer-to-peer chat interception\n this is so you can show P2P chats inline in the game", "retval": "bool", "name": "SetListenForFriendsMessages", "argsstr": "bool bInterceptEnabled", "nargs": 1, "args": [["bool", "bInterceptEnabled"]], "vfindex": 64}, {"retval": "bool", "name": "ReplyToFriendMessage", "argsstr": "CSteamID steamIDFriend, const char *pchMsgToSend", "nargs": 2, "args": [["CSteamID", "steamIDFriend"], ["constchar*", "pchMsgToSend"]], "vfindex": 65}, {"retval": "int", "name": "GetFriendMessage", "argsstr": "CSteamID steamIDFriend, int iMessageID, void *pvData, int cubData, EChatEntryType *peChatEntryType", "nargs": 5, "args": [["CSteamID", "steamIDFriend"], ["int", "iMessageID"], ["void*", "pvData"], ["int", "cubData"], ["EChatEntryType*", "peChatEntryType"]], "vfindex": 66}, {"comments": "Following apis\nCALL_RESULT( FriendsGetFollowerCount_t )", "retval": "SteamAPICall_t", "name": "GetFollowerCount", "argsstr": "CSteamID steamID", "nargs": 1, "args": [["CSteamID", "steamID"]], "vfindex": 67}, {"retval": "SteamAPICall_t", "name": "IsFollowing", "argsstr": "CSteamID steamID", "nargs": 1, "args": [["CSteamID", "steamID"]], "vfindex": 68}, {"retval": "SteamAPICall_t", "name": "EnumerateFollowingList", "argsstr": "uint32 unStartIndex", "nargs": 1, "args": [["uint32", "unStartIndex"]], "vfindex": 69}, {"retval": "bool", "name": "IsClanPublic", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 70}, {"retval": "bool", "name": "IsClanOfficialGameGroup", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 71}], "cppinterface": "STEAMFRIENDS_INTERFACE_VERSION", "cppinterfacev": "SteamFriends015", "cppclass": "ISteamFriends"}, "ISteamGameCoordinator": {"funcs": [{"comments": "Sends a message to the Game Coordinator", "retval": "EGCResults", "name": "SendMessage", "argsstr": "uint32 unMsgType, const void *pubData, uint32 cubData", "nargs": 3, "args": [["uint32", "unMsgType"], ["constvoid*", "pubData"], ["uint32", "cubData"]], "vfindex": 0}, {"comments": "Returns true if there is a message waiting from the game coordinator", "retval": "bool", "name": "IsMessageAvailable", "argsstr": "uint32 *pcubMsgSize", "nargs": 1, "args": [["uint32*", "pcubMsgSize"]], "vfindex": 1}, {"comments": "Fills the provided buffer with the first message in the queue and returns k_EGCResultOK or \n returns k_EGCResultNoMessage if there is no message waiting. pcubMsgSize is filled with the message size.\n If the provided buffer is not large enough to fit the entire message, k_EGCResultBufferTooSmall is returned\n and the message remains at the head of the queue.", "retval": "EGCResults", "name": "RetrieveMessage", "argsstr": "uint32 *punMsgType, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize", "nargs": 4, "args": [["uint32*", "punMsgType"], ["void*", "pubDest"], ["uint32", "cubDest"], ["uint32*", "pcubMsgSize"]], "vfindex": 2}], "cppinterface": "STEAMGAMECOORDINATOR_INTERFACE_VERSION", "cppinterfacev": "SteamGameCoordinator001", "cppclass": "ISteamGameCoordinator"}, "ISteamGameServer": {"funcs": [{"comments": "Basic server data.  These properties, if set, must be set before before calling LogOn.  They\n may not be changed after logged in.\n\n\n/ This is called by SteamGameServer_Init, and you will usually not need to call it directly", "retval": "bool", "name": "InitGameServer", "argsstr": "uint32 unIP, uint16 usGamePort, uint16 usQueryPort, uint32 unFlags, AppId_t nGameAppId, const char *pchVersionString", "nargs": 6, "args": [["uint32", "unIP"], ["uint16", "usGamePort"], ["uint16", "usQueryPort"], ["uint32", "unFlags"], ["AppId_t", "nGameAppId"], ["constchar*", "pchVersionString"]], "vfindex": 0}, {"comments": "/ Game product identifier.  This is currently used by the master server for version checking purposes.\n/ It's a required field, but will eventually will go away, and the AppID will be used for this purpose.", "retval": "void", "name": "SetProduct", "argsstr": "const char *pszProduct", "nargs": 1, "args": [["constchar*", "pszProduct"]], "vfindex": 1}, {"comments": "/ Description of the game.  This is a required field and is displayed in the steam server browser....for now.\n/ This is a required field, but it will go away eventually, as the data should be determined from the AppID.", "retval": "void", "name": "SetGameDescription", "argsstr": "const char *pszGameDescription", "nargs": 1, "args": [["constchar*", "pszGameDescription"]], "vfindex": 2}, {"comments": "/ If your game is a \"mod,\" pass the string that identifies it.  The default is an empty string, meaning\n/ this application is the original game, not a mod.\n/\n/ @see k_cbMaxGameServerGameDir", "retval": "void", "name": "SetModDir", "argsstr": "const char *pszModDir", "nargs": 1, "args": [["constchar*", "pszModDir"]], "vfindex": 3}, {"comments": "/ Is this is a dedicated server?  The default value is false.", "retval": "void", "name": "SetDedicatedServer", "argsstr": "bool bDedicated", "nargs": 1, "args": [["bool", "bDedicated"]], "vfindex": 4}, {"comments": "Login\n\n\n/ Begin process to login to a persistent game server account\n/\n/ You need to register for callbacks to determine the result of this operation.\n/ @see SteamServersConnected_t\n/ @see SteamServerConnectFailure_t\n/ @see SteamServersDisconnected_t", "retval": "void", "name": "LogOn", "argsstr": "const char *pszToken", "nargs": 1, "args": [["constchar*", "pszToken"]], "vfindex": 5}, {"comments": "/ Login to a generic, anonymous account.\n/\n/ Note: in previous versions of the SDK, this was automatically called within SteamGameServer_Init,\n/ but this is no longer the case.", "retval": "void", "name": "LogOnAnonymous", "argsstr": "", "args": [], "nargs": 0, "vfindex": 6}, {"comments": "/ Begin process of logging game server out of steam", "retval": "void", "name": "LogOff", "argsstr": "", "args": [], "nargs": 0, "vfindex": 7}, {"comments": "Status functions", "retval": "bool", "name": "BLoggedOn", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}, {"retval": "bool", "name": "BSecure", "argsstr": "", "args": [], "nargs": 0, "vfindex": 9}, {"retval": "CSteamID", "name": "GetSteamID", "argsstr": "", "args": [], "nargs": 0, "vfindex": 10}, {"comments": "/ Returns true if the master server has requested a restart.\n/ Only returns true once per request.", "retval": "bool", "name": "WasRestartRequested", "argsstr": "", "args": [], "nargs": 0, "vfindex": 11}, {"comments": "Server state.  These properties may be changed at any time.\n\n\n/ Max player count that will be reported to server browser and client queries", "retval": "void", "name": "SetMaxPlayerCount", "argsstr": "int cPlayersMax", "nargs": 1, "args": [["int", "cPlayersMax"]], "vfindex": 12}, {"comments": "/ Number of bots.  Default value is zero", "retval": "void", "name": "SetBotPlayerCount", "argsstr": "int cBotplayers", "nargs": 1, "args": [["int", "cBotplayers"]], "vfindex": 13}, {"comments": "/ Set the name of server as it will appear in the server browser\n/\n/ @see k_cbMaxGameServerName", "retval": "void", "name": "SetServerName", "argsstr": "const char *pszServerName", "nargs": 1, "args": [["constchar*", "pszServerName"]], "vfindex": 14}, {"comments": "/ Set name of map to report in the server browser\n/\n/ @see k_cbMaxGameServerName", "retval": "void", "name": "SetMapName", "argsstr": "const char *pszMapName", "nargs": 1, "args": [["constchar*", "pszMapName"]], "vfindex": 15}, {"comments": "/ Let people know if your server will require a password", "retval": "void", "name": "SetPasswordProtected", "argsstr": "bool bPasswordProtected", "nargs": 1, "args": [["bool", "bPasswordProtected"]], "vfindex": 16}, {"comments": "/ Spectator server.  The default value is zero, meaning the service\n/ is not used.", "retval": "void", "name": "SetSpectatorPort", "argsstr": "uint16 unSpectatorPort", "nargs": 1, "args": [["uint16", "unSpectatorPort"]], "vfindex": 17}, {"comments": "/ Name of the spectator server.  (Only used if spectator port is nonzero.)\n/\n/ @see k_cbMaxGameServerMapName", "retval": "void", "name": "SetSpectatorServerName", "argsstr": "const char *pszSpectatorServerName", "nargs": 1, "args": [["constchar*", "pszSpectatorServerName"]], "vfindex": 18}, {"comments": "/ Call this to clear the whole list of key/values that are sent in rules queries.", "retval": "void", "name": "ClearAllKeyValues", "argsstr": "", "args": [], "nargs": 0, "vfindex": 19}, {"comments": "/ Call this to add/update a key/value pair.", "retval": "void", "name": "SetKeyValue", "argsstr": "const char *pKey, const char *pValue", "nargs": 2, "args": [["constchar*", "pKey"], ["constchar*", "pValue"]], "vfindex": 20}, {"comments": "/ Sets a string defining the \"gametags\" for this server, this is optional, but if it is set\n/ it allows users to filter in the matchmaking/server-browser interfaces based on the value\n/\n/ @see k_cbMaxGameServerTags", "retval": "void", "name": "SetGameTags", "argsstr": "const char *pchGameTags", "nargs": 1, "args": [["constchar*", "pchGameTags"]], "vfindex": 21}, {"comments": "/ Sets a string defining the \"gamedata\" for this server, this is optional, but if it is set\n/ it allows users to filter in the matchmaking/server-browser interfaces based on the value\n/ don't set this unless it actually changes, its only uploaded to the master once (when\n/ acknowledged)\n/\n/ @see k_cbMaxGameServerGameData", "retval": "void", "name": "SetGameData", "argsstr": "const char *pchGameData", "nargs": 1, "args": [["constchar*", "pchGameData"]], "vfindex": 22}, {"comments": "/ Region identifier.  This is an optional field, the default value is empty, meaning the \"world\" region", "retval": "void", "name": "SetRegion", "argsstr": "const char *pszRegion", "nargs": 1, "args": [["constchar*", "pszRegion"]], "vfindex": 23}, {"comments": "Player list management / authentication\n\n\n Handles receiving a new connection from a Steam user.  This call will ask the Steam\n servers to validate the users identity, app ownership, and VAC status.  If the Steam servers \n are off-line, then it will validate the cached ticket itself which will validate app ownership \n and identity.  The AuthBlob here should be acquired on the game client using SteamUser()->InitiateGameConnection()\n and must then be sent up to the game server for authentication.\n\n Return Value: returns true if the users ticket passes basic checks. pSteamIDUser will contain the Steam ID of this user. pSteamIDUser must NOT be NULL\n If the call succeeds then you should expect a GSClientApprove_t or GSClientDeny_t callback which will tell you whether authentication\n for the user has succeeded or failed (the steamid in the callback will match the one returned by this call)", "retval": "bool", "name": "SendUserConnectAndAuthenticate", "argsstr": "uint32 unIPClient, const void *pvAuthBlob, uint32 cubAuthBlobSize, CSteamID *pSteamIDUser", "nargs": 4, "args": [["uint32", "unIPClient"], ["constvoid*", "pvAuthBlob"], ["uint32", "cubAuthBlobSize"], ["CSteamID*", "pSteamIDUser"]], "vfindex": 24}, {"comments": "Creates a fake user (ie, a bot) which will be listed as playing on the server, but skips validation.  \n \n Return Value: Returns a SteamID for the user to be tracked with, you should call HandleUserDisconnect()\n when this user leaves the server just like you would for a real user.", "retval": "CSteamID", "name": "CreateUnauthenticatedUserConnection", "argsstr": "", "args": [], "nargs": 0, "vfindex": 25}, {"comments": "Should be called whenever a user leaves our game server, this lets Steam internally\n track which users are currently on which servers for the purposes of preventing a single\n account being logged into multiple servers, showing who is currently on a server, etc.", "retval": "void", "name": "SendUserDisconnect", "argsstr": "CSteamID steamIDUser", "nargs": 1, "args": [["CSteamID", "steamIDUser"]], "vfindex": 26}, {"comments": "Update the data to be displayed in the server browser and matchmaking interfaces for a user\n currently connected to the server.  For regular users you must call this after you receive a\n GSUserValidationSuccess callback.\n \n Return Value: true if successful, false if failure (ie, steamIDUser wasn't for an active player)", "retval": "bool", "name": "BUpdateUserData", "argsstr": "CSteamID steamIDUser, const char *pchPlayerName, uint32 uScore", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchPlayerName"], ["uint32", "uScore"]], "vfindex": 27}, {"comments": "New auth system APIs - do not mix with the old auth system APIs.\n ----------------------------------------------------------------\n\n Retrieve ticket to be sent to the entity who wishes to authenticate you ( using BeginAuthSession API ). \n pcbTicket retrieves the length of the actual ticket.", "retval": "HAuthTicket", "name": "GetAuthSessionTicket", "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket", "nargs": 3, "args": [["void*", "pTicket"], ["int", "cbMaxTicket"], ["uint32*", "pcbTicket"]], "vfindex": 28}, {"comments": "Authenticate ticket ( from GetAuthSessionTicket ) from entity steamID to be sure it is valid and isnt reused\n Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )", "retval": "EBeginAuthSessionResult", "name": "BeginAuthSession", "argsstr": "const void *pAuthTicket, int cbAuthTicket, CSteamID steamID", "nargs": 3, "args": [["constvoid*", "pAuthTicket"], ["int", "cbAuthTicket"], ["CSteamID", "steamID"]], "vfindex": 29}, {"comments": "Stop tracking started by BeginAuthSession - called when no longer playing game with this entity", "retval": "void", "name": "EndAuthSession", "argsstr": "CSteamID steamID", "nargs": 1, "args": [["CSteamID", "steamID"]], "vfindex": 30}, {"comments": "Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to", "retval": "void", "name": "CancelAuthTicket", "argsstr": "HAuthTicket hAuthTicket", "nargs": 1, "args": [["HAuthTicket", "hAuthTicket"]], "vfindex": 31}, {"comments": "After receiving a user's authentication data, and passing it to SendUserConnectAndAuthenticate, use this function\n to determine if the user owns downloadable content specified by the provided AppID.", "retval": "EUserHasLicenseForAppResult", "name": "UserHasLicenseForApp", "argsstr": "CSteamID steamID, AppId_t appID", "nargs": 2, "args": [["CSteamID", "steamID"], ["AppId_t", "appID"]], "vfindex": 32}, {"comments": "Ask if a user in in the specified group, results returns async by GSUserGroupStatus_t\n returns false if we're not connected to the steam servers and thus cannot ask", "retval": "bool", "name": "RequestUserGroupStatus", "argsstr": "CSteamID steamIDUser, CSteamID steamIDGroup", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["CSteamID", "steamIDGroup"]], "vfindex": 33}, {"comments": "These two functions s are deprecated, and will not return results\n they will be removed in a future version of the SDK", "retval": "void", "name": "GetGameplayStats", "argsstr": "", "args": [], "nargs": 0, "vfindex": 34}, {"retval": "SteamAPICall_t", "name": "GetServerReputation", "argsstr": "", "args": [], "nargs": 0, "vfindex": 35}, {"comments": "Returns the public IP of the server according to Steam, useful when the server is \n behind NAT and you want to advertise its IP in a lobby for other clients to directly\n connect to", "retval": "uint32", "name": "GetPublicIP", "argsstr": "", "args": [], "nargs": 0, "vfindex": 36}, {"comments": "These are in GameSocketShare mode, where instead of ISteamGameServer creating its own\n socket to talk to the master server on, it lets the game use its socket to forward messages\n back and forth. This prevents us from requiring server ops to open up yet another port\n in their firewalls.\n\n the IP address and port should be in host order, i.e 127.0.0.1 == 0x7f000001\n\n These are used when you've elected to multiplex the game server's UDP socket\n rather than having the master server updater use its own sockets.\n \n Source games use this to simplify the job of the server admins, so they \n don't have to open up more ports on their firewalls.\n\n Call this when a packet that starts with 0xFFFFFFFF comes in. That means\n it's for us.", "retval": "bool", "name": "HandleIncomingPacket", "argsstr": "const void *pData, int cbData, uint32 srcIP, uint16 srcPort", "nargs": 4, "args": [["constvoid*", "pData"], ["int", "cbData"], ["uint32", "srcIP"], ["uint16", "srcPort"]], "vfindex": 37}, {"comments": "AFTER calling HandleIncomingPacket for any packets that came in that frame, call this.\n This gets a packet that the master server updater needs to send out on UDP.\n It returns the length of the packet it wants to send, or 0 if there are no more packets to send.\n Call this each frame until it returns 0.", "retval": "int", "name": "GetNextOutgoingPacket", "argsstr": "void *pOut, int cbMaxOut, uint32 *pNetAdr, uint16 *pPort", "nargs": 4, "args": [["void*", "pOut"], ["int", "cbMaxOut"], ["uint32*", "pNetAdr"], ["uint16*", "pPort"]], "vfindex": 38}, {"comments": "Control heartbeats / advertisement with master server\n\n\n Call this as often as you like to tell the master server updater whether or not\n you want it to be active (default: off).", "retval": "void", "name": "EnableHeartbeats", "argsstr": "bool bActive", "nargs": 1, "args": [["bool", "bActive"]], "vfindex": 39}, {"comments": "You usually don't need to modify this.\n Pass -1 to use the default value for iHeartbeatInterval.\n Some mods change this.", "retval": "void", "name": "SetHeartbeatInterval", "argsstr": "int iHeartbeatInterval", "nargs": 1, "args": [["int", "iHeartbeatInterval"]], "vfindex": 40}, {"comments": "Force a heartbeat to steam at the next opportunity", "retval": "void", "name": "ForceHeartbeat", "argsstr": "", "args": [], "nargs": 0, "vfindex": 41}, {"comments": "Associate this game server with this clan for the purposes of computing player compat\nCALL_RESULT( AssociateWithClanResult_t )", "retval": "SteamAPICall_t", "name": "AssociateWithClan", "argsstr": "CSteamID steamIDClan", "nargs": 1, "args": [["CSteamID", "steamIDClan"]], "vfindex": 42}, {"comments": "Ask if any of the current players dont want to play with this new player - or vice versa\nCALL_RESULT( ComputeNewPlayerCompatibilityResult_t )", "retval": "SteamAPICall_t", "name": "ComputeNewPlayerCompatibility", "argsstr": "CSteamID steamIDNewPlayer", "nargs": 1, "args": [["CSteamID", "steamIDNewPlayer"]], "vfindex": 43}], "cppinterface": "STEAMGAMESERVER_INTERFACE_VERSION", "cppinterfacev": "SteamGameServer012", "cppclass": "ISteamGameServer"}, "ISteamGameServerStats": {"funcs": [{"comments": "Downloads stats for the user\n returns a GSStatsReceived_t callback when completed\n if the user has no stats, GSStatsReceived_t.m_eResult will be set to k_EResultFail\n these stats will only be auto-updated for clients playing on the server. For other\n users you'll need to call RequestUserStats() again to refresh any data\nCALL_RESULT( GSStatsReceived_t )", "retval": "SteamAPICall_t", "name": "RequestUserStats", "argsstr": "CSteamID steamIDUser", "nargs": 1, "args": [["CSteamID", "steamIDUser"]], "vfindex": 0}, {"comments": "Requests stat information for a user, usable after a successful call to RequestUserStats()", "retval": "bool", "name": "GetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, int32 *pData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["int32*", "pData"]], "vfindex": 1}, {"retval": "bool", "name": "GetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, float *pData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["float*", "pData"]], "vfindex": 2}, {"retval": "bool", "name": "GetUserAchievement", "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["bool*", "pbAchieved"]], "vfindex": 3}, {"comments": "Set / update stats and achievements. \n Note: These updates will work only on stats game servers are allowed to edit and only for \n game servers that have been declared as officially controlled by the game creators. \n Set the IP range of your official servers on the Steamworks page", "retval": "bool", "name": "SetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, int32 nData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["int32", "nData"]], "vfindex": 4}, {"retval": "bool", "name": "SetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, float fData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["float", "fData"]], "vfindex": 5}, {"retval": "bool", "name": "UpdateUserAvgRateStat", "argsstr": "CSteamID steamIDUser, const char *pchName, float flCountThisSession, double dSessionLength", "nargs": 4, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["float", "flCountThisSession"], ["double", "dSessionLength"]], "vfindex": 6}, {"retval": "bool", "name": "SetUserAchievement", "argsstr": "CSteamID steamIDUser, const char *pchName", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"]], "vfindex": 7}, {"retval": "bool", "name": "ClearUserAchievement", "argsstr": "CSteamID steamIDUser, const char *pchName", "nargs": 2, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"]], "vfindex": 8}, {"comments": "Store the current data on the server, will get a GSStatsStored_t callback when set.\n\n If the callback has a result of k_EResultInvalidParam, one or more stats \n uploaded has been rejected, either because they broke constraints\n or were out of date. In this case the server sends back updated values.\n The stats should be re-iterated to keep in sync.\nCALL_RESULT( GSStatsStored_t )", "retval": "SteamAPICall_t", "name": "StoreUserStats", "argsstr": "CSteamID steamIDUser", "nargs": 1, "args": [["CSteamID", "steamIDUser"]], "vfindex": 9}], "cppinterface": "STEAMGAMESERVERSTATS_INTERFACE_VERSION", "cppinterfacev": "SteamGameServerStats001", "cppclass": "ISteamGameServerStats"}, "ISteamHTMLSurface": {"funcs": [{"comments": "Must call init and shutdown when starting/ending use of the interface", "retval": "bool", "name": "Init", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "bool", "name": "Shutdown", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"comments": "Create a browser object for display of a html page, when creation is complete the call handle\n will return a HTML_BrowserReady_t callback for the HHTMLBrowser of your new browser.\n   The user agent string is a substring to be added to the general user agent string so you can\n identify your client on web servers.\n   The userCSS string lets you apply a CSS style sheet to every displayed page, leave null if\n you do not require this functionality.\n\n YOU MUST HAVE IMPLEMENTED HANDLERS FOR HTML_BrowserReady_t, HTML_StartRequest_t,\n HTML_JSAlert_t, HTML_JSConfirm_t, and HTML_FileOpenDialog_t! See the CALLBACKS\n section of this interface (AllowStartRequest, etc) for more details. If you do\n not implement these callback handlers, the browser may appear to hang instead of\n navigating to new pages or triggering javascript popups.\n\nCALL_RESULT( HTML_BrowserReady_t )", "retval": "SteamAPICall_t", "name": "CreateBrowser", "argsstr": "const char *pchUserAgent, const char *pchUserCSS", "nargs": 2, "args": [["constchar*", "pchUserAgent"], ["constchar*", "pchUserCSS"]], "vfindex": 2}, {"comments": "Call this when you are done with a html surface, this lets us free the resources being used by it", "retval": "void", "name": "RemoveBrowser", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 3}, {"comments": "Navigate to this URL, results in a HTML_StartRequest_t as the request commences", "retval": "void", "name": "LoadURL", "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchURL, const char *pchPostData", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["constchar*", "pchURL"], ["constchar*", "pchPostData"]], "vfindex": 4}, {"comments": "Tells the surface the size in pixels to display the surface", "retval": "void", "name": "SetSize", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 unWidth, uint32 unHeight", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "unWidth"], ["uint32", "unHeight"]], "vfindex": 5}, {"comments": "Stop the load of the current html page", "retval": "void", "name": "StopLoad", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 6}, {"comments": "Reload (most likely from local cache) the current page", "retval": "void", "name": "Reload", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 7}, {"comments": "Navigate back in the page history", "retval": "void", "name": "GoBack", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 8}, {"comments": "Navigate forward in the page history", "retval": "void", "name": "GoForward", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 9}, {"comments": "Add this header to any url requests from this browser", "retval": "void", "name": "AddHeader", "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchKey, const char *pchValue", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["constchar*", "pchKey"], ["constchar*", "pchValue"]], "vfindex": 10}, {"comments": "Run this javascript script in the currently loaded page", "retval": "void", "name": "ExecuteJavascript", "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchScript", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["constchar*", "pchScript"]], "vfindex": 11}, {"comments": "Mouse click and mouse movement commands", "retval": "void", "name": "MouseUp", "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["EHTMLMouseButton", "eMouseButton"]], "vfindex": 12}, {"retval": "void", "name": "MouseDown", "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["EHTMLMouseButton", "eMouseButton"]], "vfindex": 13}, {"retval": "void", "name": "MouseDoubleClick", "argsstr": "HHTMLBrowser unBrowserHandle, EHTMLMouseButton eMouseButton", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["EHTMLMouseButton", "eMouseButton"]], "vfindex": 14}, {"comments": "X and y are relative to the HTML bounds", "retval": "void", "name": "MouseMove", "argsstr": "HHTMLBrowser unBrowserHandle, int x, int y", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["int", "x"], ["int", "y"]], "vfindex": 15}, {"comments": "NDelta is pixels of scroll", "retval": "void", "name": "MouseWheel", "argsstr": "HHTMLBrowser unBrowserHandle, int32 nDelta", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["int32", "nDelta"]], "vfindex": 16}, {"comments": "Don't show any custom cursor, just use your default\ndc_middle_pan,\ndc_north_pan,\ndc_north_east_pan,\ndc_east_pan,\ndc_south_east_pan,\ndc_south_pan,\ndc_south_west_pan,\ndc_west_pan,\ndc_north_west_pan,\ndc_alias,\ndc_cell,\ndc_colresize,\ndc_copycur,\ndc_verticaltext,\ndc_rowresize,\ndc_zoomin,\ndc_zoomout,\ndc_help,\ndc_custom,\n\ndc_last,  custom cursors start from this value and up\n};\n\nenum EHTMLKeyModifiers\n{\nk_eHTMLKeyModifier_None = 0,\nk_eHTMLKeyModifier_AltDown = 1 << 0,\nk_eHTMLKeyModifier_CtrlDown = 1 << 1,\nk_eHTMLKeyModifier_ShiftDown = 1 << 2,\n};\n\n keyboard interactions, native keycode is the virtual key code value from your OS", "retval": "void", "name": "KeyDown", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "nNativeKeyCode"], ["EHTMLKeyModifiers", "eHTMLKeyModifiers"]], "vfindex": 17}, {"retval": "void", "name": "KeyUp", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nNativeKeyCode, EHTMLKeyModifiers eHTMLKeyModifiers", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "nNativeKeyCode"], ["EHTMLKeyModifiers", "eHTMLKeyModifiers"]], "vfindex": 18}, {"comments": "CUnicodeChar is the unicode character point for this keypress (and potentially multiple chars per press)", "retval": "void", "name": "KeyChar", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 cUnicodeChar, EHTMLKeyModifiers eHTMLKeyModifiers", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "cUnicodeChar"], ["EHTMLKeyModifiers", "eHTMLKeyModifiers"]], "vfindex": 19}, {"comments": "Programmatically scroll this many pixels on the page", "retval": "void", "name": "SetHorizontalScroll", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nAbsolutePixelScroll", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "nAbsolutePixelScroll"]], "vfindex": 20}, {"retval": "void", "name": "SetVerticalScroll", "argsstr": "HHTMLBrowser unBrowserHandle, uint32 nAbsolutePixelScroll", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["uint32", "nAbsolutePixelScroll"]], "vfindex": 21}, {"comments": "Tell the html control if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things", "retval": "void", "name": "SetKeyFocus", "argsstr": "HHTMLBrowser unBrowserHandle, bool bHasKeyFocus", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["bool", "bHasKeyFocus"]], "vfindex": 22}, {"comments": "Open the current pages html code in the local editor of choice, used for debugging", "retval": "void", "name": "ViewSource", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 23}, {"comments": "Copy the currently selected text on the html page to the local clipboard", "retval": "void", "name": "CopyToClipboard", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 24}, {"comments": "Paste from the local clipboard to the current html page", "retval": "void", "name": "PasteFromClipboard", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 25}, {"comments": "Find this string in the browser, if bCurrentlyInFind is true then instead cycle to the next matching element", "retval": "void", "name": "Find", "argsstr": "HHTMLBrowser unBrowserHandle, const char *pchSearchStr, bool bCurrentlyInFind, bool bReverse", "nargs": 4, "args": [["HHTMLBrowser", "unBrowserHandle"], ["constchar*", "pchSearchStr"], ["bool", "bCurrentlyInFind"], ["bool", "bReverse"]], "vfindex": 26}, {"comments": "Cancel a currently running find", "retval": "void", "name": "StopFind", "argsstr": "HHTMLBrowser unBrowserHandle", "nargs": 1, "args": [["HHTMLBrowser", "unBrowserHandle"]], "vfindex": 27}, {"comments": "Return details about the link at position x,y on the current page", "retval": "void", "name": "GetLinkAtPosition", "argsstr": "HHTMLBrowser unBrowserHandle, int x, int y", "nargs": 3, "args": [["HHTMLBrowser", "unBrowserHandle"], ["int", "x"], ["int", "y"]], "vfindex": 28}, {"comments": "Set a webcookie for the hostname in question", "retval": "void", "name": "SetCookie", "argsstr": "const char *pchHostname, const char *pchKey, const char *pchValue, const char *pchPath = \"/\", RTime32 nExpires = 0, bool bSecure = false, bool bHTTPOnly = false", "nargs": 7, "args": [["constchar*", "pchHostname"], ["constchar*", "pchKey"], ["constchar*", "pchValue"], ["constchar*pchPath=", "\"/\""], ["RTime32nExpires=", "0"], ["boolbSecure=", "false"], ["boolbHTTPOnly=", "false"]], "vfindex": 29}, {"comments": "Zoom the current page by flZoom ( from 0.0 to 2.0, so to zoom to 120% use 1.2 ), zooming around point X,Y in the page (use 0,0 if you don't care)", "retval": "void", "name": "SetPageScaleFactor", "argsstr": "HHTMLBrowser unBrowserHandle, float flZoom, int nPointX, int nPointY", "nargs": 4, "args": [["HHTMLBrowser", "unBrowserHandle"], ["float", "flZoom"], ["int", "nPointX"], ["int", "nPointY"]], "vfindex": 30}, {"comments": "Enable/disable low-resource background mode, where javascript and repaint timers are throttled, resources are\n more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled,\n all HTML5 video and audio objects will execute \".pause()\" and gain the property \"._steam_background_paused = 1\".\n When background mode is disabled, any video or audio objects with that property will resume with \".play()\".", "retval": "void", "name": "SetBackgroundMode", "argsstr": "HHTMLBrowser unBrowserHandle, bool bBackgroundMode", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["bool", "bBackgroundMode"]], "vfindex": 31}, {"comments": "Scale the output display space by this factor, this is useful when displaying content on high dpi devices.\n Specifies the ratio between physical and logical pixels.", "retval": "void", "name": "SetDPIScalingFactor", "argsstr": "HHTMLBrowser unBrowserHandle, float flDPIScaling", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["float", "flDPIScaling"]], "vfindex": 32}, {"comments": "CALLBACKS\n\n  These set of functions are used as responses to callback requests\n\n\n You MUST call this in response to a HTML_StartRequest_t callback\n  Set bAllowed to true to allow this navigation, false to cancel it and stay \n on the current page. You can use this feature to limit the valid pages\n allowed in your HTML surface.", "retval": "void", "name": "AllowStartRequest", "argsstr": "HHTMLBrowser unBrowserHandle, bool bAllowed", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["bool", "bAllowed"]], "vfindex": 33}, {"comments": "You MUST call this in response to a HTML_JSAlert_t or HTML_JSConfirm_t callback\n  Set bResult to true for the OK option of a confirm, use false otherwise", "retval": "void", "name": "JSDialogResponse", "argsstr": "HHTMLBrowser unBrowserHandle, bool bResult", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["bool", "bResult"]], "vfindex": 34}, {"comments": "You MUST call this in response to a HTML_FileOpenDialog_t callback\nIGNOREATTR()", "retval": "void", "name": "FileLoadDialogResponse", "argsstr": "HHTMLBrowser unBrowserHandle, const char **pchSelectedFiles", "nargs": 2, "args": [["HHTMLBrowser", "unBrowserHandle"], ["constchar*", "*pchSelectedFiles"]], "vfindex": 35}], "cppinterface": "STEAMHTMLSURFACE_INTERFACE_VERSION", "cppinterfacev": "STEAMHTMLSURFACE_INTERFACE_VERSION_004", "cppclass": "ISteamHTMLSurface"}, "ISteamHTTP": {"funcs": [{"comments": "Initializes a new HTTP request, returning a handle to use in further operations on it.  Requires\n the method (GET or POST) and the absolute URL for the request.  Both http and https are supported,\n so this string must start with http: or https: and should look like http:store.steampowered.com/app/250/ \n or such.", "retval": "HTTPRequestHandle", "name": "CreateHTTPRequest", "argsstr": "EHTTPMethod eHTTPRequestMethod, const char *pchAbsoluteURL", "nargs": 2, "args": [["EHTTPMethod", "eHTTPRequestMethod"], ["constchar*", "pchAbsoluteURL"]], "vfindex": 0}, {"comments": "Set a context value for the request, which will be returned in the HTTPRequestCompleted_t callback after\n sending the request.  This is just so the caller can easily keep track of which callbacks go with which request data.", "retval": "bool", "name": "SetHTTPRequestContextValue", "argsstr": "HTTPRequestHandle hRequest, uint64 ulContextValue", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["uint64", "ulContextValue"]], "vfindex": 1}, {"comments": "Set a timeout in seconds for the HTTP request, must be called prior to sending the request.  Default\n timeout is 60 seconds if you don't call this.  Returns false if the handle is invalid, or the request\n has already been sent.", "retval": "bool", "name": "SetHTTPRequestNetworkActivityTimeout", "argsstr": "HTTPRequestHandle hRequest, uint32 unTimeoutSeconds", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["uint32", "unTimeoutSeconds"]], "vfindex": 2}, {"comments": "Set a request header value for the request, must be called prior to sending the request.  Will \n return false if the handle is invalid or the request is already sent.", "retval": "bool", "name": "SetHTTPRequestHeaderValue", "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, const char *pchHeaderValue", "nargs": 3, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchHeaderName"], ["constchar*", "pchHeaderValue"]], "vfindex": 3}, {"comments": "Set a GET or POST parameter value on the request, which is set will depend on the EHTTPMethod specified\n when creating the request.  Must be called prior to sending the request.  Will return false if the \n handle is invalid or the request is already sent.", "retval": "bool", "name": "SetHTTPRequestGetOrPostParameter", "argsstr": "HTTPRequestHandle hRequest, const char *pchParamName, const char *pchParamValue", "nargs": 3, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchParamName"], ["constchar*", "pchParamValue"]], "vfindex": 4}, {"comments": "Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on\n asynchronous response via callback.\n\n Note: If the user is in offline mode in Steam, then this will add a only-if-cached cache-control \n header and only do a local cache lookup rather than sending any actual remote request.", "retval": "bool", "name": "SendHTTPRequest", "argsstr": "HTTPRequestHandle hRequest, SteamAPICall_t *pCallHandle", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["SteamAPICall_t*", "pCallHandle"]], "vfindex": 5}, {"comments": "Sends the HTTP request, will return false on a bad handle, otherwise use SteamCallHandle to wait on\n asynchronous response via callback for completion, and listen for HTTPRequestHeadersReceived_t and \n HTTPRequestDataReceived_t callbacks while streaming.", "retval": "bool", "name": "SendHTTPRequestAndStreamResponse", "argsstr": "HTTPRequestHandle hRequest, SteamAPICall_t *pCallHandle", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["SteamAPICall_t*", "pCallHandle"]], "vfindex": 6}, {"comments": "Defers a request you have sent, the actual HTTP client code may have many requests queued, and this will move\n the specified request to the tail of the queue.  Returns false on invalid handle, or if the request is not yet sent.", "retval": "bool", "name": "DeferHTTPRequest", "argsstr": "HTTPRequestHandle hRequest", "nargs": 1, "args": [["HTTPRequestHandle", "hRequest"]], "vfindex": 7}, {"comments": "Prioritizes a request you have sent, the actual HTTP client code may have many requests queued, and this will move\n the specified request to the head of the queue.  Returns false on invalid handle, or if the request is not yet sent.", "retval": "bool", "name": "PrioritizeHTTPRequest", "argsstr": "HTTPRequestHandle hRequest", "nargs": 1, "args": [["HTTPRequestHandle", "hRequest"]], "vfindex": 8}, {"comments": "Checks if a response header is present in a HTTP response given a handle from HTTPRequestCompleted_t, also \n returns the size of the header value if present so the caller and allocate a correctly sized buffer for\n GetHTTPResponseHeaderValue.", "retval": "bool", "name": "GetHTTPResponseHeaderSize", "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, uint32 *unResponseHeaderSize", "nargs": 3, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchHeaderName"], ["uint32*", "unResponseHeaderSize"]], "vfindex": 9}, {"comments": "Gets header values from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the\n header is not present or if your buffer is too small to contain it's value.  You should first call \n BGetHTTPResponseHeaderSize to check for the presence of the header and to find out the size buffer needed.", "retval": "bool", "name": "GetHTTPResponseHeaderValue", "argsstr": "HTTPRequestHandle hRequest, const char *pchHeaderName, uint8 *pHeaderValueBuffer, uint32 unBufferSize", "nargs": 4, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchHeaderName"], ["uint8*", "pHeaderValueBuffer"], ["uint32", "unBufferSize"]], "vfindex": 10}, {"comments": "Gets the size of the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the \n handle is invalid.", "retval": "bool", "name": "GetHTTPResponseBodySize", "argsstr": "HTTPRequestHandle hRequest, uint32 *unBodySize", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["uint32*", "unBodySize"]], "vfindex": 11}, {"comments": "Gets the body data from a HTTP response given a handle from HTTPRequestCompleted_t, will return false if the \n handle is invalid or is to a streaming response, or if the provided buffer is not the correct size.  Use BGetHTTPResponseBodySize first to find out\n the correct buffer size to use.", "retval": "bool", "name": "GetHTTPResponseBodyData", "argsstr": "HTTPRequestHandle hRequest, uint8 *pBodyDataBuffer, uint32 unBufferSize", "nargs": 3, "args": [["HTTPRequestHandle", "hRequest"], ["uint8*", "pBodyDataBuffer"], ["uint32", "unBufferSize"]], "vfindex": 12}, {"comments": "Gets the body data from a streaming HTTP response given a handle from HTTPRequestDataReceived_t. Will return false if the \n handle is invalid or is to a non-streaming response (meaning it wasn't sent with SendHTTPRequestAndStreamResponse), or if the buffer size and offset \n do not match the size and offset sent in HTTPRequestDataReceived_t.", "retval": "bool", "name": "GetHTTPStreamingResponseBodyData", "argsstr": "HTTPRequestHandle hRequest, uint32 cOffset, uint8 *pBodyDataBuffer, uint32 unBufferSize", "nargs": 4, "args": [["HTTPRequestHandle", "hRequest"], ["uint32", "cOffset"], ["uint8*", "pBodyDataBuffer"], ["uint32", "unBufferSize"]], "vfindex": 13}, {"comments": "Releases an HTTP response handle, should always be called to free resources after receiving a HTTPRequestCompleted_t\n callback and finishing using the response.", "retval": "bool", "name": "ReleaseHTTPRequest", "argsstr": "HTTPRequestHandle hRequest", "nargs": 1, "args": [["HTTPRequestHandle", "hRequest"]], "vfindex": 14}, {"comments": "Gets progress on downloading the body for the request.  This will be zero unless a response header has already been\n received which included a content-length field.  For responses that contain no content-length it will report\n zero for the duration of the request as the size is unknown until the connection closes.", "retval": "bool", "name": "GetHTTPDownloadProgressPct", "argsstr": "HTTPRequestHandle hRequest, float *pflPercentOut", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["float*", "pflPercentOut"]], "vfindex": 15}, {"comments": "Sets the body for an HTTP Post request.  Will fail and return false on a GET request, and will fail if POST params\n have already been set for the request.  Setting this raw body makes it the only contents for the post, the pchContentType\n parameter will set the content-type header for the request so the server may know how to interpret the body.", "retval": "bool", "name": "SetHTTPRequestRawPostBody", "argsstr": "HTTPRequestHandle hRequest, const char *pchContentType, uint8 *pubBody, uint32 unBodyLen", "nargs": 4, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchContentType"], ["uint8*", "pubBody"], ["uint32", "unBodyLen"]], "vfindex": 16}, {"comments": "Creates a cookie container handle which you must later free with ReleaseCookieContainer().  If bAllowResponsesToModify=true\n than any response to your requests using this cookie container may add new cookies which may be transmitted with\n future requests.  If bAllowResponsesToModify=false than only cookies you explicitly set will be sent.  This API is just for\n during process lifetime, after steam restarts no cookies are persisted and you have no way to access the cookie container across\n repeat executions of your process.", "retval": "HTTPCookieContainerHandle", "name": "CreateCookieContainer", "argsstr": "bool bAllowResponsesToModify", "nargs": 1, "args": [["bool", "bAllowResponsesToModify"]], "vfindex": 17}, {"comments": "Release a cookie container you are finished using, freeing it's memory", "retval": "bool", "name": "ReleaseCookieContainer", "argsstr": "HTTPCookieContainerHandle hCookieContainer", "nargs": 1, "args": [["HTTPCookieContainerHandle", "hCookieContainer"]], "vfindex": 18}, {"comments": "Adds a cookie to the specified cookie container that will be used with future requests.", "retval": "bool", "name": "SetCookie", "argsstr": "HTTPCookieContainerHandle hCookieContainer, const char *pchHost, const char *pchUrl, const char *pchCookie", "nargs": 4, "args": [["HTTPCookieContainerHandle", "hCookieContainer"], ["constchar*", "pchHost"], ["constchar*", "pchUrl"], ["constchar*", "pchCookie"]], "vfindex": 19}, {"comments": "Set the cookie container to use for a HTTP request", "retval": "bool", "name": "SetHTTPRequestCookieContainer", "argsstr": "HTTPRequestHandle hRequest, HTTPCookieContainerHandle hCookieContainer", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["HTTPCookieContainerHandle", "hCookieContainer"]], "vfindex": 20}, {"comments": "Set the extra user agent info for a request, this doesn't clobber the normal user agent, it just adds the extra info on the end", "retval": "bool", "name": "SetHTTPRequestUserAgentInfo", "argsstr": "HTTPRequestHandle hRequest, const char *pchUserAgentInfo", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["constchar*", "pchUserAgentInfo"]], "vfindex": 21}, {"comments": "Set that https request should require verified SSL certificate via machines certificate trust store", "retval": "bool", "name": "SetHTTPRequestRequiresVerifiedCertificate", "argsstr": "HTTPRequestHandle hRequest, bool bRequireVerifiedCertificate", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["bool", "bRequireVerifiedCertificate"]], "vfindex": 22}, {"comments": "Set an absolute timeout on the HTTP request, this is just a total time timeout different than the network activity timeout\n which can bump everytime we get more data", "retval": "bool", "name": "SetHTTPRequestAbsoluteTimeoutMS", "argsstr": "HTTPRequestHandle hRequest, uint32 unMilliseconds", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["uint32", "unMilliseconds"]], "vfindex": 23}, {"comments": "Check if the reason the request failed was because we timed it out (rather than some harder failure)", "retval": "bool", "name": "GetHTTPRequestWasTimedOut", "argsstr": "HTTPRequestHandle hRequest, bool *pbWasTimedOut", "nargs": 2, "args": [["HTTPRequestHandle", "hRequest"], ["bool*", "pbWasTimedOut"]], "vfindex": 24}], "cppinterface": "STEAMHTTP_INTERFACE_VERSION", "cppinterfacev": "STEAMHTTP_INTERFACE_VERSION002", "cppclass": "ISteamHTTP"}, "ISteamInventory": {"funcs": [{"comments": "INVENTORY ASYNC RESULT MANAGEMENT\n\n Asynchronous inventory queries always output a result handle which can be used with\n GetResultStatus, GetResultItems, etc. A SteamInventoryResultReady_t callback will\n be triggered when the asynchronous result becomes ready (or fails).\n\n\n Find out the status of an asynchronous inventory result handle. Possible values:\n  k_EResultPending - still in progress\n  k_EResultOK - done, result ready\n  k_EResultExpired - done, result ready, maybe out of date (see DeserializeResult)\n  k_EResultInvalidParam - ERROR: invalid API call parameters\n  k_EResultServiceUnavailable - ERROR: service temporarily down, you may retry later\n  k_EResultLimitExceeded - ERROR: operation would exceed per-user inventory limits\n  k_EResultFail - ERROR: unknown / generic error\nMETHOD_DESC(Find out the status of an asynchronous inventory result handle.)", "retval": "EResult", "name": "GetResultStatus", "argsstr": "SteamInventoryResult_t resultHandle", "nargs": 1, "args": [["SteamInventoryResult_t", "resultHandle"]], "vfindex": 0}, {"comments": "Copies the contents of a result set into a flat array. The specific\n contents of the result set depend on which query which was used.\nMETHOD_DESC(Copies the contents of a result set into a flat array. The specific contents of the result set depend on which query which was used.)", "retval": "bool", "name": "GetResultItems", "argsstr": "SteamInventoryResult_t resultHandle,\n\t\t\t\t\t\t\t\t SteamItemDetails_t *pOutItemsArray,\n\t\t\t\t\t\t\t\tuint32 *punOutItemsArraySize", "nargs": 3, "args": [["SteamInventoryResult_t", "resultHandle"], ["SteamItemDetails_t*", "pOutItemsArray"], ["uint32*", "punOutItemsArraySize"]], "vfindex": 1}, {"comments": "In combination with GetResultItems, you can use GetResultItemProperty to retrieve\n dynamic string properties for a given item returned in the result set.\n \n Property names are always composed of ASCII letters, numbers, and/or underscores.\n\n Pass a NULL pointer for pchPropertyName to get a comma - separated list of available\n property names.\n\n If pchValueBuffer is NULL, *punValueBufferSize will contain the \n suggested buffer size. Otherwise it will be the number of bytes actually copied\n to pchValueBuffer. If the results do not fit in the given buffer, partial \n results may be copied.", "retval": "bool", "name": "GetResultItemProperty", "argsstr": "SteamInventoryResult_t resultHandle, \n\t\t\t\t\t\t\t\t\t\tuint32 unItemIndex, \n\t\t\t\t\t\t\t\t\t\tconst char *pchPropertyName,\n\t\t\t\t\t\t\t\t\t\t char *pchValueBuffer, uint32 *punValueBufferSizeOut", "nargs": 5, "args": [["SteamInventoryResult_t", "resultHandle"], ["uint32", "unItemIndex"], ["constchar*", "pchPropertyName"], ["char*", "pchValueBuffer"], ["uint32*", "punValueBufferSizeOut"]], "vfindex": 2}, {"comments": "Returns the server time at which the result was generated. Compare against\n the value of IClientUtils::GetServerRealTime() to determine age.\nMETHOD_DESC(Returns the server time at which the result was generated. Compare against the value of IClientUtils::GetServerRealTime() to determine age.)", "retval": "uint32", "name": "GetResultTimestamp", "argsstr": "SteamInventoryResult_t resultHandle", "nargs": 1, "args": [["SteamInventoryResult_t", "resultHandle"]], "vfindex": 3}, {"comments": "Returns true if the result belongs to the target steam ID, false if the\n result does not. This is important when using DeserializeResult, to verify\n that a remote player is not pretending to have a different user's inventory.\nMETHOD_DESC(Returns true if the result belongs to the target steam ID or false if the result does not. This is important when using DeserializeResult to verify that a remote player is not pretending to have a different users inventory.)", "retval": "bool", "name": "CheckResultSteamID", "argsstr": "SteamInventoryResult_t resultHandle, CSteamID steamIDExpected", "nargs": 2, "args": [["SteamInventoryResult_t", "resultHandle"], ["CSteamID", "steamIDExpected"]], "vfindex": 4}, {"comments": "Destroys a result handle and frees all associated memory.\nMETHOD_DESC(Destroys a result handle and frees all associated memory.)", "retval": "void", "name": "DestroyResult", "argsstr": "SteamInventoryResult_t resultHandle", "nargs": 1, "args": [["SteamInventoryResult_t", "resultHandle"]], "vfindex": 5}, {"comments": "INVENTORY ASYNC QUERY\n\n\n Captures the entire state of the current user's Steam inventory.\n You must call DestroyResult on this handle when you are done with it.\n Returns false and sets *pResultHandle to zero if inventory is unavailable.\n Note: calls to this function are subject to rate limits and may return\n cached results if called too frequently. It is suggested that you call\n this function only when you are about to display the user's full inventory,\n or if you expect that the inventory may have changed.\nMETHOD_DESC(Captures the entire state of the current users Steam inventory.)", "retval": "bool", "name": "GetAllItems", "argsstr": "SteamInventoryResult_t *pResultHandle", "nargs": 1, "args": [["SteamInventoryResult_t*", "pResultHandle"]], "vfindex": 6}, {"comments": "Captures the state of a subset of the current user's Steam inventory,\n identified by an array of item instance IDs. The results from this call\n can be serialized and passed to other players to \"prove\" that the current\n user owns specific items, without exposing the user's entire inventory.\n For example, you could call GetItemsByID with the IDs of the user's\n currently equipped cosmetic items and serialize this to a buffer, and\n then transmit this buffer to other players upon joining a game.\nMETHOD_DESC(Captures the state of a subset of the current users Steam inventory identified by an array of item instance IDs.)", "retval": "bool", "name": "GetItemsByID", "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemInstanceID_t *pInstanceIDs, uint32 unCountInstanceIDs", "nargs": 3, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["constSteamItemInstanceID_t*", "pInstanceIDs"], ["uint32", "unCountInstanceIDs"]], "vfindex": 7}, {"comments": "RESULT SERIALIZATION AND AUTHENTICATION\n\n Serialized result sets contain a short signature which can't be forged\n or replayed across different game sessions. A result set can be serialized\n on the local client, transmitted to other players via your game networking,\n and deserialized by the remote players. This is a secure way of preventing\n hackers from lying about posessing rare/high-value items.\n\n Serializes a result set with signature bytes to an output buffer. Pass\n NULL as an output buffer to get the required size via punOutBufferSize.\n The size of a serialized result depends on the number items which are being\n serialized. When securely transmitting items to other players, it is\n recommended to use \"GetItemsByID\" first to create a minimal result set.\n Results have a built-in timestamp which will be considered \"expired\" after\n an hour has elapsed. See DeserializeResult for expiration handling.", "retval": "bool", "name": "SerializeResult", "argsstr": "SteamInventoryResult_t resultHandle,  void *pOutBuffer, uint32 *punOutBufferSize", "nargs": 3, "args": [["SteamInventoryResult_t", "resultHandle"], ["void*", "pOutBuffer"], ["uint32*", "punOutBufferSize"]], "vfindex": 8}, {"comments": "Deserializes a result set and verifies the signature bytes. Returns false\n if bRequireFullOnlineVerify is set but Steam is running in Offline mode.\n Otherwise returns true and then delivers error codes via GetResultStatus.\n\n The bRESERVED_MUST_BE_FALSE flag is reserved for future use and should not\n be set to true by your game at this time.\n\n DeserializeResult has a potential soft-failure mode where the handle status\n is set to k_EResultExpired. GetResultItems() still succeeds in this mode.\n The \"expired\" result could indicate that the data may be out of date - not\n just due to timed expiration (one hour), but also because one of the items\n in the result set may have been traded or consumed since the result set was\n generated. You could compare the timestamp from GetResultTimestamp() to\n ISteamUtils::GetServerRealTime() to determine how old the data is. You could\n simply ignore the \"expired\" result code and continue as normal, or you\n could challenge the player with expired data to send an updated result set.", "retval": "bool", "name": "DeserializeResult", "argsstr": "SteamInventoryResult_t *pOutResultHandle, BUFFER_COUNT(punOutBufferSize", "nargs": 2, "args": [["SteamInventoryResult_t*", "pOutResultHandle"], ["", "BUFFER_COUNT(punOutBufferSize"]], "vfindex": 9}, {"comments": "INVENTORY ASYNC MODIFICATION\n\n\n GenerateItems() creates one or more items and then generates a SteamInventoryCallback_t\n notification with a matching nCallbackContext parameter. This API is only intended\n for prototyping - it is only usable by Steam accounts that belong to the publisher group \n for your game.\n If punArrayQuantity is not NULL, it should be the same length as pArrayItems and should\n describe the quantity of each item to generate.", "retval": "bool", "name": "GenerateItems", "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemDef_t *pArrayItemDefs,  const uint32 *punArrayQuantity, uint32 unArrayLength", "nargs": 4, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["constSteamItemDef_t*", "pArrayItemDefs"], ["constuint32*", "punArrayQuantity"], ["uint32", "unArrayLength"]], "vfindex": 10}, {"comments": "GrantPromoItems() checks the list of promotional items for which the user may be eligible\n and grants the items (one time only).  On success, the result set will include items which\n were granted, if any. If no items were granted because the user isn't eligible for any\n promotions, this is still considered a success.\nMETHOD_DESC(GrantPromoItems() checks the list of promotional items for which the user may be eligible and grants the items (one time only).)", "retval": "bool", "name": "GrantPromoItems", "argsstr": "SteamInventoryResult_t *pResultHandle", "nargs": 1, "args": [["SteamInventoryResult_t*", "pResultHandle"]], "vfindex": 11}, {"comments": "AddPromoItem() / AddPromoItems() are restricted versions of GrantPromoItems(). Instead of\n scanning for all eligible promotional items, the check is restricted to a single item\n definition or set of item definitions. This can be useful if your game has custom UI for\n showing a specific promo item to the user.", "retval": "bool", "name": "AddPromoItem", "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemDef_t itemDef", "nargs": 2, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["SteamItemDef_t", "itemDef"]], "vfindex": 12}, {"retval": "bool", "name": "AddPromoItems", "argsstr": "SteamInventoryResult_t *pResultHandle,  const SteamItemDef_t *pArrayItemDefs, uint32 unArrayLength", "nargs": 3, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["constSteamItemDef_t*", "pArrayItemDefs"], ["uint32", "unArrayLength"]], "vfindex": 13}, {"comments": "ConsumeItem() removes items from the inventory, permanently. They cannot be recovered.\n Not for the faint of heart - if your game implements item removal at all, a high-friction\n UI confirmation process is highly recommended.\nMETHOD_DESC(ConsumeItem() removes items from the inventory permanently.)", "retval": "bool", "name": "ConsumeItem", "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemInstanceID_t itemConsume, uint32 unQuantity", "nargs": 3, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["SteamItemInstanceID_t", "itemConsume"], ["uint32", "unQuantity"]], "vfindex": 14}, {"comments": "ExchangeItems() is an atomic combination of item generation and consumption. \n It can be used to implement crafting recipes or transmutations, or items which unpack \n themselves into other items (e.g., a chest). \n Exchange recipes are defined in the ItemDef, and explicitly list the required item \n types and resulting generated type. \n Exchange recipes are evaluated atomically by the Inventory Service; if the supplied\n components do not match the recipe, or do not contain sufficient quantity, the \n exchange will fail.", "retval": "bool", "name": "ExchangeItems", "argsstr": "SteamInventoryResult_t *pResultHandle,\n\t\t\t\t\t\t\t\t const SteamItemDef_t *pArrayGenerate,  const uint32 *punArrayGenerateQuantity, uint32 unArrayGenerateLength,\n\t\t\t\t\t\t\t\t const SteamItemInstanceID_t *pArrayDestroy,  const uint32 *punArrayDestroyQuantity, uint32 unArrayDestroyLength", "nargs": 7, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["constSteamItemDef_t*", "pArrayGenerate"], ["constuint32*", "punArrayGenerateQuantity"], ["uint32", "unArrayGenerateLength"], ["constSteamItemInstanceID_t*", "pArrayDestroy"], ["constuint32*", "punArrayDestroyQuantity"], ["uint32", "unArrayDestroyLength"]], "vfindex": 15}, {"comments": "TransferItemQuantity() is intended for use with items which are \"stackable\" (can have\n quantity greater than one). It can be used to split a stack into two, or to transfer\n quantity from one stack into another stack of identical items. To split one stack into\n two, pass k_SteamItemInstanceIDInvalid for itemIdDest and a new item will be generated.", "retval": "bool", "name": "TransferItemQuantity", "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemInstanceID_t itemIdSource, uint32 unQuantity, SteamItemInstanceID_t itemIdDest", "nargs": 4, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["SteamItemInstanceID_t", "itemIdSource"], ["uint32", "unQuantity"], ["SteamItemInstanceID_t", "itemIdDest"]], "vfindex": 16}, {"comments": "TIMED DROPS AND PLAYTIME CREDIT\n\n\n Deprecated. Calling this method is not required for proper playtime accounting.\nMETHOD_DESC( Deprecated method. Playtime accounting is performed on the Steam servers. )", "retval": "void", "name": "SendItemDropHeartbeat", "argsstr": "", "args": [], "nargs": 0, "vfindex": 17}, {"comments": "Playtime credit must be consumed and turned into item drops by your game. Only item\n definitions which are marked as \"playtime item generators\" can be spawned. The call\n will return an empty result set if there is not enough playtime credit for a drop.\n Your game should call TriggerItemDrop at an appropriate time for the user to receive\n new items, such as between rounds or while the player is dead. Note that players who\n hack their clients could modify the value of \"dropListDefinition\", so do not use it\n to directly control rarity.\n See your Steamworks configuration to set playtime drop rates for individual itemdefs.\n The client library will suppress too-frequent calls to this method.\nMETHOD_DESC(Playtime credit must be consumed and turned into item drops by your game.)", "retval": "bool", "name": "TriggerItemDrop", "argsstr": "SteamInventoryResult_t *pResultHandle, SteamItemDef_t dropListDefinition", "nargs": 2, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["SteamItemDef_t", "dropListDefinition"]], "vfindex": 18}, {"comments": "Deprecated. This method is not supported.", "retval": "bool", "name": "TradeItems", "argsstr": "SteamInventoryResult_t *pResultHandle, CSteamID steamIDTradePartner,\n\t\t\t\t\t\t\t  const SteamItemInstanceID_t *pArrayGive,  const uint32 *pArrayGiveQuantity, uint32 nArrayGiveLength,\n\t\t\t\t\t\t\t  const SteamItemInstanceID_t *pArrayGet,  const uint32 *pArrayGetQuantity, uint32 nArrayGetLength", "nargs": 8, "args": [["SteamInventoryResult_t*", "pResultHandle"], ["CSteamID", "steamIDTradePartner"], ["constSteamItemInstanceID_t*", "pArrayGive"], ["constuint32*", "pArrayGiveQuantity"], ["uint32", "nArrayGiveLength"], ["constSteamItemInstanceID_t*", "pArrayGet"], ["constuint32*", "pArrayGetQuantity"], ["uint32", "nArrayGetLength"]], "vfindex": 19}, {"comments": "ITEM DEFINITIONS\n\n Item definitions are a mapping of \"definition IDs\" (integers between 1 and 1000000)\n to a set of string properties. Some of these properties are required to display items\n on the Steam community web site. Other properties can be defined by applications.\n Use of these functions is optional; there is no reason to call LoadItemDefinitions\n if your game hardcodes the numeric definition IDs (eg, purple face mask = 20, blue\n weapon mod = 55) and does not allow for adding new item types without a client patch.\n\n\n LoadItemDefinitions triggers the automatic load and refresh of item definitions.\n Every time new item definitions are available (eg, from the dynamic addition of new\n item types while players are still in-game), a SteamInventoryDefinitionUpdate_t\n callback will be fired.\nMETHOD_DESC(LoadItemDefinitions triggers the automatic load and refresh of item definitions.)", "retval": "bool", "name": "LoadItemDefinitions", "argsstr": "", "args": [], "nargs": 0, "vfindex": 20}, {"comments": "GetItemDefinitionIDs returns the set of all defined item definition IDs (which are\n defined via Steamworks configuration, and not necessarily contiguous integers).\n If pItemDefIDs is null, the call will return true and *punItemDefIDsArraySize will\n contain the total size necessary for a subsequent call. Otherwise, the call will\n return false if and only if there is not enough space in the output array.", "retval": "bool", "name": "GetItemDefinitionIDs", "argsstr": "SteamItemDef_t *pItemDefIDs,\n\t\t\t\tDESC(Size of array is passed in and actual size used is returned in this param", "nargs": 2, "args": [["SteamItemDef_t*", "pItemDefIDs"], ["DESC(Sizeofarrayispassedinandactualsizeusedisreturnedinthis", "param"]], "vfindex": 21}, {"comments": "GetItemDefinitionProperty returns a string property from a given item definition.\n Note that some properties (for example, \"name\") may be localized and will depend\n on the current Steam language settings (see ISteamApps::GetCurrentGameLanguage).\n Property names are always composed of ASCII letters, numbers, and/or underscores.\n Pass a NULL pointer for pchPropertyName to get a comma - separated list of available\n property names. If pchValueBuffer is NULL, *punValueBufferSize will contain the \n suggested buffer size. Otherwise it will be the number of bytes actually copied\n to pchValueBuffer. If the results do not fit in the given buffer, partial \n results may be copied.", "retval": "bool", "name": "GetItemDefinitionProperty", "argsstr": "SteamItemDef_t iDefinition, const char *pchPropertyName,\n\t\t char *pchValueBuffer, uint32 *punValueBufferSizeOut", "nargs": 4, "args": [["SteamItemDef_t", "iDefinition"], ["constchar*", "pchPropertyName"], ["char*", "pchValueBuffer"], ["uint32*", "punValueBufferSizeOut"]], "vfindex": 22}, {"comments": "Request the list of \"eligible\" promo items that can be manually granted to the given\n user.  These are promo items of type \"manual\" that won't be granted automatically.\n An example usage of this is an item that becomes available every week.\nCALL_RESULT( SteamInventoryEligiblePromoItemDefIDs_t )", "retval": "SteamAPICall_t", "name": "RequestEligiblePromoItemDefinitionsIDs", "argsstr": "CSteamID steamID", "nargs": 1, "args": [["CSteamID", "steamID"]], "vfindex": 23}, {"comments": "After handling a SteamInventoryEligiblePromoItemDefIDs_t call result, use this\n function to pull out the list of item definition ids that the user can be\n manually granted via the AddPromoItems() call.", "retval": "bool", "name": "GetEligiblePromoItemDefinitionIDs", "argsstr": "CSteamID steamID,\n\t\t SteamItemDef_t *pItemDefIDs,\n\t\tDESC(Size of array is passed in and actual size used is returned in this param", "nargs": 3, "args": [["CSteamID", "steamID"], ["SteamItemDef_t*", "pItemDefIDs"], ["DESC(Sizeofarrayispassedinandactualsizeusedisreturnedinthis", "param"]], "vfindex": 24}, {"comments": "Starts the purchase process for the given item definitions.  The callback SteamInventoryStartPurchaseResult_t\n will be posted if Steam was able to initialize the transaction.\n \n Once the purchase has been authorized and completed by the user, the callback SteamInventoryResultReady_t \n will be posted.\nCALL_RESULT( SteamInventoryStartPurchaseResult_t )", "retval": "SteamAPICall_t", "name": "StartPurchase", "argsstr": "const SteamItemDef_t *pArrayItemDefs,  const uint32 *punArrayQuantity, uint32 unArrayLength", "nargs": 3, "args": [["constSteamItemDef_t*", "pArrayItemDefs"], ["constuint32*", "punArrayQuantity"], ["uint32", "unArrayLength"]], "vfindex": 25}, {"comments": "Request current prices for all applicable item definitions\nCALL_RESULT( SteamInventoryRequestPricesResult_t )", "retval": "SteamAPICall_t", "name": "RequestPrices", "argsstr": "", "args": [], "nargs": 0, "vfindex": 26}, {"comments": "Returns the number of items with prices.  Need to call RequestPrices() first.", "retval": "uint32", "name": "GetNumItemsWithPrices", "argsstr": "", "args": [], "nargs": 0, "vfindex": 27}, {"comments": "Returns item definition ids and their prices in the user's local currency.\n Need to call RequestPrices() first.", "retval": "bool", "name": "GetItemsWithPrices", "argsstr": "SteamItemDef_t *pArrayItemDefs,\n\t\t\t\t\t\t\t\t\t   uint64 *pPrices,\n\t\t\t\t\t\t\t\t\t uint32 unArrayLength", "nargs": 3, "args": [["SteamItemDef_t*", "pArrayItemDefs"], ["uint64*", "pPrices"], ["uint32", "unArrayLength"]], "vfindex": 28}, {"comments": "Retrieves the price for the item definition id\n Returns false if there is no price stored for the item definition.", "retval": "bool", "name": "GetItemPrice", "argsstr": "SteamItemDef_t iDefinition, uint64 *pPrice", "nargs": 2, "args": [["SteamItemDef_t", "iDefinition"], ["uint64*", "pPrice"]], "vfindex": 29}, {"comments": "Create a request to update properties on items", "retval": "SteamInventoryUpdateHandle_t", "name": "StartUpdateProperties", "argsstr": "", "args": [], "nargs": 0, "vfindex": 30}, {"comments": "Remove the property on the item", "retval": "bool", "name": "RemoveProperty", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName", "nargs": 3, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamItemInstanceID_t", "nItemID"], ["constchar*", "pchPropertyName"]], "vfindex": 31}, {"comments": "Accessor methods to set properties on items", "retval": "bool", "name": "SetProperty", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, const char *pchPropertyValue", "nargs": 4, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamItemInstanceID_t", "nItemID"], ["constchar*", "pchPropertyName"], ["constchar*", "pchPropertyValue"]], "vfindex": 32}, {"retval": "bool", "name": "SetProperty", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, bool bValue", "nargs": 4, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamItemInstanceID_t", "nItemID"], ["constchar*", "pchPropertyName"], ["bool", "bValue"]], "vfindex": 33}, {"retval": "bool", "name": "SetProperty", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, int64 nValue", "nargs": 4, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamItemInstanceID_t", "nItemID"], ["constchar*", "pchPropertyName"], ["int64", "nValue"]], "vfindex": 34}, {"retval": "bool", "name": "SetProperty", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamItemInstanceID_t nItemID, const char *pchPropertyName, float flValue", "nargs": 4, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamItemInstanceID_t", "nItemID"], ["constchar*", "pchPropertyName"], ["float", "flValue"]], "vfindex": 35}, {"comments": "Submit the update request by handle", "retval": "bool", "name": "SubmitUpdateProperties", "argsstr": "SteamInventoryUpdateHandle_t handle, SteamInventoryResult_t * pResultHandle", "nargs": 2, "args": [["SteamInventoryUpdateHandle_t", "handle"], ["SteamInventoryResult_t*", "pResultHandle"]], "vfindex": 36}], "cppinterface": "STEAMINVENTORY_INTERFACE_VERSION", "cppinterfacev": "STEAMINVENTORY_INTERFACE_V002", "cppclass": "ISteamInventory"}, "ISteamMatchmaking": {"funcs": [{"comments": "Game server favorites storage\n saves basic details about a multiplayer game server locally\n\n returns the number of favorites servers the user has stored", "retval": "int", "name": "GetFavoriteGameCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"comments": "Returns the details of the game server\n iGame is of range [0,GetFavoriteGameCount())\n *pnIP, *pnConnPort are filled in the with IP:port of the game server\n *punFlags specify whether the game server was stored as an explicit favorite or in the history of connections\n *pRTime32LastPlayedOnServer is filled in the with the Unix time the favorite was added", "retval": "bool", "name": "GetFavoriteGame", "argsstr": "int iGame, AppId_t *pnAppID, uint32 *pnIP, uint16 *pnConnPort, uint16 *pnQueryPort, uint32 *punFlags, uint32 *pRTime32LastPlayedOnServer", "nargs": 7, "args": [["int", "iGame"], ["AppId_t*", "pnAppID"], ["uint32*", "pnIP"], ["uint16*", "pnConnPort"], ["uint16*", "pnQueryPort"], ["uint32*", "punFlags"], ["uint32*", "pRTime32LastPlayedOnServer"]], "vfindex": 1}, {"comments": "Adds the game server to the local list; updates the time played of the server if it already exists in the list", "retval": "int", "name": "AddFavoriteGame", "argsstr": "AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags, uint32 rTime32LastPlayedOnServer", "nargs": 6, "args": [["AppId_t", "nAppID"], ["uint32", "nIP"], ["uint16", "nConnPort"], ["uint16", "nQueryPort"], ["uint32", "unFlags"], ["uint32", "rTime32LastPlayedOnServer"]], "vfindex": 2}, {"comments": "Removes the game server from the local storage; returns true if one was removed", "retval": "bool", "name": "RemoveFavoriteGame", "argsstr": "AppId_t nAppID, uint32 nIP, uint16 nConnPort, uint16 nQueryPort, uint32 unFlags", "nargs": 5, "args": [["AppId_t", "nAppID"], ["uint32", "nIP"], ["uint16", "nConnPort"], ["uint16", "nQueryPort"], ["uint32", "unFlags"]], "vfindex": 3}, {"comments": "/\n Game lobby functions\n\n Get a list of relevant lobbies\n this is an asynchronous request\n results will be returned by LobbyMatchList_t callback & call result, with the number of lobbies found\n this will never return lobbies that are full\n to add more filter, the filter calls below need to be call before each and every RequestLobbyList() call\n use the CCallResult<> object in steam_api.h to match the SteamAPICall_t call result to a function in an object, e.g.\n/*\nclass CMyLobbyListManager\n{\nCCallResult<CMyLobbyListManager, LobbyMatchList_t> m_CallResultLobbyMatchList;\nvoid FindLobbies()\n{\n SteamMatchmaking()->AddRequestLobbyListFilter*() functions would be called here, before RequestLobbyList()\nSteamAPICall_t hSteamAPICall = SteamMatchmaking()->RequestLobbyList();\nm_CallResultLobbyMatchList.Set( hSteamAPICall, this, &CMyLobbyListManager::OnLobbyMatchList );\n}\n\nvoid OnLobbyMatchList( LobbyMatchList_t *pLobbyMatchList, bool bIOFailure )\n{\n lobby list has be retrieved from Steam back-end, use results\n}\n}\n*/\n \nCALL_RESULT( LobbyMatchList_t )", "retval": "SteamAPICall_t", "name": "RequestLobbyList", "argsstr": "", "args": [], "nargs": 0, "vfindex": 4}, {"comments": "Filters for lobbies\n this needs to be called before RequestLobbyList() to take effect\n these are cleared on each call to RequestLobbyList()", "retval": "void", "name": "AddRequestLobbyListStringFilter", "argsstr": "const char *pchKeyToMatch, const char *pchValueToMatch, ELobbyComparison eComparisonType", "nargs": 3, "args": [["constchar*", "pchKeyToMatch"], ["constchar*", "pchValueToMatch"], ["ELobbyComparison", "eComparisonType"]], "vfindex": 5}, {"comments": "Numerical comparison", "retval": "void", "name": "AddRequestLobbyListNumericalFilter", "argsstr": "const char *pchKeyToMatch, int nValueToMatch, ELobbyComparison eComparisonType", "nargs": 3, "args": [["constchar*", "pchKeyToMatch"], ["int", "nValueToMatch"], ["ELobbyComparison", "eComparisonType"]], "vfindex": 6}, {"comments": "Returns results closest to the specified value. Multiple near filters can be added, with early filters taking precedence", "retval": "void", "name": "AddRequestLobbyListNearValueFilter", "argsstr": "const char *pchKeyToMatch, int nValueToBeCloseTo", "nargs": 2, "args": [["constchar*", "pchKeyToMatch"], ["int", "nValueToBeCloseTo"]], "vfindex": 7}, {"comments": "Returns only lobbies with the specified number of slots available", "retval": "void", "name": "AddRequestLobbyListFilterSlotsAvailable", "argsstr": "int nSlotsAvailable", "nargs": 1, "args": [["int", "nSlotsAvailable"]], "vfindex": 8}, {"comments": "Sets the distance for which we should search for lobbies (based on users IP address to location map on the Steam backed)", "retval": "void", "name": "AddRequestLobbyListDistanceFilter", "argsstr": "ELobbyDistanceFilter eLobbyDistanceFilter", "nargs": 1, "args": [["ELobbyDistanceFilter", "eLobbyDistanceFilter"]], "vfindex": 9}, {"comments": "Sets how many results to return, the lower the count the faster it is to download the lobby results & details to the client", "retval": "void", "name": "AddRequestLobbyListResultCountFilter", "argsstr": "int cMaxResults", "nargs": 1, "args": [["int", "cMaxResults"]], "vfindex": 10}, {"retval": "void", "name": "AddRequestLobbyListCompatibleMembersFilter", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 11}, {"comments": "Returns the CSteamID of a lobby, as retrieved by a RequestLobbyList call\n should only be called after a LobbyMatchList_t callback is received\n iLobby is of the range [0, LobbyMatchList_t::m_nLobbiesMatching)\n the returned CSteamID::IsValid() will be false if iLobby is out of range", "retval": "CSteamID", "name": "GetLobbyByIndex", "argsstr": "int iLobby", "nargs": 1, "args": [["int", "iLobby"]], "vfindex": 12}, {"comments": "Create a lobby on the Steam servers.\n If private, then the lobby will not be returned by any RequestLobbyList() call; the CSteamID\n of the lobby will need to be communicated via game channels or via InviteUserToLobby()\n this is an asynchronous request\n results will be returned by LobbyCreated_t callback and call result; lobby is joined & ready to use at this point\n a LobbyEnter_t callback will also be received (since the local user is joining their own lobby)\nCALL_RESULT( LobbyCreated_t )", "retval": "SteamAPICall_t", "name": "CreateLobby", "argsstr": "ELobbyType eLobbyType, int cMaxMembers", "nargs": 2, "args": [["ELobbyType", "eLobbyType"], ["int", "cMaxMembers"]], "vfindex": 13}, {"comments": "Joins an existing lobby\n this is an asynchronous request\n results will be returned by LobbyEnter_t callback & call result, check m_EChatRoomEnterResponse to see if was successful\n lobby metadata is available to use immediately on this call completing\nCALL_RESULT( LobbyEnter_t )", "retval": "SteamAPICall_t", "name": "JoinLobby", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 14}, {"comments": "Leave a lobby; this will take effect immediately on the client side\n other users in the lobby will be notified by a LobbyChatUpdate_t callback", "retval": "void", "name": "LeaveLobby", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 15}, {"comments": "Invite another user to the lobby\n the target user will receive a LobbyInvite_t callback\n will return true if the invite is successfully sent, whether or not the target responds\n returns false if the local user is not connected to the Steam servers\n if the other user clicks the join link, a GameLobbyJoinRequested_t will be posted if the user is in-game,\n or if the game isn't running yet the game will be launched with the parameter +connect_lobby <64-bit lobby id>", "retval": "bool", "name": "InviteUserToLobby", "argsstr": "CSteamID steamIDLobby, CSteamID steamIDInvitee", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["CSteamID", "steamIDInvitee"]], "vfindex": 16}, {"comments": "Lobby iteration, for viewing details of users in a lobby\n only accessible if the lobby user is a member of the specified lobby\n persona information for other lobby members (name, avatar, etc.) will be asynchronously received\n and accessible via ISteamFriends interface\n\n returns the number of users in the specified lobby", "retval": "int", "name": "GetNumLobbyMembers", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 17}, {"comments": "Returns the CSteamID of a user in the lobby\n iMember is of range [0,GetNumLobbyMembers())\n note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby", "retval": "CSteamID", "name": "GetLobbyMemberByIndex", "argsstr": "CSteamID steamIDLobby, int iMember", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["int", "iMember"]], "vfindex": 18}, {"comments": "Get data associated with this lobby\n takes a simple key, and returns the string associated with it\n \"\" will be returned if no value is set, or if steamIDLobby is invalid", "retval": "const char *", "name": "GetLobbyData", "argsstr": "CSteamID steamIDLobby, const char *pchKey", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["constchar*", "pchKey"]], "vfindex": 19}, {"comments": "Sets a key/value pair in the lobby metadata\n each user in the lobby will be broadcast this new value, and any new users joining will receive any existing data\n this can be used to set lobby names, map, etc.\n to reset a key, just set it to \"\"\n other users in the lobby will receive notification of the lobby data change via a LobbyDataUpdate_t callback", "retval": "bool", "name": "SetLobbyData", "argsstr": "CSteamID steamIDLobby, const char *pchKey, const char *pchValue", "nargs": 3, "args": [["CSteamID", "steamIDLobby"], ["constchar*", "pchKey"], ["constchar*", "pchValue"]], "vfindex": 20}, {"comments": "Returns the number of metadata keys set on the specified lobby", "retval": "int", "name": "GetLobbyDataCount", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 21}, {"comments": "Returns a lobby metadata key/values pair by index, of range [0, GetLobbyDataCount())", "retval": "bool", "name": "GetLobbyDataByIndex", "argsstr": "CSteamID steamIDLobby, int iLobbyData, char *pchKey, int cchKeyBufferSize, char *pchValue, int cchValueBufferSize", "nargs": 6, "args": [["CSteamID", "steamIDLobby"], ["int", "iLobbyData"], ["char*", "pchKey"], ["int", "cchKeyBufferSize"], ["char*", "pchValue"], ["int", "cchValueBufferSize"]], "vfindex": 22}, {"comments": "Removes a metadata key from the lobby", "retval": "bool", "name": "DeleteLobbyData", "argsstr": "CSteamID steamIDLobby, const char *pchKey", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["constchar*", "pchKey"]], "vfindex": 23}, {"comments": "Gets per-user metadata for someone in this lobby", "retval": "const char *", "name": "GetLobbyMemberData", "argsstr": "CSteamID steamIDLobby, CSteamID steamIDUser, const char *pchKey", "nargs": 3, "args": [["CSteamID", "steamIDLobby"], ["CSteamID", "steamIDUser"], ["constchar*", "pchKey"]], "vfindex": 24}, {"comments": "Sets per-user metadata (for the local user implicitly)", "retval": "void", "name": "SetLobbyMemberData", "argsstr": "CSteamID steamIDLobby, const char *pchKey, const char *pchValue", "nargs": 3, "args": [["CSteamID", "steamIDLobby"], ["constchar*", "pchKey"], ["constchar*", "pchValue"]], "vfindex": 25}, {"comments": "Broadcasts a chat message to the all the users in the lobby\n users in the lobby (including the local user) will receive a LobbyChatMsg_t callback\n returns true if the message is successfully sent\n pvMsgBody can be binary or text data, up to 4k\n if pvMsgBody is text, cubMsgBody should be strlen( text ) + 1, to include the null terminator", "retval": "bool", "name": "SendLobbyChatMsg", "argsstr": "CSteamID steamIDLobby, const void *pvMsgBody, int cubMsgBody", "nargs": 3, "args": [["CSteamID", "steamIDLobby"], ["constvoid*", "pvMsgBody"], ["int", "cubMsgBody"]], "vfindex": 26}, {"comments": "Get a chat message as specified in a LobbyChatMsg_t callback\n iChatID is the LobbyChatMsg_t::m_iChatID value in the callback\n *pSteamIDUser is filled in with the CSteamID of the member\n *pvData is filled in with the message itself\n return value is the number of bytes written into the buffer", "retval": "int", "name": "GetLobbyChatEntry", "argsstr": "CSteamID steamIDLobby, int iChatID,  CSteamID *pSteamIDUser, void *pvData, int cubData, EChatEntryType *peChatEntryType", "nargs": 6, "args": [["CSteamID", "steamIDLobby"], ["int", "iChatID"], ["CSteamID*", "pSteamIDUser"], ["void*", "pvData"], ["int", "cubData"], ["EChatEntryType*", "peChatEntryType"]], "vfindex": 27}, {"comments": "Refreshes metadata for a lobby you're not necessarily in right now\n you never do this for lobbies you're a member of, only if your\n this will send down all the metadata associated with a lobby\n this is an asynchronous call\n returns false if the local user is not connected to the Steam servers\n results will be returned by a LobbyDataUpdate_t callback\n if the specified lobby doesn't exist, LobbyDataUpdate_t::m_bSuccess will be set to false", "retval": "bool", "name": "RequestLobbyData", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 28}, {"comments": "Sets the game server associated with the lobby\n usually at this point, the users will join the specified game server\n either the IP/Port or the steamID of the game server has to be valid, depending on how you want the clients to be able to connect", "retval": "void", "name": "SetLobbyGameServer", "argsstr": "CSteamID steamIDLobby, uint32 unGameServerIP, uint16 unGameServerPort, CSteamID steamIDGameServer", "nargs": 4, "args": [["CSteamID", "steamIDLobby"], ["uint32", "unGameServerIP"], ["uint16", "unGameServerPort"], ["CSteamID", "steamIDGameServer"]], "vfindex": 29}, {"comments": "Returns the details of a game server set in a lobby - returns false if there is no game server set, or that lobby doesn't exist", "retval": "bool", "name": "GetLobbyGameServer", "argsstr": "CSteamID steamIDLobby, uint32 *punGameServerIP, uint16 *punGameServerPort,  CSteamID *psteamIDGameServer", "nargs": 4, "args": [["CSteamID", "steamIDLobby"], ["uint32*", "punGameServerIP"], ["uint16*", "punGameServerPort"], ["CSteamID*", "psteamIDGameServer"]], "vfindex": 30}, {"comments": "Set the limit on the # of users who can join the lobby", "retval": "bool", "name": "SetLobbyMemberLimit", "argsstr": "CSteamID steamIDLobby, int cMaxMembers", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["int", "cMaxMembers"]], "vfindex": 31}, {"comments": "Returns the current limit on the # of users who can join the lobby; returns 0 if no limit is defined", "retval": "int", "name": "GetLobbyMemberLimit", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 32}, {"comments": "Updates which type of lobby it is\n only lobbies that are k_ELobbyTypePublic or k_ELobbyTypeInvisible, and are set to joinable, will be returned by RequestLobbyList() calls", "retval": "bool", "name": "SetLobbyType", "argsstr": "CSteamID steamIDLobby, ELobbyType eLobbyType", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["ELobbyType", "eLobbyType"]], "vfindex": 33}, {"comments": "Sets whether or not a lobby is joinable - defaults to true for a new lobby\n if set to false, no user can join, even if they are a friend or have been invited", "retval": "bool", "name": "SetLobbyJoinable", "argsstr": "CSteamID steamIDLobby, bool bLobbyJoinable", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["bool", "bLobbyJoinable"]], "vfindex": 34}, {"comments": "Returns the current lobby owner\n you must be a member of the lobby to access this\n there always one lobby owner - if the current owner leaves, another user will become the owner\n it is possible (bur rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner", "retval": "CSteamID", "name": "GetLobbyOwner", "argsstr": "CSteamID steamIDLobby", "nargs": 1, "args": [["CSteamID", "steamIDLobby"]], "vfindex": 35}, {"comments": "Changes who the lobby owner is\n you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby\n after completion, the local user will no longer be the owner", "retval": "bool", "name": "SetLobbyOwner", "argsstr": "CSteamID steamIDLobby, CSteamID steamIDNewOwner", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["CSteamID", "steamIDNewOwner"]], "vfindex": 36}, {"comments": "Link two lobbies for the purposes of checking player compatibility\n you must be the lobby owner of both lobbies", "retval": "bool", "name": "SetLinkedLobby", "argsstr": "CSteamID steamIDLobby, CSteamID steamIDLobbyDependent", "nargs": 2, "args": [["CSteamID", "steamIDLobby"], ["CSteamID", "steamIDLobbyDependent"]], "vfindex": 37}, {"comments": "Changes who the lobby owner is\n you must be the lobby owner for this to succeed, and steamIDNewOwner must be in the lobby\n after completion, the local user will no longer be the owner", "retval": "void", "name": "CheckForPSNGameBootInvite", "argsstr": "unsigned int iGameBootAttributes", "nargs": 1, "args": [["unsignedint", "iGameBootAttributes"]], "vfindex": 38}, {"comments": "-----------------------------------------------------------------------------\n Callback interfaces for server list functions (see ISteamMatchmakingServers below)\n\n The idea here is that your game code implements objects that implement these\n interfaces to receive callback notifications after calling asynchronous functions\n inside the ISteamMatchmakingServers() interface below.\n\n This is different than normal Steam callback handling due to the potentially\n large size of server lists.\n-----------------------------------------------------------------------------\n\n-----------------------------------------------------------------------------\n Typedef for handle type you will receive when requesting server list.\n-----------------------------------------------------------------------------\ntypedef void* HServerListRequest;\n\n-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after a server list refresh\n or an individual server update.\n\n Since you get these callbacks after requesting full list refreshes you will\n usually implement this interface inside an object like CServerBrowser.  If that\n object is getting destructed you should use ISteamMatchMakingServers()->CancelQuery()\n to cancel any in-progress queries so you don't get a callback into the destructed\n object and crash.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingServerListResponse\n{\npublic:\n Server has responded ok with updated data", "retval": "void", "name": "ServerResponded", "argsstr": "HServerListRequest hRequest, int iServer", "nargs": 2, "args": [["HServerListRequest", "hRequest"], ["int", "iServer"]], "vfindex": 39}, {"comments": "Server has failed to respond", "retval": "void", "name": "ServerFailedToRespond", "argsstr": "HServerListRequest hRequest, int iServer", "nargs": 2, "args": [["HServerListRequest", "hRequest"], ["int", "iServer"]], "vfindex": 40}, {"comments": "A list refresh you had initiated is now 100% completed", "retval": "void", "name": "RefreshComplete", "argsstr": "HServerListRequest hRequest, EMatchMakingServerResponse response", "nargs": 2, "args": [["HServerListRequest", "hRequest"], ["EMatchMakingServerResponse", "response"]], "vfindex": 41}, {"comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after pinging an individual server \n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->PingServer() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingPingResponse\n{\npublic:\n Server has responded successfully and has updated data", "retval": "void", "name": "ServerResponded", "argsstr": "gameserveritem_t &server", "nargs": 1, "args": [["gameserveritem_t", "&server"]], "vfindex": 42}, {"comments": "Server failed to respond to the ping request", "retval": "void", "name": "ServerFailedToRespond", "argsstr": "", "args": [], "nargs": 0, "vfindex": 43}, {"comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after requesting details on\n who is playing on a particular server.\n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->PlayerDetails() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingPlayersResponse\n{\npublic:\n Got data on a new player on the server -- you'll get this callback once per player\n on the server which you have requested player data on.", "retval": "void", "name": "AddPlayerToList", "argsstr": "const char *pchName, int nScore, float flTimePlayed", "nargs": 3, "args": [["constchar*", "pchName"], ["int", "nScore"], ["float", "flTimePlayed"]], "vfindex": 44}, {"comments": "The server failed to respond to the request for player details", "retval": "void", "name": "PlayersFailedToRespond", "argsstr": "", "args": [], "nargs": 0, "vfindex": 45}, {"comments": "The server has finished responding to the player details request \n (ie, you won't get anymore AddPlayerToList callbacks)", "retval": "void", "name": "PlayersRefreshComplete", "argsstr": "", "args": [], "nargs": 0, "vfindex": 46}, {"comments": "-----------------------------------------------------------------------------\n Purpose: Callback interface for receiving responses after requesting rules\n details on a particular server.\n\n These callbacks all occur in response to querying an individual server\n via the ISteamMatchmakingServers()->ServerRules() call below.  If you are \n destructing an object that implements this interface then you should call \n ISteamMatchmakingServers()->CancelServerQuery() passing in the handle to the query\n which is in progress.  Failure to cancel in progress queries when destructing\n a callback handler may result in a crash when a callback later occurs.\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingRulesResponse\n{\npublic:\n Got data on a rule on the server -- you'll get one of these per rule defined on\n the server you are querying", "retval": "void", "name": "RulesResponded", "argsstr": "const char *pchRule, const char *pchValue", "nargs": 2, "args": [["constchar*", "pchRule"], ["constchar*", "pchValue"]], "vfindex": 47}, {"comments": "The server failed to respond to the request for rule details", "retval": "void", "name": "RulesFailedToRespond", "argsstr": "", "args": [], "nargs": 0, "vfindex": 48}, {"comments": "The server has finished responding to the rule details request \n (ie, you won't get anymore RulesResponded callbacks)", "retval": "void", "name": "RulesRefreshComplete", "argsstr": "", "args": [], "nargs": 0, "vfindex": 49}, {"comments": "-----------------------------------------------------------------------------\n Typedef for handle type you will receive when querying details on an individual server.\n-----------------------------------------------------------------------------\ntypedef int HServerQuery;\nconst int HSERVERQUERY_INVALID = 0xffffffff;\n\n-----------------------------------------------------------------------------\n Purpose: Functions for match making services for clients to get to game lists and details\n-----------------------------------------------------------------------------\nclass ISteamMatchmakingServers\n{\npublic:\n Request a new list of servers of a particular type.  These calls each correspond to one of the EMatchMakingType values.\n Each call allocates a new asynchronous request object.\n Request object must be released by calling ReleaseRequest( hServerListRequest )", "retval": "HServerListRequest", "name": "RequestInternetServerList", "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 4, "args": [["AppId_t", "iApp"], ["MatchMakingKeyValuePair_t*", "*ppchFilters"], ["uint32", "nFilters"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 50}, {"retval": "HServerListRequest", "name": "RequestLANServerList", "argsstr": "AppId_t iApp, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 2, "args": [["AppId_t", "iApp"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 51}, {"retval": "HServerListRequest", "name": "RequestFriendsServerList", "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 4, "args": [["AppId_t", "iApp"], ["MatchMakingKeyValuePair_t*", "*ppchFilters"], ["uint32", "nFilters"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 52}, {"retval": "HServerListRequest", "name": "RequestFavoritesServerList", "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 4, "args": [["AppId_t", "iApp"], ["MatchMakingKeyValuePair_t*", "*ppchFilters"], ["uint32", "nFilters"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 53}, {"retval": "HServerListRequest", "name": "RequestHistoryServerList", "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 4, "args": [["AppId_t", "iApp"], ["MatchMakingKeyValuePair_t*", "*ppchFilters"], ["uint32", "nFilters"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 54}, {"retval": "HServerListRequest", "name": "RequestSpectatorServerList", "argsstr": "AppId_t iApp,  MatchMakingKeyValuePair_t **ppchFilters, uint32 nFilters, ISteamMatchmakingServerListResponse *pRequestServersResponse", "nargs": 4, "args": [["AppId_t", "iApp"], ["MatchMakingKeyValuePair_t*", "*ppchFilters"], ["uint32", "nFilters"], ["ISteamMatchmakingServerListResponse*", "pRequestServersResponse"]], "vfindex": 55}, {"comments": "Releases the asynchronous request object and cancels any pending query on it if there's a pending query in progress.\n RefreshComplete callback is not posted when request is released.", "retval": "void", "name": "ReleaseRequest", "argsstr": "HServerListRequest hServerListRequest", "nargs": 1, "args": [["HServerListRequest", "hServerListRequest"]], "vfindex": 56}, {"comments": "Get details on a given server in the list, you can get the valid range of index\n values by calling GetServerCount().  You will also receive index values in \n ISteamMatchmakingServerListResponse::ServerResponded() callbacks", "retval": "gameserveritem_t *", "name": "GetServerDetails", "argsstr": "HServerListRequest hRequest, int iServer", "nargs": 2, "args": [["HServerListRequest", "hRequest"], ["int", "iServer"]], "vfindex": 57}, {"comments": "Cancel an request which is operation on the given list type.  You should call this to cancel\n any in-progress requests before destructing a callback object that may have been passed \n to one of the above list request calls.  Not doing so may result in a crash when a callback\n occurs on the destructed object.\n Canceling a query does not release the allocated request handle.\n The request handle must be released using ReleaseRequest( hRequest )", "retval": "void", "name": "CancelQuery", "argsstr": "HServerListRequest hRequest", "nargs": 1, "args": [["HServerListRequest", "hRequest"]], "vfindex": 58}, {"comments": "Ping every server in your list again but don't update the list of servers\n Query callback installed when the server list was requested will be used\n again to post notifications and RefreshComplete, so the callback must remain\n valid until another RefreshComplete is called on it or the request\n is released with ReleaseRequest( hRequest )", "retval": "void", "name": "RefreshQuery", "argsstr": "HServerListRequest hRequest", "nargs": 1, "args": [["HServerListRequest", "hRequest"]], "vfindex": 59}, {"comments": "Returns true if the list is currently refreshing its server list", "retval": "bool", "name": "IsRefreshing", "argsstr": "HServerListRequest hRequest", "nargs": 1, "args": [["HServerListRequest", "hRequest"]], "vfindex": 60}, {"comments": "How many servers in the given list, GetServerDetails above takes 0... GetServerCount() - 1", "retval": "int", "name": "GetServerCount", "argsstr": "HServerListRequest hRequest", "nargs": 1, "args": [["HServerListRequest", "hRequest"]], "vfindex": 61}, {"comments": "Refresh a single server inside of a query (rather than all the servers )", "retval": "void", "name": "RefreshServer", "argsstr": "HServerListRequest hRequest, int iServer", "nargs": 2, "args": [["HServerListRequest", "hRequest"], ["int", "iServer"]], "vfindex": 62}, {"comments": "-----------------------------------------------------------------------------\n Queries to individual servers directly via IP/Port\n-----------------------------------------------------------------------------\n\n Request updated ping time and other details from a single server", "retval": "HServerQuery", "name": "PingServer", "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingPingResponse *pRequestServersResponse", "nargs": 3, "args": [["uint32", "unIP"], ["uint16", "usPort"], ["ISteamMatchmakingPingResponse*", "pRequestServersResponse"]], "vfindex": 63}, {"comments": "Request the list of players currently playing on a server", "retval": "HServerQuery", "name": "PlayerDetails", "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingPlayersResponse *pRequestServersResponse", "nargs": 3, "args": [["uint32", "unIP"], ["uint16", "usPort"], ["ISteamMatchmakingPlayersResponse*", "pRequestServersResponse"]], "vfindex": 64}, {"comments": "Request the list of rules that the server is running (See ISteamGameServer::SetKeyValue() to set the rules server side)", "retval": "HServerQuery", "name": "ServerRules", "argsstr": "uint32 unIP, uint16 usPort, ISteamMatchmakingRulesResponse *pRequestServersResponse", "nargs": 3, "args": [["uint32", "unIP"], ["uint16", "usPort"], ["ISteamMatchmakingRulesResponse*", "pRequestServersResponse"]], "vfindex": 65}, {"comments": "Cancel an outstanding Ping/Players/Rules query from above.  You should call this to cancel\n any in-progress requests before destructing a callback object that may have been passed \n to one of the above calls to avoid crashing when callbacks occur.", "retval": "void", "name": "CancelServerQuery", "argsstr": "HServerQuery hServerQuery", "nargs": 1, "args": [["HServerQuery", "hServerQuery"]], "vfindex": 66}], "cppinterface": "STEAMMATCHMAKING_INTERFACE_VERSION", "cppinterfacev": "SteamMatchMaking009", "cppclass": "ISteamMatchmaking"}, "ISteamMusic": {"funcs": [{"retval": "bool", "name": "BIsEnabled", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "bool", "name": "BIsPlaying", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"retval": "AudioPlayback_Status", "name": "GetPlaybackStatus", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"retval": "void", "name": "Play", "argsstr": "", "args": [], "nargs": 0, "vfindex": 3}, {"retval": "void", "name": "Pause", "argsstr": "", "args": [], "nargs": 0, "vfindex": 4}, {"retval": "void", "name": "PlayPrevious", "argsstr": "", "args": [], "nargs": 0, "vfindex": 5}, {"retval": "void", "name": "PlayNext", "argsstr": "", "args": [], "nargs": 0, "vfindex": 6}, {"comments": "Volume is between 0.0 and 1.0", "retval": "void", "name": "SetVolume", "argsstr": "float flVolume", "nargs": 1, "args": [["float", "flVolume"]], "vfindex": 7}, {"retval": "float", "name": "GetVolume", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}], "cppinterface": "STEAMMUSIC_INTERFACE_VERSION", "cppinterfacev": "STEAMMUSIC_INTERFACE_VERSION001", "cppclass": "ISteamMusic"}, "ISteamMusicRemote": {"funcs": [{"comments": "Service Definition", "retval": "bool", "name": "RegisterSteamMusicRemote", "argsstr": "const char *pchName", "nargs": 1, "args": [["constchar*", "pchName"]], "vfindex": 0}, {"retval": "bool", "name": "DeregisterSteamMusicRemote", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"retval": "bool", "name": "BIsCurrentMusicRemote", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"retval": "bool", "name": "BActivationSuccess", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 3}, {"retval": "bool", "name": "SetDisplayName", "argsstr": "const char *pchDisplayName", "nargs": 1, "args": [["constchar*", "pchDisplayName"]], "vfindex": 4}, {"retval": "bool", "name": "SetPNGIcon_64x64", "argsstr": "void *pvBuffer, uint32 cbBufferLength", "nargs": 2, "args": [["void*", "pvBuffer"], ["uint32", "cbBufferLength"]], "vfindex": 5}, {"comments": "Abilities for the user interface", "retval": "bool", "name": "EnablePlayPrevious", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 6}, {"retval": "bool", "name": "EnablePlayNext", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 7}, {"retval": "bool", "name": "EnableShuffled", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 8}, {"retval": "bool", "name": "EnableLooped", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 9}, {"retval": "bool", "name": "EnableQueue", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 10}, {"retval": "bool", "name": "EnablePlaylists", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 11}, {"comments": "Status", "retval": "bool", "name": "UpdatePlaybackStatus", "argsstr": "AudioPlayback_Status nStatus", "nargs": 1, "args": [["AudioPlayback_Status", "nStatus"]], "vfindex": 12}, {"retval": "bool", "name": "UpdateShuffled", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 13}, {"retval": "bool", "name": "UpdateLooped", "argsstr": "bool bValue", "nargs": 1, "args": [["bool", "bValue"]], "vfindex": 14}, {"retval": "bool", "name": "UpdateVolume", "argsstr": "float flValue", "nargs": 1, "args": [["float", "flValue"]], "vfindex": 15}, {"comments": "Volume is between 0.0 and 1.0\n\n Current Entry", "retval": "bool", "name": "CurrentEntryWillChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 16}, {"retval": "bool", "name": "CurrentEntryIsAvailable", "argsstr": "bool bAvailable", "nargs": 1, "args": [["bool", "bAvailable"]], "vfindex": 17}, {"retval": "bool", "name": "UpdateCurrentEntryText", "argsstr": "const char *pchText", "nargs": 1, "args": [["constchar*", "pchText"]], "vfindex": 18}, {"retval": "bool", "name": "UpdateCurrentEntryElapsedSeconds", "argsstr": "int nValue", "nargs": 1, "args": [["int", "nValue"]], "vfindex": 19}, {"retval": "bool", "name": "UpdateCurrentEntryCoverArt", "argsstr": "void *pvBuffer, uint32 cbBufferLength", "nargs": 2, "args": [["void*", "pvBuffer"], ["uint32", "cbBufferLength"]], "vfindex": 20}, {"retval": "bool", "name": "CurrentEntryDidChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 21}, {"comments": "Queue", "retval": "bool", "name": "QueueWillChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 22}, {"retval": "bool", "name": "ResetQueueEntries", "argsstr": "", "args": [], "nargs": 0, "vfindex": 23}, {"retval": "bool", "name": "SetQueueEntry", "argsstr": "int nID, int nPosition, const char *pchEntryText", "nargs": 3, "args": [["int", "nID"], ["int", "nPosition"], ["constchar*", "pchEntryText"]], "vfindex": 24}, {"retval": "bool", "name": "SetCurrentQueueEntry", "argsstr": "int nID", "nargs": 1, "args": [["int", "nID"]], "vfindex": 25}, {"retval": "bool", "name": "QueueDidChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 26}, {"comments": "Playlist", "retval": "bool", "name": "PlaylistWillChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 27}, {"retval": "bool", "name": "ResetPlaylistEntries", "argsstr": "", "args": [], "nargs": 0, "vfindex": 28}, {"retval": "bool", "name": "SetPlaylistEntry", "argsstr": "int nID, int nPosition, const char *pchEntryText", "nargs": 3, "args": [["int", "nID"], ["int", "nPosition"], ["constchar*", "pchEntryText"]], "vfindex": 29}, {"retval": "bool", "name": "SetCurrentPlaylistEntry", "argsstr": "int nID", "nargs": 1, "args": [["int", "nID"]], "vfindex": 30}, {"retval": "bool", "name": "PlaylistDidChange", "argsstr": "", "args": [], "nargs": 0, "vfindex": 31}], "cppinterface": "STEAMMUSICREMOTE_INTERFACE_VERSION", "cppinterfacev": "STEAMMUSICREMOTE_INTERFACE_VERSION001", "cppclass": "ISteamMusicRemote"}, "ISteamNetworking": {"funcs": [{"comments": "Session-less connection functions\n    automatically establishes NAT-traversing or Relay server connections\n\n Sends a P2P packet to the specified user\n UDP-like, unreliable and a max packet size of 1200 bytes\n the first packet send may be delayed as the NAT-traversal code runs\n if we can't get through to the user, an error will be posted via the callback P2PSessionConnectFail_t\n see EP2PSend enum above for the descriptions of the different ways of sending packets\n\n nChannel is a routing number you can use to help route message to different systems - you'll have to call ReadP2PPacket() \n with the same channel number in order to retrieve the data on the other end\n using different channels to talk to the same user will still use the same underlying p2p connection, saving on resources", "retval": "bool", "name": "SendP2PPacket", "argsstr": "CSteamID steamIDRemote, const void *pubData, uint32 cubData, EP2PSend eP2PSendType, int nChannel = 0", "nargs": 5, "args": [["CSteamID", "steamIDRemote"], ["constvoid*", "pubData"], ["uint32", "cubData"], ["EP2PSend", "eP2PSendType"], ["intnChannel=", "0"]], "vfindex": 0}, {"comments": "Returns true if any data is available for read, and the amount of data that will need to be read", "retval": "bool", "name": "IsP2PPacketAvailable", "argsstr": "uint32 *pcubMsgSize, int nChannel = 0", "nargs": 2, "args": [["uint32*", "pcubMsgSize"], ["intnChannel=", "0"]], "vfindex": 1}, {"comments": "Reads in a packet that has been sent from another user via SendP2PPacket()\n returns the size of the message and the steamID of the user who sent it in the last two parameters\n if the buffer passed in is too small, the message will be truncated\n this call is not blocking, and will return false if no data is available", "retval": "bool", "name": "ReadP2PPacket", "argsstr": "void *pubDest, uint32 cubDest, uint32 *pcubMsgSize, CSteamID *psteamIDRemote, int nChannel = 0", "nargs": 5, "args": [["void*", "pubDest"], ["uint32", "cubDest"], ["uint32*", "pcubMsgSize"], ["CSteamID*", "psteamIDRemote"], ["intnChannel=", "0"]], "vfindex": 2}, {"comments": "AcceptP2PSessionWithUser() should only be called in response to a P2PSessionRequest_t callback\n P2PSessionRequest_t will be posted if another user tries to send you a packet that you haven't talked to yet\n if you don't want to talk to the user, just ignore the request\n if the user continues to send you packets, another P2PSessionRequest_t will be posted periodically\n this may be called multiple times for a single user\n (if you've called SendP2PPacket() on the other user, this implicitly accepts the session request)", "retval": "bool", "name": "AcceptP2PSessionWithUser", "argsstr": "CSteamID steamIDRemote", "nargs": 1, "args": [["CSteamID", "steamIDRemote"]], "vfindex": 3}, {"comments": "Call CloseP2PSessionWithUser() when you're done talking to a user, will free up resources under-the-hood\n if the remote user tries to send data to you again, another P2PSessionRequest_t callback will be posted", "retval": "bool", "name": "CloseP2PSessionWithUser", "argsstr": "CSteamID steamIDRemote", "nargs": 1, "args": [["CSteamID", "steamIDRemote"]], "vfindex": 4}, {"comments": "Call CloseP2PChannelWithUser() when you're done talking to a user on a specific channel. Once all channels\n open channels to a user have been closed, the open session to the user will be closed and new data from this\n user will trigger a P2PSessionRequest_t callback", "retval": "bool", "name": "CloseP2PChannelWithUser", "argsstr": "CSteamID steamIDRemote, int nChannel", "nargs": 2, "args": [["CSteamID", "steamIDRemote"], ["int", "nChannel"]], "vfindex": 5}, {"comments": "Fills out P2PSessionState_t structure with details about the underlying connection to the user\n should only needed for debugging purposes\n returns false if no connection exists to the specified user", "retval": "bool", "name": "GetP2PSessionState", "argsstr": "CSteamID steamIDRemote, P2PSessionState_t *pConnectionState", "nargs": 2, "args": [["CSteamID", "steamIDRemote"], ["P2PSessionState_t*", "pConnectionState"]], "vfindex": 6}, {"comments": "Allow P2P connections to fall back to being relayed through the Steam servers if a direct connection\n or NAT-traversal cannot be established. Only applies to connections created after setting this value,\n or to existing connections that need to automatically reconnect after this value is set.\n\n P2P packet relay is allowed by default", "retval": "bool", "name": "AllowP2PPacketRelay", "argsstr": "bool bAllow", "nargs": 1, "args": [["bool", "bAllow"]], "vfindex": 7}, {"comments": "LISTEN / CONNECT style interface functions\n\n This is an older set of functions designed around the Berkeley TCP sockets model\n it's preferential that you use the above P2P functions, they're more robust\n and these older functions will be removed eventually\n\n\n\n\n creates a socket and listens others to connect\n will trigger a SocketStatusCallback_t callback on another client connecting\n nVirtualP2PPort is the unique ID that the client will connect to, in case you have multiple ports\nthis can usually just be 0 unless you want multiple sets of connections\n unIP is the local IP address to bind to\npass in 0 if you just want the default local IP\n unPort is the port to use\npass in 0 if you don't want users to be able to connect via IP/Port, but expect to be always peer-to-peer connections only", "retval": "SNetListenSocket_t", "name": "CreateListenSocket", "argsstr": "int nVirtualP2PPort, uint32 nIP, uint16 nPort, bool bAllowUseOfPacketRelay", "nargs": 4, "args": [["int", "nVirtualP2PPort"], ["uint32", "nIP"], ["uint16", "nPort"], ["bool", "bAllowUseOfPacketRelay"]], "vfindex": 8}, {"comments": "Creates a socket and begin connection to a remote destination\n can connect via a known steamID (client or game server), or directly to an IP\n on success will trigger a SocketStatusCallback_t callback\n on failure or timeout will trigger a SocketStatusCallback_t callback with a failure code in m_eSNetSocketState", "retval": "SNetSocket_t", "name": "CreateP2PConnectionSocket", "argsstr": "CSteamID steamIDTarget, int nVirtualPort, int nTimeoutSec, bool bAllowUseOfPacketRelay", "nargs": 4, "args": [["CSteamID", "steamIDTarget"], ["int", "nVirtualPort"], ["int", "nTimeoutSec"], ["bool", "bAllowUseOfPacketRelay"]], "vfindex": 9}, {"retval": "SNetSocket_t", "name": "CreateConnectionSocket", "argsstr": "uint32 nIP, uint16 nPort, int nTimeoutSec", "nargs": 3, "args": [["uint32", "nIP"], ["uint16", "nPort"], ["int", "nTimeoutSec"]], "vfindex": 10}, {"comments": "Disconnects the connection to the socket, if any, and invalidates the handle\n any unread data on the socket will be thrown away\n if bNotifyRemoteEnd is set, socket will not be completely destroyed until the remote end acknowledges the disconnect", "retval": "bool", "name": "DestroySocket", "argsstr": "SNetSocket_t hSocket, bool bNotifyRemoteEnd", "nargs": 2, "args": [["SNetSocket_t", "hSocket"], ["bool", "bNotifyRemoteEnd"]], "vfindex": 11}, {"comments": "Destroying a listen socket will automatically kill all the regular sockets generated from it", "retval": "bool", "name": "DestroyListenSocket", "argsstr": "SNetListenSocket_t hSocket, bool bNotifyRemoteEnd", "nargs": 2, "args": [["SNetListenSocket_t", "hSocket"], ["bool", "bNotifyRemoteEnd"]], "vfindex": 12}, {"comments": "Sending data\n must be a handle to a connected socket\n data is all sent via UDP, and thus send sizes are limited to 1200 bytes; after this, many routers will start dropping packets\n use the reliable flag with caution; although the resend rate is pretty aggressive,\n it can still cause stalls in receiving data (like TCP)", "retval": "bool", "name": "SendDataOnSocket", "argsstr": "SNetSocket_t hSocket, void *pubData, uint32 cubData, bool bReliable", "nargs": 4, "args": [["SNetSocket_t", "hSocket"], ["void*", "pubData"], ["uint32", "cubData"], ["bool", "bReliable"]], "vfindex": 13}, {"comments": "Receiving data\n returns false if there is no data remaining\n fills out *pcubMsgSize with the size of the next message, in bytes", "retval": "bool", "name": "IsDataAvailableOnSocket", "argsstr": "SNetSocket_t hSocket, uint32 *pcubMsgSize", "nargs": 2, "args": [["SNetSocket_t", "hSocket"], ["uint32*", "pcubMsgSize"]], "vfindex": 14}, {"comments": "Fills in pubDest with the contents of the message\n messages are always complete, of the same size as was sent (i.e. packetized, not streaming)\n if *pcubMsgSize < cubDest, only partial data is written\n returns false if no data is available", "retval": "bool", "name": "RetrieveDataFromSocket", "argsstr": "SNetSocket_t hSocket, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize", "nargs": 4, "args": [["SNetSocket_t", "hSocket"], ["void*", "pubDest"], ["uint32", "cubDest"], ["uint32*", "pcubMsgSize"]], "vfindex": 15}, {"comments": "Checks for data from any socket that has been connected off this listen socket\n returns false if there is no data remaining\n fills out *pcubMsgSize with the size of the next message, in bytes\n fills out *phSocket with the socket that data is available on", "retval": "bool", "name": "IsDataAvailable", "argsstr": "SNetListenSocket_t hListenSocket, uint32 *pcubMsgSize, SNetSocket_t *phSocket", "nargs": 3, "args": [["SNetListenSocket_t", "hListenSocket"], ["uint32*", "pcubMsgSize"], ["SNetSocket_t*", "phSocket"]], "vfindex": 16}, {"comments": "Retrieves data from any socket that has been connected off this listen socket\n fills in pubDest with the contents of the message\n messages are always complete, of the same size as was sent (i.e. packetized, not streaming)\n if *pcubMsgSize < cubDest, only partial data is written\n returns false if no data is available\n fills out *phSocket with the socket that data is available on", "retval": "bool", "name": "RetrieveData", "argsstr": "SNetListenSocket_t hListenSocket, void *pubDest, uint32 cubDest, uint32 *pcubMsgSize, SNetSocket_t *phSocket", "nargs": 5, "args": [["SNetListenSocket_t", "hListenSocket"], ["void*", "pubDest"], ["uint32", "cubDest"], ["uint32*", "pcubMsgSize"], ["SNetSocket_t*", "phSocket"]], "vfindex": 17}, {"comments": "Returns information about the specified socket, filling out the contents of the pointers", "retval": "bool", "name": "GetSocketInfo", "argsstr": "SNetSocket_t hSocket, CSteamID *pSteamIDRemote, int *peSocketStatus, uint32 *punIPRemote, uint16 *punPortRemote", "nargs": 5, "args": [["SNetSocket_t", "hSocket"], ["CSteamID*", "pSteamIDRemote"], ["int*", "peSocketStatus"], ["uint32*", "punIPRemote"], ["uint16*", "punPortRemote"]], "vfindex": 18}, {"comments": "Returns which local port the listen socket is bound to\n *pnIP and *pnPort will be 0 if the socket is set to listen for P2P connections only", "retval": "bool", "name": "GetListenSocketInfo", "argsstr": "SNetListenSocket_t hListenSocket, uint32 *pnIP, uint16 *pnPort", "nargs": 3, "args": [["SNetListenSocket_t", "hListenSocket"], ["uint32*", "pnIP"], ["uint16*", "pnPort"]], "vfindex": 19}, {"comments": "Returns true to describe how the socket ended up connecting", "retval": "ESNetSocketConnectionType", "name": "GetSocketConnectionType", "argsstr": "SNetSocket_t hSocket", "nargs": 1, "args": [["SNetSocket_t", "hSocket"]], "vfindex": 20}, {"comments": "Max packet size, in bytes", "retval": "int", "name": "GetMaxPacketSize", "argsstr": "SNetSocket_t hSocket", "nargs": 1, "args": [["SNetSocket_t", "hSocket"]], "vfindex": 21}], "cppinterface": "STEAMNETWORKING_INTERFACE_VERSION", "cppinterfacev": "SteamNetworking005", "cppclass": "ISteamNetworking"}, "ISteamParentalSettings": {"funcs": [{"retval": "bool", "name": "BIsParentalLockEnabled", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "bool", "name": "BIsParentalLockLocked", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"retval": "bool", "name": "BIsAppBlocked", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 2}, {"retval": "bool", "name": "BIsAppInBlockList", "argsstr": "AppId_t nAppID", "nargs": 1, "args": [["AppId_t", "nAppID"]], "vfindex": 3}, {"retval": "bool", "name": "BIsFeatureBlocked", "argsstr": "EParentalFeature eFeature", "nargs": 1, "args": [["EParentalFeature", "eFeature"]], "vfindex": 4}, {"retval": "bool", "name": "BIsFeatureInBlockList", "argsstr": "EParentalFeature eFeature", "nargs": 1, "args": [["EParentalFeature", "eFeature"]], "vfindex": 5}], "cppinterface": "STEAMPARENTALSETTINGS_INTERFACE_VERSION", "cppinterfacev": "STEAMPARENTALSETTINGS_INTERFACE_VERSION001", "cppclass": "ISteamParentalSettings"}, "ISteamPS3OverlayRenderHost": {"funcs": [{"comments": "Interface for game engine to implement which Steam requires to render.\n\n Draw a textured rect.  This may use only part of the texture and will pass texture coords, it will also possibly request a gradient and will specify colors for vertexes.", "retval": "void", "name": "DrawTexturedRect", "argsstr": "int x0, int y0, int x1, int y1, float u0, float v0, float u1, float v1, int32 iTextureID, DWORD colorStart, DWORD colorEnd, EOverlayGradientDirection eDirection", "nargs": 12, "args": [["int", "x0"], ["int", "y0"], ["int", "x1"], ["int", "y1"], ["float", "u0"], ["float", "v0"], ["float", "u1"], ["float", "v1"], ["int32", "iTextureID"], ["DWORD", "colorStart"], ["DWORD", "colorEnd"], ["EOverlayGradientDirection", "eDirection"]], "vfindex": 0}, {"comments": "Load a RGBA texture for Steam, or update a previously loaded one.  Updates may be partial.  You must not evict or remove this texture once Steam has uploaded it.", "retval": "void", "name": "LoadOrUpdateTexture", "argsstr": "int32 iTextureID, bool bIsFullTexture, int x0, int y0, uint32 uWidth, uint32 uHeight, int32 iBytes, char *pData", "nargs": 8, "args": [["int32", "iTextureID"], ["bool", "bIsFullTexture"], ["int", "x0"], ["int", "y0"], ["uint32", "uWidth"], ["uint32", "uHeight"], ["int32", "iBytes"], ["char*", "pData"]], "vfindex": 1}, {"comments": "Delete a texture Steam previously uploaded", "retval": "void", "name": "DeleteTexture", "argsstr": "int32 iTextureID", "nargs": 1, "args": [["int32", "iTextureID"]], "vfindex": 2}, {"comments": "Delete all previously uploaded textures", "retval": "void", "name": "DeleteAllTextures", "argsstr": "", "args": [], "nargs": 0, "vfindex": 3}, {"comments": "-----------------------------------------------------------------------------\n Purpose: Interface Steam exposes for the game to tell it when to render, etc.\n-----------------------------------------------------------------------------\nclass ISteamPS3OverlayRender\n{\npublic:\n\n Call once at startup to initialize the Steam overlay and pass it your host interface ptr", "retval": "bool", "name": "BHostInitialize", "argsstr": "uint32 unScreenWidth, uint32 unScreenHeight, uint32 unRefreshRate, ISteamPS3OverlayRenderHost *pRenderHost, void *CellFontLib", "nargs": 5, "args": [["uint32", "unScreenWidth"], ["uint32", "unScreenHeight"], ["uint32", "unRefreshRate"], ["ISteamPS3OverlayRenderHost*", "pRenderHost"], ["void*", "CellFontLib"]], "vfindex": 4}, {"comments": "Call this once a frame when you are ready for the Steam overlay to render (ie, right before flipping buffers, after all your rendering)", "retval": "void", "name": "Render", "argsstr": "", "args": [], "nargs": 0, "vfindex": 5}, {"comments": "Call this everytime you read input on PS3.\n \n If this returns true, then the overlay is active and has consumed the input, your game\n should then ignore all the input until BHandleCellPadData once again returns false, which\n will mean the overlay is deactivated.", "retval": "bool", "name": "BHandleCellPadData", "argsstr": "const CellPadData &padData", "nargs": 1, "args": [["constCellPadData", "&padData"]], "vfindex": 6}, {"comments": "Call this if you detect no controllers connected or that the XMB is intercepting input\n \n This is important to clear input state for the overlay, so keys left down during XMB activation\n are not continued to be processed.", "retval": "bool", "name": "BResetInputState", "argsstr": "", "args": [], "nargs": 0, "vfindex": 7}], "cppinterface": null, "cppinterfacev": null, "cppclass": "ISteamPS3OverlayRenderHost"}, "ISteamRemoteStorage": {"funcs": [{"comments": "NOTE\n\n Filenames are case-insensitive, and will be converted to lowercase automatically.\n So \"foo.bar\" and \"Foo.bar\" are the same file, and if you write \"Foo.bar\" then\n iterate the files, the filename returned will be \"foo.bar\".\n\n\n file operations\nvirtual boolFileWrite( const char *pchFile, const void *pvData, int32 cubData ) = 0;\nvirtual int32FileRead( const char *pchFile, void *pvData, int32 cubDataToRead ) = 0;\n\nCALL_RESULT( RemoteStorageFileWriteAsyncComplete_t )", "retval": "SteamAPICall_t", "name": "FileWriteAsync", "argsstr": "const char *pchFile, const void *pvData, uint32 cubData", "nargs": 3, "args": [["constchar*", "pchFile"], ["constvoid*", "pvData"], ["uint32", "cubData"]], "vfindex": 0}, {"retval": "SteamAPICall_t", "name": "FileReadAsync", "argsstr": "const char *pchFile, uint32 nOffset, uint32 cubToRead", "nargs": 3, "args": [["constchar*", "pchFile"], ["uint32", "nOffset"], ["uint32", "cubToRead"]], "vfindex": 1}, {"retval": "SteamAPICall_t", "name": "FileShare", "argsstr": "const char *pchFile", "nargs": 1, "args": [["constchar*", "pchFile"]], "vfindex": 2}, {"comments": "File operations that cause network IO", "retval": "UGCFileWriteStreamHandle_t", "name": "FileWriteStreamOpen", "argsstr": "const char *pchFile", "nargs": 1, "args": [["constchar*", "pchFile"]], "vfindex": 3}, {"retval": "bool", "name": "FileWriteStreamWriteChunk", "argsstr": "UGCFileWriteStreamHandle_t writeHandle, const void *pvData, int32 cubData", "nargs": 3, "args": [["UGCFileWriteStreamHandle_t", "writeHandle"], ["constvoid*", "pvData"], ["int32", "cubData"]], "vfindex": 4}, {"retval": "bool", "name": "FileWriteStreamClose", "argsstr": "UGCFileWriteStreamHandle_t writeHandle", "nargs": 1, "args": [["UGCFileWriteStreamHandle_t", "writeHandle"]], "vfindex": 5}, {"retval": "bool", "name": "FileWriteStreamCancel", "argsstr": "UGCFileWriteStreamHandle_t writeHandle", "nargs": 1, "args": [["UGCFileWriteStreamHandle_t", "writeHandle"]], "vfindex": 6}, {"comments": "File information\nvirtual boolFileExists( const char *pchFile ) = 0;\nvirtual boolFilePersisted( const char *pchFile ) = 0;\nvirtual int32GetFileSize( const char *pchFile ) = 0;\nvirtual int64GetFileTimestamp( const char *pchFile ) = 0;", "retval": "ERemoteStoragePlatform", "name": "GetSyncPlatforms", "argsstr": "const char *pchFile", "nargs": 1, "args": [["constchar*", "pchFile"]], "vfindex": 7}, {"comments": "Iteration", "retval": "int32", "name": "GetFileCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}, {"retval": "const char *", "name": "GetFileNameAndSize", "argsstr": "int iFile, int32 *pnFileSizeInBytes", "nargs": 2, "args": [["int", "iFile"], ["int32*", "pnFileSizeInBytes"]], "vfindex": 9}, {"comments": "Configuration management", "retval": "bool", "name": "GetQuota", "argsstr": "uint64 *pnTotalBytes, uint64 *puAvailableBytes", "nargs": 2, "args": [["uint64*", "pnTotalBytes"], ["uint64*", "puAvailableBytes"]], "vfindex": 10}, {"retval": "bool", "name": "IsCloudEnabledForAccount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 11}, {"retval": "bool", "name": "IsCloudEnabledForApp", "argsstr": "", "args": [], "nargs": 0, "vfindex": 12}, {"retval": "void", "name": "SetCloudEnabledForApp", "argsstr": "bool bEnabled", "nargs": 1, "args": [["bool", "bEnabled"]], "vfindex": 13}, {"comments": "User generated content\n\n Downloads a UGC file.  A priority value of 0 will download the file immediately,\n otherwise it will wait to download the file until all downloads with a lower priority\n value are completed.  Downloads with equal priority will occur simultaneously.\nCALL_RESULT( RemoteStorageDownloadUGCResult_t )", "retval": "SteamAPICall_t", "name": "UGCDownload", "argsstr": "UGCHandle_t hContent, uint32 unPriority", "nargs": 2, "args": [["UGCHandle_t", "hContent"], ["uint32", "unPriority"]], "vfindex": 14}, {"comments": "Gets the amount of data downloaded so far for a piece of content. pnBytesExpected can be 0 if function returns false\n or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage\nvirtual boolGetUGCDownloadProgress( UGCHandle_t hContent, int32 *pnBytesDownloaded, int32 *pnBytesExpected ) = 0;\n\n Gets metadata for a file after it has been downloaded. This is the same metadata given in the RemoteStorageDownloadUGCResult_t call result\nvirtual boolGetUGCDetails( UGCHandle_t hContent, AppId_t *pnAppID,  char **ppchName, int32 *pnFileSizeInBytes,  CSteamID *pSteamIDOwner ) = 0;\n\n After download, gets the content of the file.  \n Small files can be read all at once by calling this function with an offset of 0 and cubDataToRead equal to the size of the file.\n Larger files can be read in chunks to reduce memory usage (since both sides of the IPC client and the game itself must allocate\n enough memory for each chunk).  Once the last byte is read, the file is implicitly closed and further calls to UGCRead will fail\n unless UGCDownload is called again.\n For especially large files (anything over 100MB) it is a requirement that the file is read in chunks.\nvirtual int32UGCRead( UGCHandle_t hContent, void *pvData, int32 cubDataToRead, uint32 cOffset, EUGCReadAction eAction ) = 0;\n\n Functions to iterate through UGC that has finished downloading but has not yet been read via UGCRead()\nvirtual int32GetCachedUGCCount() = 0;\nvirtualUGCHandle_t GetCachedUGCHandle( int32 iCachedContent ) = 0;\n\n The following functions are only necessary on the Playstation 3. On PC & Mac, the Steam client will handle these operations for you\n On Playstation 3, the game controls which files are stored in the cloud, via FilePersist, FileFetch, and FileForget.\n\n#if defined(_PS3) || defined(_SERVER)\n Connect to Steam and get a list of files in the Cloud - results in a RemoteStorageAppSyncStatusCheck_t callback", "retval": "void", "name": "GetFileListFromServer", "argsstr": "", "args": [], "nargs": 0, "vfindex": 15}, {"comments": "Indicate this file should be downloaded in the next sync", "retval": "bool", "name": "FileFetch", "argsstr": "const char *pchFile", "nargs": 1, "args": [["constchar*", "pchFile"]], "vfindex": 16}, {"comments": "Indicate this file should be persisted in the next sync", "retval": "bool", "name": "FilePersist", "argsstr": "const char *pchFile", "nargs": 1, "args": [["constchar*", "pchFile"]], "vfindex": 17}, {"comments": "Pull any requested files down from the Cloud - results in a RemoteStorageAppSyncedClient_t callback", "retval": "bool", "name": "SynchronizeToClient", "argsstr": "", "args": [], "nargs": 0, "vfindex": 18}, {"comments": "Upload any requested files to the Cloud - results in a RemoteStorageAppSyncedServer_t callback", "retval": "bool", "name": "SynchronizeToServer", "argsstr": "", "args": [], "nargs": 0, "vfindex": 19}, {"comments": "Reset any fetch/persist/etc requests", "retval": "bool", "name": "ResetFileRequestState", "argsstr": "", "args": [], "nargs": 0, "vfindex": 20}, {"comments": "Publishing UGC\nCALL_RESULT( RemoteStoragePublishFileProgress_t )\nvirtual SteamAPICall_tPublishWorkshopFile( const char *pchFile, const char *pchPreviewFile, AppId_t nConsumerAppId, const char *pchTitle, const char *pchDescription, ERemoteStoragePublishedFileVisibility eVisibility, SteamParamStringArray_t *pTags, EWorkshopFileType eWorkshopFileType ) = 0;", "retval": "PublishedFileUpdateHandle_t", "name": "CreatePublishedFileUpdateRequest", "argsstr": "PublishedFileId_t unPublishedFileId", "nargs": 1, "args": [["PublishedFileId_t", "unPublishedFileId"]], "vfindex": 21}, {"retval": "bool", "name": "UpdatePublishedFileFile", "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchFile", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["constchar*", "pchFile"]], "vfindex": 22}, {"retval": "bool", "name": "UpdatePublishedFilePreviewFile", "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchPreviewFile", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["constchar*", "pchPreviewFile"]], "vfindex": 23}, {"retval": "bool", "name": "UpdatePublishedFileTitle", "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchTitle", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["constchar*", "pchTitle"]], "vfindex": 24}, {"retval": "bool", "name": "UpdatePublishedFileDescription", "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchDescription", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["constchar*", "pchDescription"]], "vfindex": 25}, {"retval": "bool", "name": "UpdatePublishedFileVisibility", "argsstr": "PublishedFileUpdateHandle_t updateHandle, ERemoteStoragePublishedFileVisibility eVisibility", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["ERemoteStoragePublishedFileVisibility", "eVisibility"]], "vfindex": 26}, {"retval": "bool", "name": "UpdatePublishedFileTags", "argsstr": "PublishedFileUpdateHandle_t updateHandle, SteamParamStringArray_t *pTags", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["SteamParamStringArray_t*", "pTags"]], "vfindex": 27}, {"comments": "Gets published file details for the given publishedfileid.  If unMaxSecondsOld is greater than 0,\n cached data may be returned, depending on how long ago it was cached.  A value of 0 will force a refresh.\n A value of k_WorkshopForceLoadPublishedFileDetailsFromCache will use cached data if it exists, no matter how old it is.\nCALL_RESULT( RemoteStorageGetPublishedFileDetailsResult_t )\nvirtual SteamAPICall_tGetPublishedFileDetails( PublishedFileId_t unPublishedFileId, uint32 unMaxSecondsOld ) = 0;\nCALL_RESULT( RemoteStorageDeletePublishedFileResult_t )\nvirtual SteamAPICall_tDeletePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;\n enumerate the files that the current user published with this app\nCALL_RESULT( RemoteStorageEnumerateUserPublishedFilesResult_t )\nvirtual SteamAPICall_tEnumerateUserPublishedFiles( uint32 unStartIndex ) = 0;\nCALL_RESULT( RemoteStorageSubscribePublishedFileResult_t )\nvirtual SteamAPICall_tSubscribePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;\nCALL_RESULT( RemoteStorageEnumerateUserSubscribedFilesResult_t )\nvirtual SteamAPICall_tEnumerateUserSubscribedFiles( uint32 unStartIndex ) = 0;\nCALL_RESULT( RemoteStorageUnsubscribePublishedFileResult_t )\nvirtual SteamAPICall_tUnsubscribePublishedFile( PublishedFileId_t unPublishedFileId ) = 0;", "retval": "bool", "name": "UpdatePublishedFileSetChangeDescription", "argsstr": "PublishedFileUpdateHandle_t updateHandle, const char *pchChangeDescription", "nargs": 2, "args": [["PublishedFileUpdateHandle_t", "updateHandle"], ["constchar*", "pchChangeDescription"]], "vfindex": 28}, {"comments": "This method enumerates the public view of workshop files\nCALL_RESULT( RemoteStorageEnumerateWorkshopFilesResult_t )\nvirtual SteamAPICall_tEnumeratePublishedWorkshopFiles( EWorkshopEnumerationType eEnumerationType, uint32 unStartIndex, uint32 unCount, uint32 unDays, SteamParamStringArray_t *pTags, SteamParamStringArray_t *pUserTags ) = 0;\n\nCALL_RESULT( RemoteStorageDownloadUGCResult_t )", "retval": "SteamAPICall_t", "name": "UGCDownloadToLocation", "argsstr": "UGCHandle_t hContent, const char *pchLocation, uint32 unPriority", "nargs": 3, "args": [["UGCHandle_t", "hContent"], ["constchar*", "pchLocation"], ["uint32", "unPriority"]], "vfindex": 29}], "cppinterface": "STEAMREMOTESTORAGE_INTERFACE_VERSION", "cppinterfacev": "STEAMREMOTESTORAGE_INTERFACE_VERSION014", "cppclass": "ISteamRemoteStorage"}, "ISteamScreenshots": {"funcs": [{"comments": "Writes a screenshot to the user's screenshot library given the raw image data, which must be in RGB format.\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.", "retval": "ScreenshotHandle", "name": "WriteScreenshot", "argsstr": "void *pubRGB, uint32 cubRGB, int nWidth, int nHeight", "nargs": 4, "args": [["void*", "pubRGB"], ["uint32", "cubRGB"], ["int", "nWidth"], ["int", "nHeight"]], "vfindex": 0}, {"comments": "Adds a screenshot to the user's screenshot library from disk.  If a thumbnail is provided, it must be 200 pixels wide and the same aspect ratio\n as the screenshot, otherwise a thumbnail will be generated if the user uploads the screenshot.  The screenshots must be in either JPEG or TGA format.\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.\n JPEG, TGA, and PNG formats are supported.", "retval": "ScreenshotHandle", "name": "AddScreenshotToLibrary", "argsstr": "const char *pchFilename, const char *pchThumbnailFilename, int nWidth, int nHeight", "nargs": 4, "args": [["constchar*", "pchFilename"], ["constchar*", "pchThumbnailFilename"], ["int", "nWidth"], ["int", "nHeight"]], "vfindex": 1}, {"comments": "Causes the Steam overlay to take a screenshot.  If screenshots are being hooked by the game then a ScreenshotRequested_t callback is sent back to the game instead.", "retval": "void", "name": "TriggerScreenshot", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "Toggles whether the overlay handles screenshots when the user presses the screenshot hotkey, or the game handles them.  If the game is hooking screenshots,\n then the ScreenshotRequested_t callback will be sent if the user presses the hotkey, and the game is expected to call WriteScreenshot or AddScreenshotToLibrary\n in response.", "retval": "void", "name": "HookScreenshots", "argsstr": "bool bHook", "nargs": 1, "args": [["bool", "bHook"]], "vfindex": 3}, {"comments": "Sets metadata about a screenshot's location (for example, the name of the map)", "retval": "bool", "name": "SetLocation", "argsstr": "ScreenshotHandle hScreenshot, const char *pchLocation", "nargs": 2, "args": [["ScreenshotHandle", "hScreenshot"], ["constchar*", "pchLocation"]], "vfindex": 4}, {"comments": "Tags a user as being visible in the screenshot", "retval": "bool", "name": "TagUser", "argsstr": "ScreenshotHandle hScreenshot, CSteamID steamID", "nargs": 2, "args": [["ScreenshotHandle", "hScreenshot"], ["CSteamID", "steamID"]], "vfindex": 5}, {"comments": "Tags a published file as being visible in the screenshot", "retval": "bool", "name": "TagPublishedFile", "argsstr": "ScreenshotHandle hScreenshot, PublishedFileId_t unPublishedFileID", "nargs": 2, "args": [["ScreenshotHandle", "hScreenshot"], ["PublishedFileId_t", "unPublishedFileID"]], "vfindex": 6}, {"comments": "Returns true if the app has hooked the screenshot", "retval": "bool", "name": "IsScreenshotsHooked", "argsstr": "", "args": [], "nargs": 0, "vfindex": 7}, {"comments": "Adds a VR screenshot to the user's screenshot library from disk in the supported type.\n pchFilename should be the normal 2D image used in the library view\n pchVRFilename should contain the image that matches the correct type\n The return value is a handle that is valid for the duration of the game process and can be used to apply tags.\n JPEG, TGA, and PNG formats are supported.", "retval": "ScreenshotHandle", "name": "AddVRScreenshotToLibrary", "argsstr": "EVRScreenshotType eType, const char *pchFilename, const char *pchVRFilename", "nargs": 3, "args": [["EVRScreenshotType", "eType"], ["constchar*", "pchFilename"], ["constchar*", "pchVRFilename"]], "vfindex": 8}], "cppinterface": "STEAMSCREENSHOTS_INTERFACE_VERSION", "cppinterfacev": "STEAMSCREENSHOTS_INTERFACE_VERSION003", "cppclass": "ISteamScreenshots"}, "ISteamUGC": {"funcs": [{"comments": "Query UGC associated with a user. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.", "retval": "UGCQueryHandle_t", "name": "CreateQueryUserUGCRequest", "argsstr": "AccountID_t unAccountID, EUserUGCList eListType, EUGCMatchingUGCType eMatchingUGCType, EUserUGCListSortOrder eSortOrder, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage", "nargs": 7, "args": [["AccountID_t", "unAccountID"], ["EUserUGCList", "eListType"], ["EUGCMatchingUGCType", "eMatchingUGCType"], ["EUserUGCListSortOrder", "eSortOrder"], ["AppId_t", "nCreatorAppID"], ["AppId_t", "nConsumerAppID"], ["uint32", "unPage"]], "vfindex": 0}, {"comments": "Query for all matching UGC. Creator app id or consumer app id must be valid and be set to the current running app. unPage should start at 1.", "retval": "UGCQueryHandle_t", "name": "CreateQueryAllUGCRequest", "argsstr": "EUGCQuery eQueryType, EUGCMatchingUGCType eMatchingeMatchingUGCTypeFileType, AppId_t nCreatorAppID, AppId_t nConsumerAppID, uint32 unPage", "nargs": 5, "args": [["EUGCQuery", "eQueryType"], ["EUGCMatchingUGCType", "eMatchingeMatchingUGCTypeFileType"], ["AppId_t", "nCreatorAppID"], ["AppId_t", "nConsumerAppID"], ["uint32", "unPage"]], "vfindex": 1}, {"comments": "Query for the details of the given published file ids (the RequestUGCDetails call is deprecated and replaced with this)", "retval": "UGCQueryHandle_t", "name": "CreateQueryUGCDetailsRequest", "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs", "nargs": 2, "args": [["PublishedFileId_t*", "pvecPublishedFileID"], ["uint32", "unNumPublishedFileIDs"]], "vfindex": 2}, {"comments": "Send the query to Steam\nCALL_RESULT( SteamUGCQueryCompleted_t )", "retval": "SteamAPICall_t", "name": "SendQueryUGCRequest", "argsstr": "UGCQueryHandle_t handle", "nargs": 1, "args": [["UGCQueryHandle_t", "handle"]], "vfindex": 3}, {"comments": "Retrieve an individual result after receiving the callback for querying UGC", "retval": "bool", "name": "GetQueryUGCResult", "argsstr": "UGCQueryHandle_t handle, uint32 index, SteamUGCDetails_t *pDetails", "nargs": 3, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["SteamUGCDetails_t*", "pDetails"]], "vfindex": 4}, {"retval": "bool", "name": "GetQueryUGCPreviewURL", "argsstr": "UGCQueryHandle_t handle, uint32 index,  char *pchURL, uint32 cchURLSize", "nargs": 4, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["char*", "pchURL"], ["uint32", "cchURLSize"]], "vfindex": 5}, {"retval": "bool", "name": "GetQueryUGCMetadata", "argsstr": "UGCQueryHandle_t handle, uint32 index,  char *pchMetadata, uint32 cchMetadatasize", "nargs": 4, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["char*", "pchMetadata"], ["uint32", "cchMetadatasize"]], "vfindex": 6}, {"retval": "bool", "name": "GetQueryUGCChildren", "argsstr": "UGCQueryHandle_t handle, uint32 index, PublishedFileId_t* pvecPublishedFileID, uint32 cMaxEntries", "nargs": 4, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["PublishedFileId_t*", "pvecPublishedFileID"], ["uint32", "cMaxEntries"]], "vfindex": 7}, {"retval": "bool", "name": "GetQueryUGCStatistic", "argsstr": "UGCQueryHandle_t handle, uint32 index, EItemStatistic eStatType, uint64 *pStatValue", "nargs": 4, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["EItemStatistic", "eStatType"], ["uint64*", "pStatValue"]], "vfindex": 8}, {"retval": "uint32", "name": "GetQueryUGCNumAdditionalPreviews", "argsstr": "UGCQueryHandle_t handle, uint32 index", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"]], "vfindex": 9}, {"retval": "bool", "name": "GetQueryUGCAdditionalPreview", "argsstr": "UGCQueryHandle_t handle, uint32 index, uint32 previewIndex,  char *pchURLOrVideoID, uint32 cchURLSize,  char *pchOriginalFileName, uint32 cchOriginalFileNameSize, EItemPreviewType *pPreviewType", "nargs": 8, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["uint32", "previewIndex"], ["char*", "pchURLOrVideoID"], ["uint32", "cchURLSize"], ["char*", "pchOriginalFileName"], ["uint32", "cchOriginalFileNameSize"], ["EItemPreviewType*", "pPreviewType"]], "vfindex": 10}, {"retval": "uint32", "name": "GetQueryUGCNumKeyValueTags", "argsstr": "UGCQueryHandle_t handle, uint32 index", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"]], "vfindex": 11}, {"retval": "bool", "name": "GetQueryUGCKeyValueTag", "argsstr": "UGCQueryHandle_t handle, uint32 index, uint32 keyValueTagIndex,  char *pchKey, uint32 cchKeySize,  char *pchValue, uint32 cchValueSize", "nargs": 7, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "index"], ["uint32", "keyValueTagIndex"], ["char*", "pchKey"], ["uint32", "cchKeySize"], ["char*", "pchValue"], ["uint32", "cchValueSize"]], "vfindex": 12}, {"comments": "Release the request to free up memory, after retrieving results", "retval": "bool", "name": "ReleaseQueryUGCRequest", "argsstr": "UGCQueryHandle_t handle", "nargs": 1, "args": [["UGCQueryHandle_t", "handle"]], "vfindex": 13}, {"comments": "Options to set for querying UGC", "retval": "bool", "name": "AddRequiredTag", "argsstr": "UGCQueryHandle_t handle, const char *pTagName", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pTagName"]], "vfindex": 14}, {"retval": "bool", "name": "AddExcludedTag", "argsstr": "UGCQueryHandle_t handle, const char *pTagName", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pTagName"]], "vfindex": 15}, {"retval": "bool", "name": "SetReturnOnlyIDs", "argsstr": "UGCQueryHandle_t handle, bool bReturnOnlyIDs", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnOnlyIDs"]], "vfindex": 16}, {"retval": "bool", "name": "SetReturnKeyValueTags", "argsstr": "UGCQueryHandle_t handle, bool bReturnKeyValueTags", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnKeyValueTags"]], "vfindex": 17}, {"retval": "bool", "name": "SetReturnLongDescription", "argsstr": "UGCQueryHandle_t handle, bool bReturnLongDescription", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnLongDescription"]], "vfindex": 18}, {"retval": "bool", "name": "SetReturnMetadata", "argsstr": "UGCQueryHandle_t handle, bool bReturnMetadata", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnMetadata"]], "vfindex": 19}, {"retval": "bool", "name": "SetReturnChildren", "argsstr": "UGCQueryHandle_t handle, bool bReturnChildren", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnChildren"]], "vfindex": 20}, {"retval": "bool", "name": "SetReturnAdditionalPreviews", "argsstr": "UGCQueryHandle_t handle, bool bReturnAdditionalPreviews", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnAdditionalPreviews"]], "vfindex": 21}, {"retval": "bool", "name": "SetReturnTotalOnly", "argsstr": "UGCQueryHandle_t handle, bool bReturnTotalOnly", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bReturnTotalOnly"]], "vfindex": 22}, {"retval": "bool", "name": "SetReturnPlaytimeStats", "argsstr": "UGCQueryHandle_t handle, uint32 unDays", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "unDays"]], "vfindex": 23}, {"retval": "bool", "name": "SetLanguage", "argsstr": "UGCQueryHandle_t handle, const char *pchLanguage", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pchLanguage"]], "vfindex": 24}, {"retval": "bool", "name": "SetAllowCachedResponse", "argsstr": "UGCQueryHandle_t handle, uint32 unMaxAgeSeconds", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "unMaxAgeSeconds"]], "vfindex": 25}, {"comments": "Options only for querying user UGC", "retval": "bool", "name": "SetCloudFileNameFilter", "argsstr": "UGCQueryHandle_t handle, const char *pMatchCloudFileName", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pMatchCloudFileName"]], "vfindex": 26}, {"comments": "Options only for querying all UGC", "retval": "bool", "name": "SetMatchAnyTag", "argsstr": "UGCQueryHandle_t handle, bool bMatchAnyTag", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["bool", "bMatchAnyTag"]], "vfindex": 27}, {"retval": "bool", "name": "SetSearchText", "argsstr": "UGCQueryHandle_t handle, const char *pSearchText", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pSearchText"]], "vfindex": 28}, {"retval": "bool", "name": "SetRankedByTrendDays", "argsstr": "UGCQueryHandle_t handle, uint32 unDays", "nargs": 2, "args": [["UGCQueryHandle_t", "handle"], ["uint32", "unDays"]], "vfindex": 29}, {"retval": "bool", "name": "AddRequiredKeyValueTag", "argsstr": "UGCQueryHandle_t handle, const char *pKey, const char *pValue", "nargs": 3, "args": [["UGCQueryHandle_t", "handle"], ["constchar*", "pKey"], ["constchar*", "pValue"]], "vfindex": 30}, {"comments": "DEPRECATED - Use CreateQueryUGCDetailsRequest call above instead!", "retval": "SteamAPICall_t", "name": "RequestUGCDetails", "argsstr": "PublishedFileId_t nPublishedFileID, uint32 unMaxAgeSeconds", "nargs": 2, "args": [["PublishedFileId_t", "nPublishedFileID"], ["uint32", "unMaxAgeSeconds"]], "vfindex": 31}, {"comments": "Steam Workshop Creator API\nCALL_RESULT( CreateItemResult_t )", "retval": "SteamAPICall_t", "name": "CreateItem", "argsstr": "AppId_t nConsumerAppId, EWorkshopFileType eFileType", "nargs": 2, "args": [["AppId_t", "nConsumerAppId"], ["EWorkshopFileType", "eFileType"]], "vfindex": 32}, {"comments": "Create new item for this app with no content attached yet", "retval": "UGCUpdateHandle_t", "name": "StartItemUpdate", "argsstr": "AppId_t nConsumerAppId, PublishedFileId_t nPublishedFileID", "nargs": 2, "args": [["AppId_t", "nConsumerAppId"], ["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 33}, {"comments": "Start an UGC item update. Set changed properties before commiting update with CommitItemUpdate()", "retval": "bool", "name": "SetItemTitle", "argsstr": "UGCUpdateHandle_t handle, const char *pchTitle", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchTitle"]], "vfindex": 34}, {"comments": "Change the title of an UGC item", "retval": "bool", "name": "SetItemDescription", "argsstr": "UGCUpdateHandle_t handle, const char *pchDescription", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchDescription"]], "vfindex": 35}, {"comments": "Change the description of an UGC item", "retval": "bool", "name": "SetItemUpdateLanguage", "argsstr": "UGCUpdateHandle_t handle, const char *pchLanguage", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchLanguage"]], "vfindex": 36}, {"comments": "Specify the language of the title or description that will be set", "retval": "bool", "name": "SetItemMetadata", "argsstr": "UGCUpdateHandle_t handle, const char *pchMetaData", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchMetaData"]], "vfindex": 37}, {"comments": "Change the metadata of an UGC item (max = k_cchDeveloperMetadataMax)", "retval": "bool", "name": "SetItemVisibility", "argsstr": "UGCUpdateHandle_t handle, ERemoteStoragePublishedFileVisibility eVisibility", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["ERemoteStoragePublishedFileVisibility", "eVisibility"]], "vfindex": 38}, {"comments": "Change the visibility of an UGC item", "retval": "bool", "name": "SetItemTags", "argsstr": "UGCUpdateHandle_t updateHandle, const SteamParamStringArray_t *pTags", "nargs": 2, "args": [["UGCUpdateHandle_t", "updateHandle"], ["constSteamParamStringArray_t*", "pTags"]], "vfindex": 39}, {"comments": "Change the tags of an UGC item", "retval": "bool", "name": "SetItemContent", "argsstr": "UGCUpdateHandle_t handle, const char *pszContentFolder", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pszContentFolder"]], "vfindex": 40}, {"comments": "Update item content from this local folder", "retval": "bool", "name": "SetItemPreview", "argsstr": "UGCUpdateHandle_t handle, const char *pszPreviewFile", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pszPreviewFile"]], "vfindex": 41}, {"comments": "Change preview image file for this item. pszPreviewFile points to local image file, which must be under 1MB in size", "retval": "bool", "name": "RemoveItemKeyValueTags", "argsstr": "UGCUpdateHandle_t handle, const char *pchKey", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchKey"]], "vfindex": 42}, {"comments": "Remove any existing key-value tags with the specified key", "retval": "bool", "name": "AddItemKeyValueTag", "argsstr": "UGCUpdateHandle_t handle, const char *pchKey, const char *pchValue", "nargs": 3, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchKey"], ["constchar*", "pchValue"]], "vfindex": 43}, {"comments": "Add new key-value tags for the item. Note that there can be multiple values for a tag.", "retval": "bool", "name": "AddItemPreviewFile", "argsstr": "UGCUpdateHandle_t handle, const char *pszPreviewFile, EItemPreviewType type", "nargs": 3, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pszPreviewFile"], ["EItemPreviewType", "type"]], "vfindex": 44}, {"comments": "Add preview file for this item. pszPreviewFile points to local file, which must be under 1MB in size", "retval": "bool", "name": "AddItemPreviewVideo", "argsstr": "UGCUpdateHandle_t handle, const char *pszVideoID", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pszVideoID"]], "vfindex": 45}, {"comments": "Add preview video for this item", "retval": "bool", "name": "UpdateItemPreviewFile", "argsstr": "UGCUpdateHandle_t handle, uint32 index, const char *pszPreviewFile", "nargs": 3, "args": [["UGCUpdateHandle_t", "handle"], ["uint32", "index"], ["constchar*", "pszPreviewFile"]], "vfindex": 46}, {"comments": "Updates an existing preview file for this item. pszPreviewFile points to local file, which must be under 1MB in size", "retval": "bool", "name": "UpdateItemPreviewVideo", "argsstr": "UGCUpdateHandle_t handle, uint32 index, const char *pszVideoID", "nargs": 3, "args": [["UGCUpdateHandle_t", "handle"], ["uint32", "index"], ["constchar*", "pszVideoID"]], "vfindex": 47}, {"comments": "Updates an existing preview video for this item", "retval": "bool", "name": "RemoveItemPreview", "argsstr": "UGCUpdateHandle_t handle, uint32 index", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["uint32", "index"]], "vfindex": 48}, {"comments": "Remove a preview by index starting at 0 (previews are sorted)\n\nCALL_RESULT( SubmitItemUpdateResult_t )", "retval": "SteamAPICall_t", "name": "SubmitItemUpdate", "argsstr": "UGCUpdateHandle_t handle, const char *pchChangeNote", "nargs": 2, "args": [["UGCUpdateHandle_t", "handle"], ["constchar*", "pchChangeNote"]], "vfindex": 49}, {"comments": "Commit update process started with StartItemUpdate()", "retval": "EItemUpdateStatus", "name": "GetItemUpdateProgress", "argsstr": "UGCUpdateHandle_t handle, uint64 *punBytesProcessed, uint64* punBytesTotal", "nargs": 3, "args": [["UGCUpdateHandle_t", "handle"], ["uint64*", "punBytesProcessed"], ["uint64*", "punBytesTotal"]], "vfindex": 50}, {"comments": "Steam Workshop Consumer API\nCALL_RESULT( SetUserItemVoteResult_t )", "retval": "SteamAPICall_t", "name": "SetUserItemVote", "argsstr": "PublishedFileId_t nPublishedFileID, bool bVoteUp", "nargs": 2, "args": [["PublishedFileId_t", "nPublishedFileID"], ["bool", "bVoteUp"]], "vfindex": 51}, {"retval": "SteamAPICall_t", "name": "GetUserItemVote", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 52}, {"retval": "SteamAPICall_t", "name": "AddItemToFavorites", "argsstr": "AppId_t nAppId, PublishedFileId_t nPublishedFileID", "nargs": 2, "args": [["AppId_t", "nAppId"], ["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 53}, {"retval": "SteamAPICall_t", "name": "RemoveItemFromFavorites", "argsstr": "AppId_t nAppId, PublishedFileId_t nPublishedFileID", "nargs": 2, "args": [["AppId_t", "nAppId"], ["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 54}, {"retval": "SteamAPICall_t", "name": "SubscribeItem", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 55}, {"comments": "Subscribe to this item, will be installed ASAP\nCALL_RESULT( RemoteStorageUnsubscribePublishedFileResult_t )", "retval": "SteamAPICall_t", "name": "UnsubscribeItem", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 56}, {"comments": "Unsubscribe from this item, will be uninstalled after game quits", "retval": "uint32", "name": "GetNumSubscribedItems", "argsstr": "", "args": [], "nargs": 0, "vfindex": 57}, {"comments": "Number of subscribed items", "retval": "uint32", "name": "GetSubscribedItems", "argsstr": "PublishedFileId_t* pvecPublishedFileID, uint32 cMaxEntries", "nargs": 2, "args": [["PublishedFileId_t*", "pvecPublishedFileID"], ["uint32", "cMaxEntries"]], "vfindex": 58}, {"comments": "All subscribed item PublishFileIDs\n\n get EItemState flags about item on this client", "retval": "uint32", "name": "GetItemState", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 59}, {"comments": "Get info about currently installed content on disc for items that have k_EItemStateInstalled set\n if k_EItemStateLegacyItem is set, pchFolder contains the path to the legacy file itself (not a folder)", "retval": "bool", "name": "GetItemInstallInfo", "argsstr": "PublishedFileId_t nPublishedFileID, uint64 *punSizeOnDisk,  char *pchFolder, uint32 cchFolderSize, uint32 *punTimeStamp", "nargs": 5, "args": [["PublishedFileId_t", "nPublishedFileID"], ["uint64*", "punSizeOnDisk"], ["char*", "pchFolder"], ["uint32", "cchFolderSize"], ["uint32*", "punTimeStamp"]], "vfindex": 60}, {"comments": "Get info about pending update for items that have k_EItemStateNeedsUpdate set. punBytesTotal will be valid after download started once", "retval": "bool", "name": "GetItemDownloadInfo", "argsstr": "PublishedFileId_t nPublishedFileID, uint64 *punBytesDownloaded, uint64 *punBytesTotal", "nargs": 3, "args": [["PublishedFileId_t", "nPublishedFileID"], ["uint64*", "punBytesDownloaded"], ["uint64*", "punBytesTotal"]], "vfindex": 61}, {"comments": "Download new or update already installed item. If function returns true, wait for DownloadItemResult_t. If the item is already installed,\n then files on disk should not be used until callback received. If item is not subscribed to, it will be cached for some time.\n If bHighPriority is set, any other item download will be suspended and this item downloaded ASAP.", "retval": "bool", "name": "DownloadItem", "argsstr": "PublishedFileId_t nPublishedFileID, bool bHighPriority", "nargs": 2, "args": [["PublishedFileId_t", "nPublishedFileID"], ["bool", "bHighPriority"]], "vfindex": 62}, {"comments": "Game servers can set a specific workshop folder before issuing any UGC commands.\n This is helpful if you want to support multiple game servers running out of the same install folder", "retval": "bool", "name": "BInitWorkshopForGameServer", "argsstr": "DepotId_t unWorkshopDepotID, const char *pszFolder", "nargs": 2, "args": [["DepotId_t", "unWorkshopDepotID"], ["constchar*", "pszFolder"]], "vfindex": 63}, {"comments": "SuspendDownloads( true ) will suspend all workshop downloads until SuspendDownloads( false ) is called or the game ends", "retval": "void", "name": "SuspendDownloads", "argsstr": "bool bSuspend", "nargs": 1, "args": [["bool", "bSuspend"]], "vfindex": 64}, {"comments": "Usage tracking\nCALL_RESULT( StartPlaytimeTrackingResult_t )", "retval": "SteamAPICall_t", "name": "StartPlaytimeTracking", "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs", "nargs": 2, "args": [["PublishedFileId_t*", "pvecPublishedFileID"], ["uint32", "unNumPublishedFileIDs"]], "vfindex": 65}, {"retval": "SteamAPICall_t", "name": "StopPlaytimeTracking", "argsstr": "PublishedFileId_t *pvecPublishedFileID, uint32 unNumPublishedFileIDs", "nargs": 2, "args": [["PublishedFileId_t*", "pvecPublishedFileID"], ["uint32", "unNumPublishedFileIDs"]], "vfindex": 66}, {"retval": "SteamAPICall_t", "name": "StopPlaytimeTrackingForAllItems", "argsstr": "", "args": [], "nargs": 0, "vfindex": 67}, {"comments": "Parent-child relationship or dependency management\nCALL_RESULT( AddUGCDependencyResult_t )", "retval": "SteamAPICall_t", "name": "AddDependency", "argsstr": "PublishedFileId_t nParentPublishedFileID, PublishedFileId_t nChildPublishedFileID", "nargs": 2, "args": [["PublishedFileId_t", "nParentPublishedFileID"], ["PublishedFileId_t", "nChildPublishedFileID"]], "vfindex": 68}, {"retval": "SteamAPICall_t", "name": "RemoveDependency", "argsstr": "PublishedFileId_t nParentPublishedFileID, PublishedFileId_t nChildPublishedFileID", "nargs": 2, "args": [["PublishedFileId_t", "nParentPublishedFileID"], ["PublishedFileId_t", "nChildPublishedFileID"]], "vfindex": 69}, {"comments": "Add/remove app dependence/requirements (usually DLC)\nCALL_RESULT( AddAppDependencyResult_t )", "retval": "SteamAPICall_t", "name": "AddAppDependency", "argsstr": "PublishedFileId_t nPublishedFileID, AppId_t nAppID", "nargs": 2, "args": [["PublishedFileId_t", "nPublishedFileID"], ["AppId_t", "nAppID"]], "vfindex": 70}, {"retval": "SteamAPICall_t", "name": "RemoveAppDependency", "argsstr": "PublishedFileId_t nPublishedFileID, AppId_t nAppID", "nargs": 2, "args": [["PublishedFileId_t", "nPublishedFileID"], ["AppId_t", "nAppID"]], "vfindex": 71}, {"comments": "Request app dependencies. note that whatever callback you register for GetAppDependenciesResult_t may be called multiple times\n until all app dependencies have been returned\nCALL_RESULT( GetAppDependenciesResult_t )", "retval": "SteamAPICall_t", "name": "GetAppDependencies", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 72}, {"comments": "Delete the item without prompting the user\nCALL_RESULT( DeleteItemResult_t )", "retval": "SteamAPICall_t", "name": "DeleteItem", "argsstr": "PublishedFileId_t nPublishedFileID", "nargs": 1, "args": [["PublishedFileId_t", "nPublishedFileID"]], "vfindex": 73}], "cppinterface": "STEAMUGC_INTERFACE_VERSION", "cppinterfacev": "STEAMUGC_INTERFACE_VERSION010", "cppclass": "ISteamUGC"}, "ISteamUser": {"funcs": [{"comments": "Returns the HSteamUser this interface represents\n this is only used internally by the API, and by a few select interfaces that support multi-user", "retval": "HSteamUser", "name": "GetHSteamUser", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"comments": "Returns true if the Steam client current has a live connection to the Steam servers. \n If false, it means there is no active connection due to either a networking issue on the local machine, or the Steam server is down/busy.\n The Steam client will automatically be trying to recreate the connection as often as possible.", "retval": "bool", "name": "BLoggedOn", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"comments": "Returns the CSteamID of the account currently logged into the Steam client\n a CSteamID is a unique identifier for an account, and used to differentiate users in all parts of the Steamworks API", "retval": "CSteamID", "name": "GetSteamID", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "Multiplayer Authentication functions\n\n InitiateGameConnection() starts the state machine for authenticating the game client with the game server\n It is the client portion of a three-way handshake between the client, the game server, and the steam servers\n\n Parameters:\n void *pAuthBlob - a pointer to empty memory that will be filled in with the authentication token.\n int cbMaxAuthBlob - the number of bytes of allocated memory in pBlob. Should be at least 2048 bytes.\n CSteamID steamIDGameServer - the steamID of the game server, received from the game server by the client\n CGameID gameID - the ID of the current game. For games without mods, this is just CGameID( <appID> )\n uint32 unIPServer, uint16 usPortServer - the IP address of the game server\n bool bSecure - whether or not the client thinks that the game server is reporting itself as secure (i.e. VAC is running)\n\n return value - returns the number of bytes written to pBlob. If the return is 0, then the buffer passed in was too small, and the call has failed\n The contents of pBlob should then be sent to the game server, for it to use to complete the authentication process.", "retval": "int", "name": "InitiateGameConnection", "argsstr": "void *pAuthBlob, int cbMaxAuthBlob, CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer, bool bSecure", "nargs": 6, "args": [["void*", "pAuthBlob"], ["int", "cbMaxAuthBlob"], ["CSteamID", "steamIDGameServer"], ["uint32", "unIPServer"], ["uint16", "usPortServer"], ["bool", "bSecure"]], "vfindex": 3}, {"comments": "Notify of disconnect\n needs to occur when the game client leaves the specified game server, needs to match with the InitiateGameConnection() call", "retval": "void", "name": "TerminateGameConnection", "argsstr": "uint32 unIPServer, uint16 usPortServer", "nargs": 2, "args": [["uint32", "unIPServer"], ["uint16", "usPortServer"]], "vfindex": 4}, {"comments": "Legacy functions\n\n used by only a few games to track usage events", "retval": "void", "name": "TrackAppUsageEvent", "argsstr": "CGameID gameID, int eAppUsageEvent, const char *pchExtraInfo = \"\"", "nargs": 3, "args": [["CGameID", "gameID"], ["int", "eAppUsageEvent"], ["constchar*pchExtraInfo=", "\"\""]], "vfindex": 5}, {"comments": "Get the local storage folder for current Steam account to write application data, e.g. save games, configs etc.\n this will usually be something like \"C:\\Progam Files\\Steam\\userdata\\<SteamID>\\<AppID>\\local\"", "retval": "bool", "name": "GetUserDataFolder", "argsstr": "char *pchBuffer, int cubBuffer", "nargs": 2, "args": [["char*", "pchBuffer"], ["int", "cubBuffer"]], "vfindex": 6}, {"comments": "Starts voice recording. Once started, use GetVoice() to get the data", "retval": "void", "name": "StartVoiceRecording", "argsstr": "", "args": [], "nargs": 0, "vfindex": 7}, {"comments": "Stops voice recording. Because people often release push-to-talk keys early, the system will keep recording for\n a little bit after this function is called. GetVoice() should continue to be called until it returns\n k_eVoiceResultNotRecording", "retval": "void", "name": "StopVoiceRecording", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}, {"comments": "Determine the size of captured audio data that is available from GetVoice.\n Most applications will only use compressed data and should ignore the other\n parameters, which exist primarily for backwards compatibility. See comments\n below for further explanation of \"uncompressed\" data.", "retval": "EVoiceResult", "name": "GetAvailableVoice", "argsstr": "uint32 *pcbCompressed, uint32 *pcbUncompressed_Deprecated = 0, uint32 nUncompressedVoiceDesiredSampleRate_Deprecated = 0", "nargs": 3, "args": [["uint32*", "pcbCompressed"], ["uint32*pcbUncompressed_Deprecated=", "0"], ["uint32nUncompressedVoiceDesiredSampleRate_Deprecated=", "0"]], "vfindex": 9}, {"comments": "---------------------------------------------------------------------------\n NOTE: \"uncompressed\" audio is a deprecated feature and should not be used\n by most applications. It is raw single-channel 16-bit PCM wave data which\n may have been run through preprocessing filters and/or had silence removed,\n so the uncompressed audio could have a shorter duration than you expect.\n There may be no data at all during long periods of silence. Also, fetching\n uncompressed audio will cause GetVoice to discard any leftover compressed\n audio, so you must fetch both types at once. Finally, GetAvailableVoice is\n not precisely accurate when the uncompressed size is requested. So if you\n really need to use uncompressed audio, you should call GetVoice frequently\n with two very large (20kb+) output buffers instead of trying to allocate\n perfectly-sized buffers. But most applications should ignore all of these\n details and simply leave the \"uncompressed\" parameters as NULL/zero.\n ---------------------------------------------------------------------------\n\n Read captured audio data from the microphone buffer. This should be called\n at least once per frame, and preferably every few milliseconds, to keep the\n microphone input delay as low as possible. Most applications will only use\n compressed data and should pass NULL/zero for the \"uncompressed\" parameters.\n Compressed data can be transmitted by your application and decoded into raw\n using the DecompressVoice function below.", "retval": "EVoiceResult", "name": "GetVoice", "argsstr": "bool bWantCompressed, void *pDestBuffer, uint32 cbDestBufferSize, uint32 *nBytesWritten, bool bWantUncompressed_Deprecated = false, void *pUncompressedDestBuffer_Deprecated = 0, uint32 cbUncompressedDestBufferSize_Deprecated = 0, uint32 *nUncompressBytesWritten_Deprecated = 0, uint32 nUncompressedVoiceDesiredSampleRate_Deprecated = 0", "nargs": 9, "args": [["bool", "bWantCompressed"], ["void*", "pDestBuffer"], ["uint32", "cbDestBufferSize"], ["uint32*", "nBytesWritten"], ["boolbWantUncompressed_Deprecated=", "false"], ["void*pUncompressedDestBuffer_Deprecated=", "0"], ["uint32cbUncompressedDestBufferSize_Deprecated=", "0"], ["uint32*nUncompressBytesWritten_Deprecated=", "0"], ["uint32nUncompressedVoiceDesiredSampleRate_Deprecated=", "0"]], "vfindex": 10}, {"comments": "Decodes the compressed voice data returned by GetVoice. The output data is\n raw single-channel 16-bit PCM audio. The decoder supports any sample rate\n from 11025 to 48000; see GetVoiceOptimalSampleRate() below for details.\n If the output buffer is not large enough, then *nBytesWritten will be set\n to the required buffer size, and k_EVoiceResultBufferTooSmall is returned.\n It is suggested to start with a 20kb buffer and reallocate as necessary.", "retval": "EVoiceResult", "name": "DecompressVoice", "argsstr": "const void *pCompressed, uint32 cbCompressed, void *pDestBuffer, uint32 cbDestBufferSize, uint32 *nBytesWritten, uint32 nDesiredSampleRate", "nargs": 6, "args": [["constvoid*", "pCompressed"], ["uint32", "cbCompressed"], ["void*", "pDestBuffer"], ["uint32", "cbDestBufferSize"], ["uint32*", "nBytesWritten"], ["uint32", "nDesiredSampleRate"]], "vfindex": 11}, {"comments": "This returns the native sample rate of the Steam voice decompressor; using\n this sample rate for DecompressVoice will perform the least CPU processing.\n However, the final audio quality will depend on how well the audio device\n (and/or your application's audio output SDK) deals with lower sample rates.\n You may find that you get the best audio output quality when you ignore\n this function and use the native sample rate of your audio output device,\n which is usually 48000 or 44100.", "retval": "uint32", "name": "GetVoiceOptimalSampleRate", "argsstr": "", "args": [], "nargs": 0, "vfindex": 12}, {"comments": "Retrieve ticket to be sent to the entity who wishes to authenticate you. \n pcbTicket retrieves the length of the actual ticket.", "retval": "HAuthTicket", "name": "GetAuthSessionTicket", "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket", "nargs": 3, "args": [["void*", "pTicket"], ["int", "cbMaxTicket"], ["uint32*", "pcbTicket"]], "vfindex": 13}, {"comments": "Authenticate ticket from entity steamID to be sure it is valid and isnt reused\n Registers for callbacks if the entity goes offline or cancels the ticket ( see ValidateAuthTicketResponse_t callback and EAuthSessionResponse )", "retval": "EBeginAuthSessionResult", "name": "BeginAuthSession", "argsstr": "const void *pAuthTicket, int cbAuthTicket, CSteamID steamID", "nargs": 3, "args": [["constvoid*", "pAuthTicket"], ["int", "cbAuthTicket"], ["CSteamID", "steamID"]], "vfindex": 14}, {"comments": "Stop tracking started by BeginAuthSession - called when no longer playing game with this entity", "retval": "void", "name": "EndAuthSession", "argsstr": "CSteamID steamID", "nargs": 1, "args": [["CSteamID", "steamID"]], "vfindex": 15}, {"comments": "Cancel auth ticket from GetAuthSessionTicket, called when no longer playing game with the entity you gave the ticket to", "retval": "void", "name": "CancelAuthTicket", "argsstr": "HAuthTicket hAuthTicket", "nargs": 1, "args": [["HAuthTicket", "hAuthTicket"]], "vfindex": 16}, {"comments": "After receiving a user's authentication data, and passing it to BeginAuthSession, use this function\n to determine if the user owns downloadable content specified by the provided AppID.", "retval": "EUserHasLicenseForAppResult", "name": "UserHasLicenseForApp", "argsstr": "CSteamID steamID, AppId_t appID", "nargs": 2, "args": [["CSteamID", "steamID"], ["AppId_t", "appID"]], "vfindex": 17}, {"comments": "Returns true if this users looks like they are behind a NAT device. Only valid once the user has connected to steam \n (i.e a SteamServersConnected_t has been issued) and may not catch all forms of NAT.", "retval": "bool", "name": "BIsBehindNAT", "argsstr": "", "args": [], "nargs": 0, "vfindex": 18}, {"comments": "Set data to be replicated to friends so that they can join your game\n CSteamID steamIDGameServer - the steamID of the game server, received from the game server by the client\n uint32 unIPServer, uint16 usPortServer - the IP address of the game server", "retval": "void", "name": "AdvertiseGame", "argsstr": "CSteamID steamIDGameServer, uint32 unIPServer, uint16 usPortServer", "nargs": 3, "args": [["CSteamID", "steamIDGameServer"], ["uint32", "unIPServer"], ["uint16", "usPortServer"]], "vfindex": 19}, {"comments": "Requests a ticket encrypted with an app specific shared key\n pDataToInclude, cbDataToInclude will be encrypted into the ticket\n ( This is asynchronous, you must wait for the ticket to be completed by the server )\nCALL_RESULT( EncryptedAppTicketResponse_t )", "retval": "SteamAPICall_t", "name": "RequestEncryptedAppTicket", "argsstr": "void *pDataToInclude, int cbDataToInclude", "nargs": 2, "args": [["void*", "pDataToInclude"], ["int", "cbDataToInclude"]], "vfindex": 20}, {"comments": "Retrieve a finished ticket", "retval": "bool", "name": "GetEncryptedAppTicket", "argsstr": "void *pTicket, int cbMaxTicket, uint32 *pcbTicket", "nargs": 3, "args": [["void*", "pTicket"], ["int", "cbMaxTicket"], ["uint32*", "pcbTicket"]], "vfindex": 21}, {"comments": "Trading Card badges data access\n if you only have one set of cards, the series will be 1\n the user has can have two different badges for a series; the regular (max level 5) and the foil (max level 1)", "retval": "int", "name": "GetGameBadgeLevel", "argsstr": "int nSeries, bool bFoil", "nargs": 2, "args": [["int", "nSeries"], ["bool", "bFoil"]], "vfindex": 22}, {"comments": "Gets the Steam Level of the user, as shown on their profile", "retval": "int", "name": "GetPlayerSteamLevel", "argsstr": "", "args": [], "nargs": 0, "vfindex": 23}, {"comments": "Requests a URL which authenticates an in-game browser for store check-out,\n and then redirects to the specified URL. As long as the in-game browser\n accepts and handles session cookies, Steam microtransaction checkout pages\n will automatically recognize the user instead of presenting a login page.\n The result of this API call will be a StoreAuthURLResponse_t callback.\n NOTE: The URL has a very short lifetime to prevent history-snooping attacks,\n so you should only call this API when you are about to launch the browser,\n or else immediately navigate to the result URL using a hidden browser window.\n NOTE 2: The resulting authorization cookie has an expiration time of one day,\n so it would be a good idea to request and visit a new auth URL every 12 hours.\nCALL_RESULT( StoreAuthURLResponse_t )", "retval": "SteamAPICall_t", "name": "RequestStoreAuthURL", "argsstr": "const char *pchRedirectURL", "nargs": 1, "args": [["constchar*", "pchRedirectURL"]], "vfindex": 24}, {"comments": "Gets whether the users phone number is verified", "retval": "bool", "name": "BIsPhoneVerified", "argsstr": "", "args": [], "nargs": 0, "vfindex": 25}, {"comments": "Gets whether the user has two factor enabled on their account", "retval": "bool", "name": "BIsTwoFactorEnabled", "argsstr": "", "args": [], "nargs": 0, "vfindex": 26}, {"comments": "Gets whether the users phone number is identifying", "retval": "bool", "name": "BIsPhoneIdentifying", "argsstr": "", "args": [], "nargs": 0, "vfindex": 27}, {"comments": "Gets whether the users phone number is awaiting (re)verification", "retval": "bool", "name": "BIsPhoneRequiringVerification", "argsstr": "", "args": [], "nargs": 0, "vfindex": 28}], "cppinterface": "STEAMUSER_INTERFACE_VERSION", "cppinterfacev": "SteamUser019", "cppclass": "ISteamUser"}, "ISteamUserStats": {"funcs": [{"comments": "Ask the server to send down this user's data and achievements for this game\nCALL_BACK( UserStatsReceived_t )", "retval": "bool", "name": "RequestCurrentStats", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"comments": "Data accessors", "retval": "bool", "name": "GetStat", "argsstr": "const char *pchName, int32 *pData", "nargs": 2, "args": [["constchar*", "pchName"], ["int32*", "pData"]], "vfindex": 1}, {"retval": "bool", "name": "GetStat", "argsstr": "const char *pchName, float *pData", "nargs": 2, "args": [["constchar*", "pchName"], ["float*", "pData"]], "vfindex": 2}, {"comments": "Set / update data", "retval": "bool", "name": "SetStat", "argsstr": "const char *pchName, int32 nData", "nargs": 2, "args": [["constchar*", "pchName"], ["int32", "nData"]], "vfindex": 3}, {"retval": "bool", "name": "SetStat", "argsstr": "const char *pchName, float fData", "nargs": 2, "args": [["constchar*", "pchName"], ["float", "fData"]], "vfindex": 4}, {"retval": "bool", "name": "UpdateAvgRateStat", "argsstr": "const char *pchName, float flCountThisSession, double dSessionLength", "nargs": 3, "args": [["constchar*", "pchName"], ["float", "flCountThisSession"], ["double", "dSessionLength"]], "vfindex": 5}, {"comments": "Achievement flag accessors", "retval": "bool", "name": "GetAchievement", "argsstr": "const char *pchName, bool *pbAchieved", "nargs": 2, "args": [["constchar*", "pchName"], ["bool*", "pbAchieved"]], "vfindex": 6}, {"retval": "bool", "name": "SetAchievement", "argsstr": "const char *pchName", "nargs": 1, "args": [["constchar*", "pchName"]], "vfindex": 7}, {"retval": "bool", "name": "ClearAchievement", "argsstr": "const char *pchName", "nargs": 1, "args": [["constchar*", "pchName"]], "vfindex": 8}, {"comments": "Get the achievement status, and the time it was unlocked if unlocked.\n If the return value is true, but the unlock time is zero, that means it was unlocked before Steam \n began tracking achievement unlock times (December 2009). Time is seconds since January 1, 1970.", "retval": "bool", "name": "GetAchievementAndUnlockTime", "argsstr": "const char *pchName, bool *pbAchieved, uint32 *punUnlockTime", "nargs": 3, "args": [["constchar*", "pchName"], ["bool*", "pbAchieved"], ["uint32*", "punUnlockTime"]], "vfindex": 9}, {"comments": "Store the current data on the server, will get a callback when set\n And one callback for every new achievement\n\n If the callback has a result of k_EResultInvalidParam, one or more stats \n uploaded has been rejected, either because they broke constraints\n or were out of date. In this case the server sends back updated values.\n The stats should be re-iterated to keep in sync.", "retval": "bool", "name": "StoreStats", "argsstr": "", "args": [], "nargs": 0, "vfindex": 10}, {"comments": "Achievement / GroupAchievement metadata\n\n Gets the icon of the achievement, which is a handle to be used in ISteamUtils::GetImageRGBA(), or 0 if none set. \n A return value of 0 may indicate we are still fetching data, and you can wait for the UserAchievementIconFetched_t callback\n which will notify you when the bits are ready. If the callback still returns zero, then there is no image set for the\n specified achievement.", "retval": "int", "name": "GetAchievementIcon", "argsstr": "const char *pchName", "nargs": 1, "args": [["constchar*", "pchName"]], "vfindex": 11}, {"comments": "Get general attributes for an achievement. Accepts the following keys:\n - \"name\" and \"desc\" for retrieving the localized achievement name and description (returned in UTF8)\n - \"hidden\" for retrieving if an achievement is hidden (returns \"0\" when not hidden, \"1\" when hidden)", "retval": "const char *", "name": "GetAchievementDisplayAttribute", "argsstr": "const char *pchName, const char *pchKey", "nargs": 2, "args": [["constchar*", "pchName"], ["constchar*", "pchKey"]], "vfindex": 12}, {"comments": "Achievement progress - triggers an AchievementProgress callback, that is all.\n Calling this w/ N out of N progress will NOT set the achievement, the game must still do that.", "retval": "bool", "name": "IndicateAchievementProgress", "argsstr": "const char *pchName, uint32 nCurProgress, uint32 nMaxProgress", "nargs": 3, "args": [["constchar*", "pchName"], ["uint32", "nCurProgress"], ["uint32", "nMaxProgress"]], "vfindex": 13}, {"comments": "Used for iterating achievements. In general games should not need these functions because they should have a\n list of existing achievements compiled into them", "retval": "uint32", "name": "GetNumAchievements", "argsstr": "", "args": [], "nargs": 0, "vfindex": 14}, {"comments": "Get achievement name iAchievement in [0,GetNumAchievements)", "retval": "const char *", "name": "GetAchievementName", "argsstr": "uint32 iAchievement", "nargs": 1, "args": [["uint32", "iAchievement"]], "vfindex": 15}, {"comments": "Friends stats & achievements\n\n downloads stats for the user\n returns a UserStatsReceived_t received when completed\n if the other user has no stats, UserStatsReceived_t.m_eResult will be set to k_EResultFail\n these stats won't be auto-updated; you'll need to call RequestUserStats() again to refresh any data\nCALL_RESULT( UserStatsReceived_t )", "retval": "SteamAPICall_t", "name": "RequestUserStats", "argsstr": "CSteamID steamIDUser", "nargs": 1, "args": [["CSteamID", "steamIDUser"]], "vfindex": 16}, {"comments": "Requests stat information for a user, usable after a successful call to RequestUserStats()", "retval": "bool", "name": "GetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, int32 *pData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["int32*", "pData"]], "vfindex": 17}, {"retval": "bool", "name": "GetUserStat", "argsstr": "CSteamID steamIDUser, const char *pchName, float *pData", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["float*", "pData"]], "vfindex": 18}, {"retval": "bool", "name": "GetUserAchievement", "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved", "nargs": 3, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["bool*", "pbAchieved"]], "vfindex": 19}, {"comments": "See notes for GetAchievementAndUnlockTime above", "retval": "bool", "name": "GetUserAchievementAndUnlockTime", "argsstr": "CSteamID steamIDUser, const char *pchName, bool *pbAchieved, uint32 *punUnlockTime", "nargs": 4, "args": [["CSteamID", "steamIDUser"], ["constchar*", "pchName"], ["bool*", "pbAchieved"], ["uint32*", "punUnlockTime"]], "vfindex": 20}, {"comments": "Reset stats", "retval": "bool", "name": "ResetAllStats", "argsstr": "bool bAchievementsToo", "nargs": 1, "args": [["bool", "bAchievementsToo"]], "vfindex": 21}, {"comments": "Leaderboard functions\n\n asks the Steam back-end for a leaderboard by name, and will create it if it's not yet\n This call is asynchronous, with the result returned in LeaderboardFindResult_t\nCALL_RESULT(LeaderboardFindResult_t)", "retval": "SteamAPICall_t", "name": "FindOrCreateLeaderboard", "argsstr": "const char *pchLeaderboardName, ELeaderboardSortMethod eLeaderboardSortMethod, ELeaderboardDisplayType eLeaderboardDisplayType", "nargs": 3, "args": [["constchar*", "pchLeaderboardName"], ["ELeaderboardSortMethod", "eLeaderboardSortMethod"], ["ELeaderboardDisplayType", "eLeaderboardDisplayType"]], "vfindex": 22}, {"comments": "As above, but won't create the leaderboard if it's not found\n This call is asynchronous, with the result returned in LeaderboardFindResult_t\nCALL_RESULT( LeaderboardFindResult_t )", "retval": "SteamAPICall_t", "name": "FindLeaderboard", "argsstr": "const char *pchLeaderboardName", "nargs": 1, "args": [["constchar*", "pchLeaderboardName"]], "vfindex": 23}, {"comments": "Returns the name of a leaderboard", "retval": "const char *", "name": "GetLeaderboardName", "argsstr": "SteamLeaderboard_t hSteamLeaderboard", "nargs": 1, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"]], "vfindex": 24}, {"comments": "Returns the total number of entries in a leaderboard, as of the last request", "retval": "int", "name": "GetLeaderboardEntryCount", "argsstr": "SteamLeaderboard_t hSteamLeaderboard", "nargs": 1, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"]], "vfindex": 25}, {"comments": "Returns the sort method of the leaderboard", "retval": "ELeaderboardSortMethod", "name": "GetLeaderboardSortMethod", "argsstr": "SteamLeaderboard_t hSteamLeaderboard", "nargs": 1, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"]], "vfindex": 26}, {"comments": "Returns the display type of the leaderboard", "retval": "ELeaderboardDisplayType", "name": "GetLeaderboardDisplayType", "argsstr": "SteamLeaderboard_t hSteamLeaderboard", "nargs": 1, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"]], "vfindex": 27}, {"comments": "Asks the Steam back-end for a set of rows in the leaderboard.\n This call is asynchronous, with the result returned in LeaderboardScoresDownloaded_t\n LeaderboardScoresDownloaded_t will contain a handle to pull the results from GetDownloadedLeaderboardEntries() (below)\n You can ask for more entries than exist, and it will return as many as do exist.\n k_ELeaderboardDataRequestGlobal requests rows in the leaderboard from the full table, with nRangeStart & nRangeEnd in the range [1, TotalEntries]\n k_ELeaderboardDataRequestGlobalAroundUser requests rows around the current user, nRangeStart being negate\n   e.g. DownloadLeaderboardEntries( hLeaderboard, k_ELeaderboardDataRequestGlobalAroundUser, -3, 3 ) will return 7 rows, 3 before the user, 3 after\n k_ELeaderboardDataRequestFriends requests all the rows for friends of the current user \nCALL_RESULT( LeaderboardScoresDownloaded_t )", "retval": "SteamAPICall_t", "name": "DownloadLeaderboardEntries", "argsstr": "SteamLeaderboard_t hSteamLeaderboard, ELeaderboardDataRequest eLeaderboardDataRequest, int nRangeStart, int nRangeEnd", "nargs": 4, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"], ["ELeaderboardDataRequest", "eLeaderboardDataRequest"], ["int", "nRangeStart"], ["int", "nRangeEnd"]], "vfindex": 28}, {"comments": "As above, but downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers\n if a user doesn't have a leaderboard entry, they won't be included in the result\n a max of 100 users can be downloaded at a time, with only one outstanding call at a time\nMETHOD_DESC(Downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers)\nCALL_RESULT( LeaderboardScoresDownloaded_t )", "retval": "SteamAPICall_t", "name": "DownloadLeaderboardEntriesForUsers", "argsstr": "SteamLeaderboard_t hSteamLeaderboard,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    CSteamID *prgUsers, int cUsers", "nargs": 3, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"], ["CSteamID*", "prgUsers"], ["int", "cUsers"]], "vfindex": 29}, {"comments": "Returns data about a single leaderboard entry\n use a for loop from 0 to LeaderboardScoresDownloaded_t::m_cEntryCount to get all the downloaded entries\n e.g.\nvoid OnLeaderboardScoresDownloaded( LeaderboardScoresDownloaded_t *pLeaderboardScoresDownloaded )\n{\nfor ( int index = 0; index < pLeaderboardScoresDownloaded->m_cEntryCount; index++ )\n{\nLeaderboardEntry_t leaderboardEntry;\nint32 details[3]; we know this is how many we've stored previously\nGetDownloadedLeaderboardEntry( pLeaderboardScoresDownloaded->m_hSteamLeaderboardEntries, index, &leaderboardEntry, details, 3 );\nassert( leaderboardEntry.m_cDetails == 3 );\n...\n}\n once you've accessed all the entries, the data will be free'd, and the SteamLeaderboardEntries_t handle will become invalid", "retval": "bool", "name": "GetDownloadedLeaderboardEntry", "argsstr": "SteamLeaderboardEntries_t hSteamLeaderboardEntries, int index, LeaderboardEntry_t *pLeaderboardEntry, int32 *pDetails, int cDetailsMax", "nargs": 5, "args": [["SteamLeaderboardEntries_t", "hSteamLeaderboardEntries"], ["int", "index"], ["LeaderboardEntry_t*", "pLeaderboardEntry"], ["int32*", "pDetails"], ["int", "cDetailsMax"]], "vfindex": 30}, {"comments": "Uploads a user score to the Steam back-end.\n This call is asynchronous, with the result returned in LeaderboardScoreUploaded_t\n Details are extra game-defined information regarding how the user got that score\n pScoreDetails points to an array of int32's, cScoreDetailsCount is the number of int32's in the list\nCALL_RESULT( LeaderboardScoreUploaded_t )", "retval": "SteamAPICall_t", "name": "UploadLeaderboardScore", "argsstr": "SteamLeaderboard_t hSteamLeaderboard, ELeaderboardUploadScoreMethod eLeaderboardUploadScoreMethod, int32 nScore, const int32 *pScoreDetails, int cScoreDetailsCount", "nargs": 5, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"], ["ELeaderboardUploadScoreMethod", "eLeaderboardUploadScoreMethod"], ["int32", "nScore"], ["constint32*", "pScoreDetails"], ["int", "cScoreDetailsCount"]], "vfindex": 31}, {"comments": "Attaches a piece of user generated content the user's entry on a leaderboard.\n hContent is a handle to a piece of user generated content that was shared using ISteamUserRemoteStorage::FileShare().\n This call is asynchronous, with the result returned in LeaderboardUGCSet_t.\nCALL_RESULT( LeaderboardUGCSet_t )", "retval": "SteamAPICall_t", "name": "AttachLeaderboardUGC", "argsstr": "SteamLeaderboard_t hSteamLeaderboard, UGCHandle_t hUGC", "nargs": 2, "args": [["SteamLeaderboard_t", "hSteamLeaderboard"], ["UGCHandle_t", "hUGC"]], "vfindex": 32}, {"comments": "Retrieves the number of players currently playing your game (online + offline)\n This call is asynchronous, with the result returned in NumberOfCurrentPlayers_t\nCALL_RESULT( NumberOfCurrentPlayers_t )", "retval": "SteamAPICall_t", "name": "GetNumberOfCurrentPlayers", "argsstr": "", "args": [], "nargs": 0, "vfindex": 33}, {"comments": "Requests that Steam fetch data on the percentage of players who have received each achievement\n for the game globally.\n This call is asynchronous, with the result returned in GlobalAchievementPercentagesReady_t.\nCALL_RESULT( GlobalAchievementPercentagesReady_t )", "retval": "SteamAPICall_t", "name": "RequestGlobalAchievementPercentages", "argsstr": "", "args": [], "nargs": 0, "vfindex": 34}, {"comments": "Get the info on the most achieved achievement for the game, returns an iterator index you can use to fetch\n the next most achieved afterwards.  Will return -1 if there is no data on achievement \n percentages (ie, you haven't called RequestGlobalAchievementPercentages and waited on the callback).", "retval": "int", "name": "GetMostAchievedAchievementInfo", "argsstr": "char *pchName, uint32 unNameBufLen, float *pflPercent, bool *pbAchieved", "nargs": 4, "args": [["char*", "pchName"], ["uint32", "unNameBufLen"], ["float*", "pflPercent"], ["bool*", "pbAchieved"]], "vfindex": 35}, {"comments": "Get the info on the next most achieved achievement for the game. Call this after GetMostAchievedAchievementInfo or another\n GetNextMostAchievedAchievementInfo call passing the iterator from the previous call. Returns -1 after the last\n achievement has been iterated.", "retval": "int", "name": "GetNextMostAchievedAchievementInfo", "argsstr": "int iIteratorPrevious, char *pchName, uint32 unNameBufLen, float *pflPercent, bool *pbAchieved", "nargs": 5, "args": [["int", "iIteratorPrevious"], ["char*", "pchName"], ["uint32", "unNameBufLen"], ["float*", "pflPercent"], ["bool*", "pbAchieved"]], "vfindex": 36}, {"comments": "Returns the percentage of users who have achieved the specified achievement.", "retval": "bool", "name": "GetAchievementAchievedPercent", "argsstr": "const char *pchName, float *pflPercent", "nargs": 2, "args": [["constchar*", "pchName"], ["float*", "pflPercent"]], "vfindex": 37}, {"comments": "Requests global stats data, which is available for stats marked as \"aggregated\".\n This call is asynchronous, with the results returned in GlobalStatsReceived_t.\n nHistoryDays specifies how many days of day-by-day history to retrieve in addition\n to the overall totals. The limit is 60.\nCALL_RESULT( GlobalStatsReceived_t )", "retval": "SteamAPICall_t", "name": "RequestGlobalStats", "argsstr": "int nHistoryDays", "nargs": 1, "args": [["int", "nHistoryDays"]], "vfindex": 38}, {"comments": "Gets the lifetime totals for an aggregated stat", "retval": "bool", "name": "GetGlobalStat", "argsstr": "const char *pchStatName, int64 *pData", "nargs": 2, "args": [["constchar*", "pchStatName"], ["int64*", "pData"]], "vfindex": 39}, {"retval": "bool", "name": "GetGlobalStat", "argsstr": "const char *pchStatName, double *pData", "nargs": 2, "args": [["constchar*", "pchStatName"], ["double*", "pData"]], "vfindex": 40}, {"comments": "Gets history for an aggregated stat. pData will be filled with daily values, starting with today.\n So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, \n etc. cubData is the size in bytes of the pubData buffer. Returns the number of \n elements actually set.", "retval": "int32", "name": "GetGlobalStatHistory", "argsstr": "const char *pchStatName,  int64 *pData, uint32 cubData", "nargs": 3, "args": [["constchar*", "pchStatName"], ["int64*", "pData"], ["uint32", "cubData"]], "vfindex": 41}, {"retval": "int32", "name": "GetGlobalStatHistory", "argsstr": "const char *pchStatName,  double *pData, uint32 cubData", "nargs": 3, "args": [["constchar*", "pchStatName"], ["double*", "pData"], ["uint32", "cubData"]], "vfindex": 42}, {"comments": "Call to kick off installation of the PS3 trophies. This call is asynchronous, and the results will be returned in a PS3TrophiesInstalled_t\n callback.", "retval": "bool", "name": "InstallPS3Trophies", "argsstr": "", "args": [], "nargs": 0, "vfindex": 43}, {"comments": "Returns the amount of space required at boot to install trophies. This value can be used when comparing the amount of space needed\n by the game to the available space value passed to the game at boot. The value is set during InstallPS3Trophies().", "retval": "uint64", "name": "GetTrophySpaceRequiredBeforeInstall", "argsstr": "", "args": [], "nargs": 0, "vfindex": 44}, {"comments": "On PS3, user stats & achievement progress through Steam must be stored with the user's saved game data.\n At startup, before calling RequestCurrentStats(), you must pass the user's stats data to Steam via this method.\n If you do not have any user data, call this function with pvData = NULL and cubData = 0", "retval": "bool", "name": "SetUserStatsData", "argsstr": "const void *pvData, uint32 cubData", "nargs": 2, "args": [["constvoid*", "pvData"], ["uint32", "cubData"]], "vfindex": 45}, {"comments": "Call to get the user's current stats data. You should retrieve this data after receiving successful UserStatsReceived_t & UserStatsStored_t\n callbacks, and store the data with the user's save game data. You can call this method with pvData = NULL and cubData = 0 to get the required\n buffer size.", "retval": "bool", "name": "GetUserStatsData", "argsstr": "void *pvData, uint32 cubData, uint32 *pcubWritten", "nargs": 3, "args": [["void*", "pvData"], ["uint32", "cubData"], ["uint32*", "pcubWritten"]], "vfindex": 46}], "cppinterface": "STEAMUSERSTATS_INTERFACE_VERSION", "cppinterfacev": "STEAMUSERSTATS_INTERFACE_VERSION011", "cppclass": "ISteamUserStats"}, "ISteamUtils": {"funcs": [{"comments": "Return the number of seconds since the user", "retval": "uint32", "name": "GetSecondsSinceAppActive", "argsstr": "", "args": [], "nargs": 0, "vfindex": 0}, {"retval": "uint32", "name": "GetSecondsSinceComputerActive", "argsstr": "", "args": [], "nargs": 0, "vfindex": 1}, {"comments": "The universe this client is connecting to", "retval": "EUniverse", "name": "GetConnectedUniverse", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "Steam server time.  Number of seconds since January 1, 1970, GMT (i.e unix time)", "retval": "uint32", "name": "GetServerRealTime", "argsstr": "", "args": [], "nargs": 0, "vfindex": 3}, {"comments": "Returns the 2 digit ISO 3166-1-alpha-2 format country code this client is running in (as looked up via an IP-to-location database)\n e.g \"US\" or \"UK\".", "retval": "const char *", "name": "GetIPCountry", "argsstr": "", "args": [], "nargs": 0, "vfindex": 4}, {"comments": "Returns true if the image exists, and valid sizes were filled out", "retval": "bool", "name": "GetImageSize", "argsstr": "int iImage, uint32 *pnWidth, uint32 *pnHeight", "nargs": 3, "args": [["int", "iImage"], ["uint32*", "pnWidth"], ["uint32*", "pnHeight"]], "vfindex": 5}, {"comments": "Returns true if the image exists, and the buffer was successfully filled out\n results are returned in RGBA format\n the destination buffer size should be 4 * height * width * sizeof(char)", "retval": "bool", "name": "GetImageRGBA", "argsstr": "int iImage, uint8 *pubDest, int nDestBufferSize", "nargs": 3, "args": [["int", "iImage"], ["uint8*", "pubDest"], ["int", "nDestBufferSize"]], "vfindex": 6}, {"comments": "Returns the IP of the reporting server for valve - currently only used in Source engine games", "retval": "bool", "name": "GetCSERIPPort", "argsstr": "uint32 *unIP, uint16 *usPort", "nargs": 2, "args": [["uint32*", "unIP"], ["uint16*", "usPort"]], "vfindex": 7}, {"comments": "Return the amount of battery power left in the current system in % [0..100], 255 for being on AC power", "retval": "uint8", "name": "GetCurrentBatteryPower", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}, {"comments": "Returns the appID of the current process", "retval": "uint32", "name": "GetAppID", "argsstr": "", "args": [], "nargs": 0, "vfindex": 9}, {"comments": "Sets the position where the overlay instance for the currently calling game should show notifications.\n This position is per-game and if this function is called from outside of a game context it will do nothing.", "retval": "void", "name": "SetOverlayNotificationPosition", "argsstr": "ENotificationPosition eNotificationPosition", "nargs": 1, "args": [["ENotificationPosition", "eNotificationPosition"]], "vfindex": 10}, {"comments": "API asynchronous call results\n can be used directly, but more commonly used via the callback dispatch API (see steam_api.h)", "retval": "bool", "name": "IsAPICallCompleted", "argsstr": "SteamAPICall_t hSteamAPICall, bool *pbFailed", "nargs": 2, "args": [["SteamAPICall_t", "hSteamAPICall"], ["bool*", "pbFailed"]], "vfindex": 11}, {"retval": "ESteamAPICallFailure", "name": "GetAPICallFailureReason", "argsstr": "SteamAPICall_t hSteamAPICall", "nargs": 1, "args": [["SteamAPICall_t", "hSteamAPICall"]], "vfindex": 12}, {"retval": "bool", "name": "GetAPICallResult", "argsstr": "SteamAPICall_t hSteamAPICall, void *pCallback, int cubCallback, int iCallbackExpected, bool *pbFailed", "nargs": 5, "args": [["SteamAPICall_t", "hSteamAPICall"], ["void*", "pCallback"], ["int", "cubCallback"], ["int", "iCallbackExpected"], ["bool*", "pbFailed"]], "vfindex": 13}, {"comments": "Deprecated. Applications should use SteamAPI_RunCallbacks() instead. Game servers do not need to call this function.\nSTEAM_PRIVATE_API(", "retval": "void", "name": "RunFrame", "argsstr": "", "args": [], "nargs": 0, "vfindex": 14}, {"comments": "Returns the number of IPC calls made since the last time this function was called\n Used for perf debugging so you can understand how many IPC calls your game makes per frame\n Every IPC call is at minimum a thread context switch if not a process one so you want to rate\n control how often you do them.", "retval": "uint32", "name": "GetIPCCallCount", "argsstr": "", "args": [], "nargs": 0, "vfindex": 15}, {"comments": "API warning handling\n 'int' is the severity; 0 for msg, 1 for warning\n 'const char *' is the text of the message\n callbacks will occur directly after the API function is called that generated the warning or message", "retval": "void", "name": "SetWarningMessageHook", "argsstr": "SteamAPIWarningMessageHook_t pFunction", "nargs": 1, "args": [["SteamAPIWarningMessageHook_t", "pFunction"]], "vfindex": 16}, {"comments": "Returns true if the overlay is running & the user can access it. The overlay process could take a few seconds to\n start & hook the game process, so this function will initially return false while the overlay is loading.", "retval": "bool", "name": "IsOverlayEnabled", "argsstr": "", "args": [], "nargs": 0, "vfindex": 17}, {"comments": "Normally this call is unneeded if your game has a constantly running frame loop that calls the \n D3D Present API, or OGL SwapBuffers API every frame.\n\n However, if you have a game that only refreshes the screen on an event driven basis then that can break \n the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also\n need to Present() to the screen any time an even needing a notification happens or when the overlay is\n brought up over the game by a user.  You can use this API to ask the overlay if it currently need a present\n in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you\n refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.", "retval": "bool", "name": "BOverlayNeedsPresent", "argsstr": "", "args": [], "nargs": 0, "vfindex": 18}, {"comments": "Asynchronous call to check if an executable file has been signed using the public key set on the signing tab\n of the partner site, for example to refuse to load modified executable files.  \n The result is returned in CheckFileSignature_t.\n   k_ECheckFileSignatureNoSignaturesFoundForThisApp - This app has not been configured on the signing tab of the partner site to enable this function.\n   k_ECheckFileSignatureNoSignaturesFoundForThisFile - This file is not listed on the signing tab for the partner site.\n   k_ECheckFileSignatureFileNotFound - The file does not exist on disk.\n   k_ECheckFileSignatureInvalidSignature - The file exists, and the signing tab has been set for this file, but the file is either not signed or the signature does not match.\n   k_ECheckFileSignatureValidSignature - The file is signed and the signature is valid.\nCALL_RESULT( CheckFileSignature_t )", "retval": "SteamAPICall_t", "name": "CheckFileSignature", "argsstr": "const char *szFileName", "nargs": 1, "args": [["constchar*", "szFileName"]], "vfindex": 19}, {"comments": "Activates the Big Picture text input dialog which only supports gamepad input", "retval": "bool", "name": "ShowGamepadTextInput", "argsstr": "EGamepadTextInputMode eInputMode, EGamepadTextInputLineMode eLineInputMode, const char *pchDescription, uint32 unCharMax, const char *pchExistingText", "nargs": 5, "args": [["EGamepadTextInputMode", "eInputMode"], ["EGamepadTextInputLineMode", "eLineInputMode"], ["constchar*", "pchDescription"], ["uint32", "unCharMax"], ["constchar*", "pchExistingText"]], "vfindex": 20}, {"comments": "Returns previously entered text & length", "retval": "uint32", "name": "GetEnteredGamepadTextLength", "argsstr": "", "args": [], "nargs": 0, "vfindex": 21}, {"retval": "bool", "name": "GetEnteredGamepadTextInput", "argsstr": "char *pchText, uint32 cchText", "nargs": 2, "args": [["char*", "pchText"], ["uint32", "cchText"]], "vfindex": 22}, {"comments": "Returns the language the steam client is running in, you probably want ISteamApps::GetCurrentGameLanguage instead, this is for very special usage cases", "retval": "const char *", "name": "GetSteamUILanguage", "argsstr": "", "args": [], "nargs": 0, "vfindex": 23}, {"comments": "Returns true if Steam itself is running in VR mode", "retval": "bool", "name": "IsSteamRunningInVR", "argsstr": "", "args": [], "nargs": 0, "vfindex": 24}, {"comments": "Sets the inset of the overlay notification from the corner specified by SetOverlayNotificationPosition.", "retval": "void", "name": "SetOverlayNotificationInset", "argsstr": "int nHorizontalInset, int nVerticalInset", "nargs": 2, "args": [["int", "nHorizontalInset"], ["int", "nVerticalInset"]], "vfindex": 25}, {"comments": "Returns true if Steam & the Steam Overlay are running in Big Picture mode\n Games much be launched through the Steam client to enable the Big Picture overlay. During development,\n a game can be added as a non-steam game to the developers library to test this feature", "retval": "bool", "name": "IsSteamInBigPictureMode", "argsstr": "", "args": [], "nargs": 0, "vfindex": 26}, {"comments": "Ask SteamUI to create and render its OpenVR dashboard", "retval": "void", "name": "StartVRDashboard", "argsstr": "", "args": [], "nargs": 0, "vfindex": 27}, {"comments": "Returns true if the HMD content will be streamed via Steam In-Home Streaming", "retval": "bool", "name": "IsVRHeadsetStreamingEnabled", "argsstr": "", "args": [], "nargs": 0, "vfindex": 28}, {"comments": "Set whether the HMD content will be streamed via Steam In-Home Streaming\n If this is set to true, then the scene in the HMD headset will be streamed, and remote input will not be allowed.\n If this is set to false, then the application window will be streamed instead, and remote input will be allowed.\n The default is true unless \"VRHeadsetStreaming\" \"0\" is in the extended appinfo for a game.\n (this is useful for games that have asymmetric multiplayer gameplay)", "retval": "void", "name": "SetVRHeadsetStreamingEnabled", "argsstr": "bool bEnabled", "nargs": 1, "args": [["bool", "bEnabled"]], "vfindex": 29}], "cppinterface": "STEAMUTILS_INTERFACE_VERSION", "cppinterfacev": "SteamUtils009", "cppclass": "ISteamUtils"}, "ISteamVideo": {"funcs": [{"comments": "Get a URL suitable for streaming the given Video app ID's video", "retval": "void", "name": "GetVideoURL", "argsstr": "AppId_t unVideoAppID", "nargs": 1, "args": [["AppId_t", "unVideoAppID"]], "vfindex": 0}, {"comments": "Returns true if user is uploading a live broadcast", "retval": "bool", "name": "IsBroadcasting", "argsstr": "int *pnNumViewers", "nargs": 1, "args": [["int*", "pnNumViewers"]], "vfindex": 1}, {"comments": "Get the OPF Details for 360 Video Playback\nCALL_BACK( GetOPFSettingsResult_t )", "retval": "void", "name": "GetOPFSettings", "argsstr": "AppId_t unVideoAppID", "nargs": 1, "args": [["AppId_t", "unVideoAppID"]], "vfindex": 2}, {"retval": "bool", "name": "GetOPFStringForApp", "argsstr": "AppId_t unVideoAppID, char *pchBuffer, int32 *pnBufferSize", "nargs": 3, "args": [["AppId_t", "unVideoAppID"], ["char*", "pchBuffer"], ["int32*", "pnBufferSize"]], "vfindex": 3}], "cppinterface": "STEAMVIDEO_INTERFACE_VERSION", "cppinterfacev": "STEAMVIDEO_INTERFACE_V002", "cppclass": "ISteamVideo"}, "CSteamAPIContext": {"funcs": [{"comments": "DEPRECATED - there is no benefit to using this over the global accessors\nCSteamAPIContext() { Clear(); }\nvoid Clear();\nbool Init();\nISteamClient*SteamClient() const{ return m_pSteamClient; }\nISteamUser*SteamUser() const{ return m_pSteamUser; }\nISteamFriends*SteamFriends() const{ return m_pSteamFriends; }\nISteamUtils*SteamUtils() const{ return m_pSteamUtils; }\nISteamMatchmaking*SteamMatchmaking() const{ return m_pSteamMatchmaking; }\nISteamUserStats*SteamUserStats() const{ return m_pSteamUserStats; }\nISteamApps*SteamApps() const{ return m_pSteamApps; }\nISteamMatchmakingServers* SteamMatchmakingServers() const { return m_pSteamMatchmakingServers; }\nISteamNetworking*SteamNetworking() const{ return m_pSteamNetworking; }\nISteamRemoteStorage* SteamRemoteStorage() const{ return m_pSteamRemoteStorage; }\nISteamScreenshots*SteamScreenshots() const{ return m_pSteamScreenshots; }\nISteamHTTP*SteamHTTP() const{ return m_pSteamHTTP; }\nISteamController*SteamController() const{ return m_pController; }\nISteamUGC*SteamUGC() const{ return m_pSteamUGC; }\nISteamAppList*SteamAppList() const{ return m_pSteamAppList; }\nISteamMusic*SteamMusic() const{ return m_pSteamMusic; }\nISteamMusicRemote*SteamMusicRemote() const{ return m_pSteamMusicRemote; }\nISteamHTMLSurface*SteamHTMLSurface() const{ return m_pSteamHTMLSurface; }\nISteamInventory*SteamInventory() const{ return m_pSteamInventory; }\nISteamVideo*SteamVideo() const{ return m_pSteamVideo; }\nISteamParentalSettings* SteamParentalSettings() const{ return m_pSteamParentalSettings; }\n DEPRECATED - there is no benefit to using this over the global accessors\nprivate:\nISteamClient*m_pSteamClient;\nISteamUser*m_pSteamUser;\nISteamFriends*m_pSteamFriends;\nISteamUtils*m_pSteamUtils;\nISteamMatchmaking*m_pSteamMatchmaking;\nISteamUserStats*m_pSteamUserStats;\nISteamApps*m_pSteamApps;\nISteamMatchmakingServers *m_pSteamMatchmakingServers;\nISteamNetworking*m_pSteamNetworking;\nISteamRemoteStorage *m_pSteamRemoteStorage;\nISteamScreenshots*m_pSteamScreenshots;\nISteamHTTP*m_pSteamHTTP;\nISteamController*m_pController;\nISteamUGC*m_pSteamUGC;\nISteamAppList*m_pSteamAppList;\nISteamMusic*m_pSteamMusic;\nISteamMusicRemote*m_pSteamMusicRemote;\nISteamHTMLSurface*m_pSteamHTMLSurface;\nISteamInventory*m_pSteamInventory;\nISteamVideo*m_pSteamVideo;\nISteamParentalSettings *m_pSteamParentalSettings;\n};\n\n\n----------------------------------------------------------------------------------------------------------------------------------------------------------\nsteam callback and call-result helpers\n\nThe following macros and classes are used to register your application for\ncallbacks and call-results, which are delivered in a predictable manner.\n\nSTEAM_CALLBACK macros are meant for use inside of a C++ class definition.\nThey map a Steam notification callback directly to a class member function\nwhich is automatically prototyped as \"void func( callback_type *pParam )\".\n\nCCallResult is used with specific Steam APIs that return \"result handles\".\nThe handle can be passed to a CCallResult object's Set function, along with\nan object pointer and member-function pointer. The member function will\nbe executed once the results of the Steam API call are available.\n\nCCallback and CCallbackManual classes can be used instead of STEAM_CALLBACK\nmacros if you require finer control over registration and unregistration.\n\nCallbacks and call-results are queued automatically and are only\ndelivered/executed when your application calls SteamAPI_RunCallbacks().\n----------------------------------------------------------------------------------------------------------------------------------------------------------\n\n SteamAPI_RunCallbacks is safe to call from multiple threads simultaneously,\n but if you choose to do this, callback code could be executed on any thread.\n One alternative is to call SteamAPI_RunCallbacks from the main thread only,\n and call SteamAPI_ReleaseCurrentThreadMemory regularly on other threads.\nS_API void S_CALLTYPE SteamAPI_RunCallbacks();\n\n\n Declares a callback member function plus a helper member variable which\n registers the callback on object creation and unregisters on destruction.\n The optional fourth 'var' param exists only for backwards-compatibility\n and can be ignored.\n#define STEAM_CALLBACK( thisclass, func, .../*callback_type, [deprecated] var*/ ) \\\n_STEAM_CALLBACK_SELECT( ( __VA_ARGS__, 4, 3 ), ( /**/, thisclass, func, __VA_ARGS__ ) )\n\n Declares a callback function and a named CCallbackManual variable which\n has Register and Unregister functions instead of automatic registration.\n#define STEAM_CALLBACK_MANUAL( thisclass, func, callback_type, var )\\\nCCallbackManual< thisclass, callback_type > var; void func( callback_type *pParam )\n\n\n Internal functions used by the utility CCallback objects to receive callbacks\nS_API void S_CALLTYPE SteamAPI_RegisterCallback( class CCallbackBase *pCallback, int iCallback );\nS_API void S_CALLTYPE SteamAPI_UnregisterCallback( class CCallbackBase *pCallback );\n Internal functions used by the utility CCallResult objects to receive async call results\nS_API void S_CALLTYPE SteamAPI_RegisterCallResult( class CCallbackBase *pCallback, SteamAPICall_t hAPICall );\nS_API void S_CALLTYPE SteamAPI_UnregisterCallResult( class CCallbackBase *pCallback, SteamAPICall_t hAPICall );\n\n\n-----------------------------------------------------------------------------\n Purpose: base for callbacks and call results - internal implementation detail\n-----------------------------------------------------------------------------\nclass CCallbackBase\n{\npublic:\nCCallbackBase() { m_nCallbackFlags = 0; m_iCallback = 0; }\n don't add a virtual destructor because we export this binary interface across dll's", "retval": "void", "name": "Run", "argsstr": "void *pvParam", "nargs": 1, "args": [["void*", "pvParam"]], "vfindex": 0}, {"retval": "void", "name": "Run", "argsstr": "void *pvParam, bool bIOFailure, SteamAPICall_t hSteamAPICall", "nargs": 3, "args": [["void*", "pvParam"], ["bool", "bIOFailure"], ["SteamAPICall_t", "hSteamAPICall"]], "vfindex": 1}, {"retval": "int", "name": "GetCallbackSizeBytes", "argsstr": "", "args": [], "nargs": 0, "vfindex": 2}, {"comments": "-----------------------------------------------------------------------------\n Purpose: templated base for callbacks - internal implementation detail\n-----------------------------------------------------------------------------\ntemplate< int sizeof_P >\nclass CCallbackImpl : protected CCallbackBase\n{\npublic:\n~CCallbackImpl() { if ( m_nCallbackFlags & k_ECallbackFlagsRegistered ) SteamAPI_UnregisterCallback( this ); }\nvoid SetGameserverFlag() { m_nCallbackFlags |= k_ECallbackFlagsGameServer; }\n\nprotected:", "retval": "void", "name": "Run", "argsstr": "void *pvParam", "nargs": 1, "args": [["void*", "pvParam"]], "vfindex": 3}, {"retval": "void", "name": "Run", "argsstr": "void *pvParam, bool /*bIOFailure*/, SteamAPICall_t /*hSteamAPICall*/", "nargs": 3, "args": [["void*", "pvParam"], ["bool", "/*bIOFailure*/"], ["SteamAPICall_t", "/*hSteamAPICall*/"]], "vfindex": 4}, {"retval": "int", "name": "GetCallbackSizeBytes", "argsstr": "", "args": [], "nargs": 0, "vfindex": 5}, {"comments": "-----------------------------------------------------------------------------\n Purpose: maps a steam async call result to a class member function\ntemplate params: T = local class, P = parameter struct\n-----------------------------------------------------------------------------\ntemplate< class T, class P >\nclass CCallResult : private CCallbackBase\n{\npublic:\ntypedef void (T::*func_t)( P*, bool );\n\nCCallResult();\n~CCallResult();\n\nvoid Set( SteamAPICall_t hAPICall, T *p, func_t func );\nbool IsActive() const;\nvoid Cancel();\n\nvoid SetGameserverFlag() { m_nCallbackFlags |= k_ECallbackFlagsGameServer; }\nprivate:", "retval": "void", "name": "Run", "argsstr": "void *pvParam", "nargs": 1, "args": [["void*", "pvParam"]], "vfindex": 6}, {"retval": "void", "name": "Run", "argsstr": "void *pvParam, bool bIOFailure, SteamAPICall_t hSteamAPICall", "nargs": 3, "args": [["void*", "pvParam"], ["bool", "bIOFailure"], ["SteamAPICall_t", "hSteamAPICall"]], "vfindex": 7}, {"retval": "int", "name": "GetCallbackSizeBytes", "argsstr": "", "args": [], "nargs": 0, "vfindex": 8}, {"comments": "-----------------------------------------------------------------------------\n Purpose: maps a steam callback to a class member function\ntemplate params: T = local class, P = parameter struct,\nbGameserver = listen for gameserver callbacks instead of client callbacks\n-----------------------------------------------------------------------------\ntemplate< class T, class P, bool bGameserver = false >\nclass CCallback : public CCallbackImpl< sizeof( P ) >\n{\npublic:\ntypedef void (T::*func_t)(P*);\n\n NOTE: If you can't provide the correct parameters at construction time, you should\n use the CCallbackManual callback object (STEAM_CALLBACK_MANUAL macro) instead.\nCCallback( T *pObj, func_t func );\n\nvoid Register( T *pObj, func_t func );\nvoid Unregister();\n\nprotected:", "retval": "void", "name": "Run", "argsstr": "void *pvParam", "nargs": 1, "args": [["void*", "pvParam"]], "vfindex": 9}], "cppinterface": null, "cppinterfacev": null, "cppclass": "CSteamAPIContext"}}